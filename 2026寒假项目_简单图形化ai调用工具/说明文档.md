# 简单图形化AI调用工具说明文档

## 1. 项目概述

本项目是一个使用Python+Flask开发的简单图形化AI调用工具，旨在通过可视化界面简化AI模型的调用和流程编排。

### 1.1 核心功能

1. **拖拽式模块配置**：通过拖拽方式设置"模块"，每个模块有输入输出接口
2. **连线式流程定义**：通过连线设定运行顺序、测试和数据流向
3. **一键代码转换**：将图形化编程结果一键转换为对应"python代码"
4. **自定义模块支持**：支持自定义模块并配有图形化的编程工具
5. **运行状态可视化**：连线上自动标出在第几步"运行"，黄色圆圈表示当前运行状态
6. **连线状态同步**：当模块位置或画布缩放/拖拽时，连线上的运行状态标记会自动更新位置
7. **模块库管理**：提供输入模块、调用模块、处理模块等多种模块类型，支持自定义模块
8. **连线颜色切换**：用户可以通过双击连线切换红黑色
9. **运行模式支持**：支持步进运行和连续运行

### 1.2 技术栈

- **后端**：Python + Flask
- **前端**：HTML/JavaScript (具体实现见前端模块)
- **模块管理**：自定义模块系统

## 2. 系统架构

### 2.1 界面布局

根据示意图，系统界面布局如下：

1. **左侧模块库**：
   - 输入模块
   - 调用模块
   - 处理模块
   - 输出模块
   - 自定义模块（可扩展）

2. **中央画布**：
   - 用于拖拽放置模块
   - 用于绘制模块间的连接线
   - 显示运行状态和流程

3. **右侧对话面板**：
   - 对话功能：提供给用户一个使用自己设计的调用方式的地方
   - 对话双方：用户和AI
   - 数据流向：用户输入将作为输入模块（user输入）的数据输出，AI的回答来自"对话输出"模块
   - 上下文说明：这里看到的上下文是展示使用，LLM实际使用的上下文看的是调用模块

4. **顶部控制面板**：
   - 运行控制：开始、暂停、停止
   - 代码生成：一键转换为Python代码
   - 项目管理：新建、保存、加载

### 2.2 文件结构

```
├── app.py                # 主应用文件
├── templates/
│   └── main.html         # 前端页面
├── default_modules/      # 内置默认模块
│   └── 调用模块.py        # 调用模块示例
├── custom_modules/       # 用户自定义模块
└── auto_save/            # 自动保存目录
    └── ai_tool_project_时间戳.aiud  # 项目配置文件
```

### 2.3 模块类型

1. **输入模块**：负责数据输入，支持固定输入和外部输入
2. **处理模块**：负责数据处理、转换和条件判断
   - 包含判断功能：负责条件判断和分支控制
3. **调用模块**：负责调用AI模型或其他外部服务
4. **输出模块**：负责结果输出和展示

### 2.4 项目文件格式

#### 一、保存

1. **文件基础说明**
项目文件采用 `.aiud` 扩展名，使用 zip 压缩格式，包含以下内容：
- `project.json`：项目配置文件，包含模块信息、连接信息、画布大小等数据
- `custom_modules` 文件夹：包含项目中使用的自定义模块文件

2. **文件结构**
```
.aiud文件 (zip压缩)
├── project.json
└── custom_modules/
    └── 自定义模块.py
```

3. **project.json 结构**
```json
{
  "modules": [
    {
      "id": "模块ID",
      "name": "模块名称",
      "kind": "模块类型",
      "left": "X坐标",
      "top": "Y坐标",
      "moduleData": {
        "name": "模块名称",
        "params": {
          "name": "模块名称",
          "kind": "模块类型",
          "input_quantity": 输入端口数量,
          "output_quantity": 输出端口数量,
          "variables_name": "变量名称",
          "output_name": "输出端口名称"
        }
      },
      "settings": {
        "变量名": "默认值"
      }
    }
  ],
  "connections": [
    {
      "startModuleId": "起始模块ID",
      "startPortIndex": 起始端口索引,
      "endModuleId": "结束模块ID",
      "endPortIndex": 结束端口索引,
      "isRed": 是否为红线
    }
  ],
  "canvasSize": {
    "width": 画布宽度,
    "height": 画布高度
  },
  "timestamp": "保存时间戳",
  "usedCustomModules": ["使用的自定义模块名称列表"]
}
```

4. **字段说明**
- **version**：项目文件版本号，用于版本兼容处理
- **modules**：包含所有模块的信息，每个模块包括ID、名称、类型、坐标、模块数据和设置等。
- **connections**：包含所有连接的信息，每个连接包括起始模块ID、起始端口索引、结束模块ID、结束端口索引和是否为红线等。
- **canvasSize**：包含画布大小信息，包括宽度和高度。
- **timestamp**：保存时间戳，格式为ISO格式。
- **usedCustomModules**：包含项目中使用的自定义模块名称列表。

5. **版本兼容处理**
- 系统会自动处理不同版本的项目文件
- 对于缺失字段，会使用默认值进行填充
- 支持从旧版本项目文件平滑升级到新版本

#### 二、模块运行与加载规则


默认加载规则：在 app.py 运行时，会自动导入「默认模块文件夹」和「自定义模块文件夹」内的所有模块。

动态更新规则：当用户点击左侧模块库中自定义模块后方的刷新键后，系统会触发刷新，重新加载「自定义模块文件夹」中的所有模块。

导入项目规则：导入项目时，会自动加载项目文件携带的自定义模块，并将这些模块添加到左侧模块库的自定义模块分类中。
- 自定义模块冲突处理：当导入的模块与本地已有同名模块时，系统会：
  1. 采用默认模块优先于自定义模块的原则
  2. 保留从.aiud文件中加载的自定义模块（如果默认模块中不存在）
  3. 确保模块加载的一致性和可靠性

模块删除规则：删除模块时，会直接从模块状态中移除对应的模块ID，并删除与该模块相关的所有连线。

#### 三、编码细节

协议规定：代码的第 1 个模块编号为 0（00000000），模块编号为递增的唯一标识符，删除模块时不会重新编号或前移后续模块编号。

模块ID管理：
- 系统会自动生成唯一的模块ID，避免重复
- 当模块ID达到最大值时，会自动重置为0并重新开始编号，但会跳过已使用的ID
- 删除模块时，会从已使用ID集合中移除对应的ID，以便重用
- 系统维护"已使用ID集合"，确保ID的唯一性

全局变量：00000001OT001 被指定为「子模块第 2 个输出接口」对应的全局变量名，支持自动保存。

### 2.5 模块样式

#### 一、基础样式规范
所有模块默认采用矩形设计，边缘线条清晰锐利，整体风格简洁直观，便于拖拽操作与视觉区分。

样式与尺寸依据：模块的具体样式细节（含功能关键词、贴图图标）、长度、宽度参数，均由对应模块代码文件前 12 行的注释内容指定，实现样式与模块逻辑的关联配置；
- 容错性处理：当注释格式错误或缺失时，系统会：
  1. 加载默认样式（矩形、默认端口数量）
  2. 记录解析错误但继续执行
  3. 为缺失的参数设置合理的默认值

模块内部：通过浅线条划分功能区域（含参数配置区、状态显示区、核心功能区），无重叠遮挡；表面印有模块功能关键词（如 "输入""调用""处理""输出"）及 6 个功能贴图图标，作为模块类型快速识别标识；

端口设计：输入 / 输出端口位于模块侧边缘（输入在左、输出在右），端口为模块侧边缘处的小方形区域，方形内部带有箭头标识：输入端口的箭头指向模块内部，输出端口的箭头指向模块外部，明确数据传输的方向与连线接口位置。

#### 二、特殊边缘样式规则（根据端口数量动态调整）

无输入模块（input_quantity=0）：矩形左侧边缘自动变为圆弧形，取消左侧的 "方形 + 箭头" 输入端口标识，通过形态直观体现 "无输入接口" 的特性；

无输出模块（output_quantity=0）：矩形右侧边缘自动变为圆弧形，取消右侧的 "方形 + 箭头" 输出端口标识，明确 "无输出接口" 的属性；

既有输入又有输出的模块（input_quantity≥1 且 output_quantity≥1）：保持矩形四边直角设计，左右两侧清晰标注 "方形 + 箭头" 的标准化输入 / 输出端口（格式为IN_001/OUT_001），端口标识与模块边缘齐平，便于连线操作。

## 3. 功能说明

### 3.1 线的种类

系统支持两种类型的连接线：

1. **黑线**：
   - 数据传递：数据从A模块到B模块，仅在B模块`excitedbydata=true`（可被数据激活）时继续传递
   - 传输数据时，颜色为红、黄相间

2. **红线**：
   - 在传输数据的同时，让B模块立即激活，用红线表示进程
   - 对于无延迟的模块，会立即执行；对于有延迟的模块，会等待延迟后再执行
   - 传输数据时，颜色为红、黄相间

**连线颜色设置**：
- 连线的红黑色是用户设置的
- 用户可以通过双击连线进行切换

### 3.2 运行方式

- **步进运行**：
  - 仅运行一次，在连线颜色点添加黄色圆圈
  - 点击步进后，向后运行一个步进
  
- **延迟运行**：
  - 步进与数据强传递运行至下一个有延迟模块
  - 延迟运行：上一步完成后隔指定时间，运行下一步

- **自动运行模式**：
  - 当前实现：每一步进执行完毕后自动停止运行，不再使用固定的时间间隔
  - 设计意图：确保每一步进都能完整执行，避免因固定间隔导致的执行不同步问题
  - 执行方式：系统会执行一个完整的步进，包括所有模块的执行和数据传输，然后停止运行

- **暂停功能**：
  - 点击暂停键后，该一步进执行完毕后暂停
  - "步进执行完毕"的判定标准：当前步进内所有模块执行+数据传输完成，且无未完成的延迟等待
  - 暂停后，模块执行会被中断，确保资源不被浪费
  - 暂停时会标记当前执行位置，记录未完成的延迟任务状态
  - 暂停后禁止新的步进启动，直至点击"继续"

- **继续运行**：
  - 点击运行键后继续以自动模式运行
  - 继续运行时会检查模块的执行状态，确保从正确的位置继续

- **边界场景校验**：
  - 无输入端口的模块应该是输入模块或excitedbydata=true的模块
  - 无输出端口的模块应该是输出模块或终点模块
  - 校验失败后的处理逻辑：系统会在执行前进行校验，对于不符合要求的模块，会记录警告信息但继续执行
  - 实现方式：在`executeModule`函数中进行边界场景校验，确保模块配置合理

- **用户输入触发**：
  - 当用户在右侧对话处发送内容后，"user输入模块"输出用户输入的内容，整体开始运行

- **对话输出触发停止**：
  - 当"对话输出"模块接受到内容后，在当前步进执行完毕后，停止运行
  - 清空范围：只清空模块输入/输出端口的业务变量，保留`displayContent`/缓存模块的缓存值
  - 清空时机：在"对话输出模块接收内容后，当前步进执行完毕的瞬间"
  - 实现方式：系统会遍历所有模块状态，清空非缓存模块和显示模块的输入输出值

- **缓存模块执行特性**：
  - 缓存模块在每次步进执行中都会进行一次输出（包括用户输入触发的初始步进）
  - 这一输出会在其他所有数据传输进行前进行
  - 缓存模块在有输入数据时会更新缓存，在无输入数据时会保持原有输出
  - 缓存模块初始化值：默认初始化为null
  - 缓存模块时序冲突处理：当接收到多个输入数据时，会根据时间戳选择最新的数据进行更新
  - 时间戳生成规则：使用系统接收数据时的毫秒级时间戳（Date.now()）
  - 多输入同时到达时的处理：缓存模块维护"输入数据时间戳记录表"，每次接收数据时记录时间戳，更新缓存时对比所有输入的时间戳
  - "最新数据"判定标准：时间戳数值最大的即为最新数据

- **显示模块执行特性**：
  - 显示模块会将输入数据作为输出
  - 显示模块会设置displayContent变量，与实际内容分离
  - 停止运行时，显示模块的displayContent变量会被保留

- **执行流程**：
  1. **初始化**：系统加载所有模块，准备执行环境
  2. **触发运行**：
     - 通过用户输入触发：用户在右侧对话处发送内容，"user输入模块"输出内容
  3. **缓存模块执行**：
     - 缓存模块在每次步进开始时进行输出
     - 这一输出在其他所有数据传输前进行
  4. **模块执行**：
     - 按照连线顺序执行各个模块
     - 每个模块调用其文件中定义的函数
     - 函数输入来自端口变量（按顺序）
     - 函数按序返回输出值，赋值给输出变量
     - 对于显示模块，会设置displayContent变量，与实际内容分离
  5. **数据传输**：
     - 输出值通过连线传输到下一个模块的输入端口
     - 支持一连多（多连一）的连接方式
     - 若为无延迟模块，则继续向后运行
  6. **步进控制**：
     - 自动运行模式：每一步进执行后等待0.2秒，自动运行下一步进
     - 暂停：点击暂停键后，当前步进执行完毕后暂停
     - 继续：点击运行键后继续以自动模式运行
     - 步进：点击步进按钮，向后运行一个步进
  7. **停止运行**：
     - 当"对话输出"模块接受到内容后，在当前步进执行完毕后停止运行
     - 将除了"缓存模块"之外的端口变量全部赋值为空
     - 保留"显示模块"和"缓存模块"的显示内容（displayContent变量）
     - 点击"停止"按钮强制停止执行

- **运行支持**：
  - 支持一连多（多连一）的连接方式
  - 当流程中需要"延迟"运行至下一个延迟模块时，若A为流程模块，且A到B的连线可以激活B，则在该"步进"内，A和B都运行

### 3.3 模块运行逻辑

模块的运行逻辑如下：

1. **模块执行准备**：
   - 读取模块文件，获取函数名称和参数信息
   - 确定模块的输入变量数量（`input_quantity`）和总变量数量（`variable_quantity`）
   - 准备函数调用所需的输入变量值

2. **输入变量获取**：
   - 前`#input_quantity`个变量值来自输入端口的变量值
   - 所有输入变量的默认值来自"设置"界面所设置的值

3. **函数执行**：
   - 运行模块中定义的函数，传入准备好的输入变量
   - 优先调用`execute`、`run`、`process`等主执行函数
   - 对于调用模块，额外传递`settings`参数和`cancel_token`参数
   - 函数的输出值数量等于输出端口的数量
   - 特殊情况：当模块的`time_late == variable_quantity`时，输出值的数量会比输出端口数多1（多的那一个return为延迟步数的数量）

4. **输出值处理**：
   - 根据函数的返回值，对输出端口的端口变量进行赋值
   - 处理延迟步数，根据延迟步数向后执行
   - 延迟步数数值范围校验：确保延迟步数为非负整数
  - 校验失败后的处理逻辑：如果延迟步数为负数或非整数，系统会跳过该模块的延迟执行，直接执行模块
  - 实现方式：在数据传输时进行校验，使用Number.isInteger()和>=0判断
   - 对于多输出延迟逻辑：所有输出端口都会按照相同的延迟步数执行

5. **显示内容处理**：
   - 对于"显示模块"和"缓存模块"，系统会使用`displayContent`变量存储显示内容
   - `displayContent`变量与实际输出值分离，确保停止运行时显示内容不会被清空
   - 当模块有新的输入数据时，`displayContent`会被更新为新的内容
   - 当停止运行时，`displayContent`变量会被保留，而其他端口变量会被清空

6. **数据激活处理**：
   - **excitedbydata参数说明**：
     - `excitedbydata=true`：模块会被数据激活（即会被黑线激活），当依赖模块执行且至少有一个输入端口有数据时会加入执行顺序
     - `excitedbydata=false`：模块不会被数据激活（即不会被黑线激活），只会被红线激活
   - 显示模块和缓存模块总是会加入执行顺序，无论`excitedbydata`值如何
   - 对于多连一场景：直接使用最后接收到的值，无论数据类型如何
  - "最后接收"的判定维度：模块执行周期内最晚到达该端口的数据
  - 实现方式：系统会记录每个数据的接收时间戳，时间戳最大的即为最后接收到的值
  - 数据类型处理：对于数据类型不兼容的情况，系统会尝试自动转换，转换失败时会记录错误但继续执行



### 3.4 模块参数

每个模块包含以下参数：

| 参数名 | 类型 | 描述 |
|-------|------|------|
| input_quantity | 数字 | 输入端口数量 |
| variable_quantity | 数字 | 变量数量 |
| userinput | 布尔值 | 是否有用户输入 |
| showingwindow_quantity | 数字 | 内容显示窗口数 |
| inputtingwindow_quantity | 数字 | 设定窗口数 |
| setting | 布尔值 | 是否有设置窗口 |
| output_quantity | 数字 | 输出端口数量 |
| time_late | 数字 | 延迟步进数(延迟n个步进后输出) |
| name | 字符串 | 模块名称 |
| excitedbydata | 布尔值 | 是否被数据激活 |
| variables_name | 字符串 | 变量的名称，其中前input_quantity个为输入端口名 |
| kind | 字符串 | 模块的分类 |
| output_name | 字符串 | 输出端口的名称，与output_quantity数量对应 |

## 4. 使用指南

### 4.1 基本操作流程

1. **创建项目**：
   - 点击"新建项目"按钮
   - 输入项目名称和保存路径

2. **添加模块**：
   - 从模块库中拖拽模块到画布
   - 每个模块会自动分配唯一ID
   - 配置模块参数和属性，如输入/输出数量、显示窗口等

3. **设置连线**：
   - 点击源模块输出端口，拖动到目标模块输入端口
   - 连线自动显示运行顺序和方向
   - 支持从一个模块的多个输出端口连接到不同的目标模块

4. **运行测试**：
   - 点击"运行"按钮开始执行
   - 观察连线颜色变化和运行状态
   - 连线上会显示当前运行到第几步

5. **生成代码**：
   - 点击"生成代码"按钮
   - 系统自动生成对应Python代码

6. **保存项目**：
   - 点击"保存"按钮
   - 项目配置自动保存为`.aiud`文件到`auto_save`目录
   - 文件名格式为`ai_tool_project_时间戳.aiud`

7. **加载项目**：
   - 点击"加载"按钮
   - 在文件选择对话框中选择`.aiud`格式的项目文件
   - 系统会自动加载项目配置，包括模块信息、连接信息和画布大小

### 4.2 模块配置

#### 4.2.1 输入模块配置

- **固定输入**：直接在模块中设置固定值
- **外部输入**：通过用户界面输入或文件导入
- **输入类型**：支持文本、数字、文件等多种类型

#### 4.2.2 处理模块配置

- **处理类型**：支持数据转换、过滤、计算等操作
- **参数设置**：根据处理类型设置相应参数

#### 4.2.3 调用模块配置

- **模型选择**：选择要调用的AI模型
- **参数配置**：设置模型调用参数
- **认证信息**：配置API密钥等认证信息

#### 4.2.4 判断模块配置

- **判断条件**：设置条件判断逻辑
- **分支配置**：配置不同条件下的执行分支

#### 4.2.5 输出模块配置

- **输出类型**：设置输出格式和目标
- **显示配置**：配置结果展示方式

## 5. 技术实现细节


### 5.1 数据流向

- 数据从输入模块开始，经过处理模块和调用模块，最终到达输出模块
- 数据传递支持同步和异步两种方式
- 支持数据在模块间的转换和映射

### 5.2 运行控制

- 系统使用事件驱动模型控制模块执行
- 支持单步执行和连续执行两种模式
- 支持执行过程中的暂停和恢复

## 6. 注意事项

1. **模块命名**：
   - 模块编号采用8位数字格式(如`00000001`)
   - 输入端口编号格式为`IN_001`，输出端口编号格式为`OUT_001`

2. **数据类型**：
   - 确保数据类型在模块间匹配
   - 对于不匹配的数据类型，系统会尝试自动转换

3. **性能考虑**：
   - 对于大型项目，建议合理规划模块数量和连接关系
   - 复杂计算应考虑使用异步处理

4. **错误处理**：
   - 系统会捕获并显示模块执行错误
   - 建议在关键节点添加错误处理模块

5. **版本兼容性**：
   - 项目文件格式可能会随版本更新而变化
   - 建议定期备份项目文件

## 7. 扩展与定制

### 7.1 自定义模块开发

1. **模块结构**：
   - 每个模块包含参数定义、执行逻辑和UI配置
   - 模块文件应放在`custom_modules`目录下

2. **模块注册**：
   - 自定义模块会在系统启动时自动注册
   - 也可以通过UI界面手动导入模块

### 7.2 系统扩展

- **添加新的运行模式**：修改`app.py`中的运行控制逻辑
- **扩展前端界面**：修改`main.html`和相关JavaScript
- **集成新的AI模型**：添加相应的调用模块

## 8. 示例项目

### 8.1 基本数据处理流程

1. **输入模块**：读取CSV文件数据
2. **处理模块**：数据清洗和转换
3. **调用模块**：调用分类模型进行预测
4. **输出模块**：展示预测结果

### 8.2 复杂决策流程

1. **输入模块**：接收用户输入
2. **处理模块**：特征提取和预处理
3. **判断模块**：根据条件选择不同模型
4. **调用模块**：调用选中的AI模型
5. **输出模块**：展示结果并保存

## 9. 总结


本项目通过图形化界面和模块化设计，大大简化了AI模型的调用和流程编排过程，使非专业人员也能轻松构建和部署AI应用。系统支持多种运行模式和模块类型，具有良好的扩展性和定制性。

通过本工具，用户可以：
- 快速构建AI应用原型
- 可视化设计和测试AI工作流
- 一键生成可部署的代码
- 自定义和扩展功能模块

本工具为AI应用的开发和部署提供了一种直观、高效的解决方案，适合各种规模和类型的AI项目。
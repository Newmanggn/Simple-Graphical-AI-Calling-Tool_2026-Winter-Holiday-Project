# 模块开发完整指南

## 1. 概述

本文档是图形化AI调用工具的模块开发完整指南，旨在帮助开发者快速、简单地创建模块，包括自定义模块和默认模块。通过遵循本指南，您可以：

- 创建功能强大、可靠的自定义模块，扩展工具的功能，实现特定的业务逻辑，或者集成第三方服务
- 为开发团队开发默认模块，作为工具的内置功能

本指南适用于所有类型的模块开发，提供了从基础到高级的完整指导。

## 2. 模块基础结构

一个完整的模块由以下两部分组成：

### 2.1 配置头部

模块文件的开头需要包含一系列以 `#` 开头的配置参数，这些参数定义了模块的基本属性和行为。

```python
#input_quantity=001      # 输入端口数量
#variable_quantity=001    # 变量数量
#userinput=false          # 是否支持用户输入
#setting=false            # 是否支持设置
#output_quantity=001      # 输出端口数量
#time_late=000            # 延迟时间
#name=示例模块            # 模块名称
#excitedbydata=true        # 是否可被数据激活
#variables_name=input      # 变量名称（多个变量用逗号分隔）
#kind=处理模块            # 模块类型
#output_name=output        # 输出名称（多个输出用逗号分隔）
```

### 2.2 模块代码

配置头部之后是模块的实际代码，包括：

1. 必要的导入语句
2. 模块的核心逻辑函数
3. 主执行函数 `execute()`
4. 可选的测试代码

## 3. 配置参数详细说明

| 参数 | 说明 | 示例值 |
|------|------|--------|
| input_quantity | 输入端口数量，格式为三位数字 | 001, 004 |
| variable_quantity | 变量数量，格式为三位数字 | 001, 004 |
| userinput | 是否支持用户输入，T/F | T, F |
| setting | 是否支持设置，T/F | T, F |
| output_quantity | 输出端口数量，格式为三位数字 | 001, 002 |
| time_late | 延迟时间 | 0, 1000 |
| excitedbydata | 是否可被数据激活，T/F | T, F |
| name | 模块名称 | 缓存模块, 调用模块 |
| kind | 模块类型 | 处理模块, 调用模块 |
| variables_name | 变量名称，多个用逗号分隔 | 模型选择,提示词,上下文,对话 |
| output_name | 输出名称，多个用逗号分隔 | 生成结果,更新后的上下文 |

## 4. 执行函数格式

每个模块必须实现一个 `execute()` 函数，这是模块的主入口点。函数的参数数量应与模块的输入端口数量匹配。

### 4.1 基本格式

```python
def execute(input1, input2, ..., settings=None, cancel_token=None):
    """
    执行模块逻辑
    
    参数:
    - input1, input2, ...: 输入参数，数量与input_quantity对应
    - settings: 额外的设置参数（可选）
    - cancel_token: 取消令牌函数，用于检查是否需要取消执行（可选，主要用于调用模块）
    
    返回:
    - 输出值或输出值列表，数量与output_quantity对应
    """
    # 模块逻辑
    # ...
    
    # 返回结果
    return output
    # 或多个返回值
    # return output1, output2
```

### 4.2 参数说明

- **输入参数**: 根据模块的 `input_quantity` 配置，函数会接收相应数量的输入参数。这些参数来自连接的上游模块的输出。
- **settings**: 当模块配置了 `setting=T` 时，这个参数会包含用户在设置界面中配置的值。
- **cancel_token**: 这是一个函数，用于检查执行是否应该被取消。在长时间运行的操作中，应该定期调用这个函数并在返回 `True` 时停止执行。

### 4.3 返回值说明

- 函数应该返回与 `output_quantity` 配置数量相匹配的值。
- 如果只需要返回一个值，可以直接返回该值。
- 如果需要返回多个值，应该返回一个元组。
- 如果模块配置了 `time_late` 并且其值等于 `variable_quantity`，则返回值数量应该比 `output_quantity` 多1，多的那个值是延迟步数。

## 5. 模块类型

根据 `kind` 参数，模块可以分为以下类型：

| 类型 | 说明 | 示例 |
|------|------|------|
| 处理模块 | 对输入数据进行处理并输出结果 | 缓存模块, 加法模块 |
| 调用模块 | 调用外部服务或API | 调用模块 |
| 输入模块 | 提供用户输入功能 | user输入模块 |
| 输出模块 | 展示输出结果 | 对话输出模块 |

## 6. 模块开发最佳实践

1. **清晰的文档**: 为模块和关键函数添加详细的文档字符串，说明功能、参数和返回值。
2. **错误处理**: 实现适当的错误处理，确保模块在异常情况下能够优雅失败并返回有意义的错误信息。
3. **类型检查**: 对输入参数进行类型检查和转换，确保模块的健壮性。
4. **默认值**: 为可选参数提供合理的默认值，提高模块的可用性。
5. **测试代码**: 添加测试代码，方便模块的调试和验证。
6. **模块化**: 将复杂逻辑分解为多个函数，提高代码的可读性和可维护性。
7. **性能考虑**: 对于计算密集型操作，考虑优化算法和数据结构，提高模块的执行效率。

## 7. 案例代码

### 7.1 基础案例

#### 7.1.1 缓存模块

```python
#input_quantity=001
#variable_quantity=001
#userinput=F
#setting=F
#output_quantity=001
#time_late=000
#name=缓存模块
#excitedbydata=T
#variables_name=input
#kind=处理模块
#output_name=output

# 全局缓存变量
_cache = None

def execute(input_data):
    """
    执行缓存逻辑
    
    参数:
    - input_data: 输入数据
    
    返回:
    - 缓存的数据
    """
    global _cache
    
    # 如果输入数据不是None，则更新缓存
    if input_data is not None:
        _cache = input_data
    
    # 返回缓存的数据
    return _cache

# 测试代码
if __name__ == "__main__":
    # 测试缓存更新
    result = execute("测试数据")
    print(f"缓存模块测试结果: {result}")
    
    # 测试缓存读取
    result = execute(None)
    print(f"缓存模块读取测试: {result}")
```

#### 7.1.2 加法模块

```python
#input_quantity=002
#variable_quantity=002
#userinput=F
#setting=F
#output_quantity=001
#time_late=000
#name=加法模块
#excitedbydata=T
#variables_name=数字1,数字2
#kind=处理模块
#output_name=和

def execute(num1, num2):
    """
    执行加法操作
    
    参数:
    - num1: 第一个数字
    - num2: 第二个数字
    
    返回:
    - 两个数字的和
    """
    try:
        # 类型转换
        num1 = float(num1) if num1 is not None else 0
        num2 = float(num2) if num2 is not None else 0
        
        # 执行加法
        result = num1 + num2
        
        return result
    except Exception as e:
        # 错误处理
        return f"计算错误: {str(e)}"

# 测试代码
if __name__ == "__main__":
    test_result = execute(10, 20)
    print(f"加法测试结果: {test_result}")
    
    test_result2 = execute("30", "40")
    print(f"字符串加法测试结果: {test_result2}")
    
    test_result3 = execute(None, 50)
    print(f"空值加法测试结果: {test_result3}")
```

### 7.2 进阶案例

#### 7.2.1 文本处理模块

```python
#input_quantity=001
#variable_quantity=001
#userinput=F
#setting=F
#output_quantity=001
#time_late=000
#name=文本转大写
#excitedbydata=T
#variables_name=文本
#kind=处理模块
#output_name=大写文本

def execute(text):
    """
    将文本转换为大写
    
    参数:
    - text: 输入文本
    
    返回:
    - 大写文本
    """
    if text is None:
        return ""
    
    try:
        # 确保输入是字符串
        if not isinstance(text, str):
            text = str(text)
        
        # 转换为大写
        return text.upper()
    except Exception as e:
        return f"处理错误: {str(e)}"

# 测试代码
if __name__ == "__main__":
    test_result = execute("hello world")
    print(f"文本转大写测试结果: {test_result}")
    
    test_result2 = execute(123)
    print(f"数字转大写测试结果: {test_result2}")
    
    test_result3 = execute(None)
    print(f"空值测试结果: '{test_result3}'")
```

#### 7.2.2 条件判断模块

```python
#input_quantity=001
#variable_quantity=001
#userinput=F
#setting=F
#output_quantity=002
#time_late=000
#name=条件判断
#excitedbydata=T
#variables_name=值
#kind=处理模块
#output_name=大于0,小于等于0

def execute(value):
    """
    执行条件判断
    
    参数:
    - value: 输入值
    
    返回:
    - 两个值，分别表示是否大于0和是否小于等于0
    """
    try:
        # 类型转换
        if value is None:
            return False, True
        
        if not isinstance(value, (int, float)):
            value = float(value)
        
        # 执行条件判断
        is_greater_than_zero = value > 0
        is_less_or_equal_zero = not is_greater_than_zero
        
        return is_greater_than_zero, is_less_or_equal_zero
    except Exception as e:
        return False, False

# 测试代码
if __name__ == "__main__":
    test_result = execute(10)
    print(f"正数测试结果: {test_result}")
    
    test_result2 = execute(-5)
    print(f"负数测试结果: {test_result2}")
    
    test_result3 = execute(0)
    print(f"零测试结果: {test_result3}")
    
    test_result4 = execute("15")
    print(f"字符串测试结果: {test_result4}")
```

#### 7.2.3 列表处理模块

```python
#input_quantity=001
#variable_quantity=001
#userinput=F
#setting=F
#output_quantity=002
#time_late=000
#name=列表处理
#excitedbydata=T
#variables_name=列表
#kind=处理模块
#output_name=元素数量,最大元素

def execute(input_list):
    """
    处理列表数据
    
    参数:
    - input_list: 输入列表
    
    返回:
    - 两个值，分别表示列表元素数量和最大元素
    """
    try:
        # 类型检查
        if input_list is None:
            return 0, None
        
        if not isinstance(input_list, list):
            # 尝试转换为列表
            input_list = [input_list]
        
        # 获取元素数量
        count = len(input_list)
        
        # 获取最大元素
        max_element = max(input_list) if count > 0 else None
        
        return count, max_element
    except Exception as e:
        return 0, None

# 测试代码
if __name__ == "__main__":
    test_result = execute([1, 2, 3, 4, 5])
    print(f"列表处理测试结果: {test_result}")
    
    test_result2 = execute("单个元素")
    print(f"单个元素测试结果: {test_result2}")
    
    test_result3 = execute(None)
    print(f"空值测试结果: {test_result3}")
```

### 7.3 高级案例

#### 7.3.1 带设置的模块

```python
#input_quantity=001
#variable_quantity=001
#userinput=F
#setting=T
#output_quantity=001
#time_late=000
#name=带设置的模块
#excitedbydata=T
#variables_name=输入
#kind=处理模块
#output_name=输出

def execute(input_data, settings=None):
    """
    执行带设置的处理
    
    参数:
    - input_data: 输入数据
    - settings: 设置参数
    
    返回:
    - 处理结果
    """
    try:
        # 获取设置值
        prefix = settings.get('prefix', '处理结果: ')
        suffix = settings.get('suffix', '')
        
        # 处理输入数据
        if input_data is None:
            return f"{prefix}无输入{suffix}"
        
        # 确保输入是字符串
        if not isinstance(input_data, str):
            input_data = str(input_data)
        
        # 应用设置并返回结果
        return f"{prefix}{input_data}{suffix}"
    except Exception as e:
        return f"处理错误: {str(e)}"

# 测试代码
if __name__ == "__main__":
    # 测试默认设置
    test_result = execute("测试数据")
    print(f"默认设置测试结果: '{test_result}'")
    
    # 测试自定义设置
    custom_settings = {'prefix': '自定义前缀: ', 'suffix': ' (自定义后缀)'}
    test_result2 = execute("测试数据", custom_settings)
    print(f"自定义设置测试结果: '{test_result2}'")
```

#### 7.3.2 外部API调用模块

```python
#input_quantity=001
#variable_quantity=001
#userinput=F
#setting=T
#output_quantity=001
#time_late=000
#name=API调用
#excitedbydata=T
#variables_name=查询
#kind=调用模块
#output_name=结果

import requests

def execute(query, settings=None, cancel_token=None):
    """
    调用外部API
    
    参数:
    - query: 查询参数
    - settings: 设置参数
    - cancel_token: 取消令牌函数
    
    返回:
    - API调用结果
    """
    try:
        # 获取设置值
        api_url = settings.get('api_url', 'https://api.example.com/search')
        api_key = settings.get('api_key', '')
        
        # 检查是否需要取消
        if cancel_token and cancel_token():
            return "执行已取消"
        
        # 构建请求参数
        params = {
            'q': query,
            'api_key': api_key
        }
        
        # 发送请求
        response = requests.get(api_url, params=params, timeout=10)
        
        # 检查是否需要取消
        if cancel_token and cancel_token():
            return "执行已取消"
        
        # 处理响应
        if response.status_code == 200:
            return response.json()
        else:
            return f"API调用失败: {response.status_code}"
    except Exception as e:
        return f"调用错误: {str(e)}"

# 测试代码
if __name__ == "__main__":
    # 测试API调用
    test_settings = {
        'api_url': 'https://jsonplaceholder.typicode.com/posts',
        'api_key': 'test_key'
    }
    
    # 模拟取消令牌
    def mock_cancel_token():
        return False
    
    test_result = execute('1', test_settings, mock_cancel_token)
    print(f"API调用测试结果: {test_result}")
```

## 8. 模块部署

1. **保存模块文件**：将开发完成的模块文件保存为 `.py` 文件。
2. **复制到模块目录**：将文件复制到 `default_modules` 目录（内置模块）或 `custom_modules` 目录（自定义模块）。
3. **刷新模块列表**：在图形化AI调用工具中，点击左侧模块库中自定义模块后方的刷新按钮，系统会重新加载模块。
4. **添加并测试**：从模块库中拖拽新模块到画布，配置参数并测试其功能。

## 9. 故障排除

### 9.1 常见问题

| 问题 | 可能原因 | 解决方案 |
|------|----------|----------|
| 模块不显示在工具中 | 配置头部格式错误 | 检查配置头部的格式和参数，确保所有参数都正确设置。 |
| 模块执行出错 | `execute()` 函数签名错误 | 确保 `execute()` 函数的参数数量与 `input_quantity` 一致。 |
| 设置不生效 | 未处理 `settings` 参数 | 在 `execute()` 函数中添加对 `settings` 参数的处理。 |
| 输出与预期不符 | 输出值数量与 `output_quantity` 不一致 | 确保返回值的数量与 `output_quantity` 配置一致。 |
| 模块执行超时 | 长时间运行的操作未检查取消令牌 | 在长时间运行的操作中，定期调用 `cancel_token()` 函数并在返回 `True` 时停止执行。 |

### 9.2 调试技巧

1. **添加日志**：在模块中添加 `print()` 语句，输出关键变量的值和执行状态。
2. **错误捕获**：使用 `try-except` 块捕获并打印异常信息，帮助定位问题。
3. **本地测试**：在模块文件末尾添加测试代码，在本地运行测试，验证模块功能。
4. **简化测试**：从简单的输入开始测试，逐步增加复杂度，定位问题所在。
5. **检查类型**：确保输入和输出的数据类型与预期一致，必要时进行类型转换。

## 10. 总结

本指南提供了创建模块的完整流程和示例代码，涵盖了从基础到高级的各种场景，适用于开发自定义模块和默认模块。通过遵循本指南的最佳实践和示例，您可以创建功能强大、可靠的模块，扩展图形化AI调用工具的功能。

本指南的核心价值在于：

- 提供了统一的模块开发标准和规范
- 涵盖了从配置到部署的完整开发流程
- 包含了多个实用的案例代码，从简单到复杂
- 提供了故障排除和调试技巧

希望本指南能够帮助您顺利开发模块，无论是作为个人开发者创建自定义模块，还是作为开发团队成员开发默认模块！如果您有任何问题或建议，请随时反馈。
<!DOCTYPE html>
<html lang="zh-CN">
<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>简单图形化AI调用工具</title>
        <!-- 引入JSZip库 -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            overflow: hidden;
        }
        
        /* 顶部控制面板 */
        .top-panel {
            background-color: #333;
            color: white;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
        }
        
        /* 项目名样式 */
        .project-name {
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            flex: 1;
            margin: 0 20px;
        }
        
        .control-buttons {
            display: flex;
            gap: 10px;
        }
        
        .control-buttons button {
            padding: 5px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .control-buttons button:hover {
            background-color: #45a049;
        }
        
        /* 主容器 */
        .main-container {
            display: flex;
            height: calc(100vh - 60px);
        }
        
        /* 左侧模块库 */
        .module-library {
            width: 200px;
            background-color: #f5f5f5;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            padding: 10px;
            transition: width 0.3s ease;
        }
        
        .module-library.collapsed {
            width: 40px;
        }
        
        .module-library.collapsed .module-category h3,
        .module-library.collapsed .module-item {
            display: none;
        }
        
        .collapse-btn {
            position: absolute;
            top: 50%;
            right: -10px;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background-color: #ddd;
            border: 1px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        .module-library .collapse-btn {
            right: -10px;
        }
        
        .chat-panel .collapse-btn {
            left: -10px;
        }
        
        .module-category {
            margin-bottom: 20px;
        }
        
        .module-category h3 {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #666;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .module-category h3::after {
            content: '▼';
            font-size: 10px;
            transition: transform 0.3s ease;
        }
        
        .module-category.collapsed h3::after {
            transform: rotate(-90deg);
        }
        
        .module-category.collapsed .module-items {
            display: none;
        }
        
        .module-category.collapsed h3 {
            margin-bottom: 5px;
        }
        
        .module-item {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 5px;
            cursor: grab;
            transition: all 0.2s ease;
        }
        
        .module-item:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        
        .module-item:active {
            cursor: grabbing;
        }
        
        .module-item .module-name {
            font-weight: bold;
            font-size: 12px;
        }
        
        .module-item .module-kind {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }
        
        /* 中央画布 */
        .canvas {
            flex: 1;
            background-color: white;
            position: relative;
            overflow: auto;
            cursor: grab;
            user-select: none;
        }
        
        .canvas-content {
            position: relative;
            transform-origin: 0 0;
            transition: transform 0.2s ease;
            background-image: linear-gradient(#e0e0e0 1px, transparent 1px),
                              linear-gradient(90deg, #e0e0e0 1px, transparent 1px),
                              linear-gradient(#999 3px, transparent 3px),
                              linear-gradient(90deg, #999 3px, transparent 3px);
            background-size: 20px 20px, 20px 20px, 60px 60px, 60px 60px;
            width: 4000px;
            height: 3000px;
            min-width: 100%;
            min-height: 100%;
        }
        
        .canvas:active {
            cursor: grabbing;
        }
        
        .module {
            position: absolute;
            background-color: white;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            min-width: 120px;
            min-height: 80px;
            cursor: move;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* 缩放控制 */
        .zoom-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            display: flex;
            gap: 5px;
        }
        
        .zoom-controls button {
            height: 30px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-controls button:not(#resize-canvas-btn) {
            width: 30px;
        }
        
        #resize-canvas-btn {
            width: auto;
            padding: 0 10px;
        }
        
        .zoom-controls button:hover {
            background-color: #e0e0e0;
        }
        
        .zoom-controls .zoom-level {
            width: 60px;
            text-align: center;
            line-height: 30px;
            font-size: 12px;
        }
        
        /* 模块样式 */
        .module {
            position: absolute;
            background-color: white;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            min-width: 120px;
            min-height: 80px;
            cursor: move;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* 无输入模块样式 */
        .module.no-input {
            border-top-left-radius: 20px;
            border-bottom-left-radius: 20px;
        }
        
        /* 无输出模块样式 */
        .module.no-output {
            border-top-right-radius: 20px;
            border-bottom-right-radius: 20px;
        }
        
        .module .module-header {
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .module .module-kind {
            font-size: 10px;
            color: #666;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .module .ports {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        
        /* 设置按钮 */
        .setting-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 2px 6px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #666;
        }
        
        .setting-btn:hover {
            background-color: #e0e0e0;
            color: #333;
        }
        
        /* 设置窗口 */
        .setting-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .setting-modal-content {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            width: 400px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
        }
        
        .setting-modal h3 {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .setting-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .setting-form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .setting-form-group label {
            font-size: 14px;
            font-weight: bold;
        }
        
        .setting-form-group input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .setting-modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        
        .setting-modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .setting-modal-buttons .cancel-btn {
            background-color: #f0f0f0;
        }
        
        .setting-modal-buttons .save-btn {
            background-color: #4CAF50;
            color: white;
        }
        
        .setting-modal-buttons .save-btn:hover {
            background-color: #45a049;
        }
        
        .module .input-ports {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .module .output-ports {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .port {
            width: 10px;
            height: 10px;
            background-color: #333;
            border-radius: 50%;
            margin: 2px 0;
            cursor: crosshair;
        }
        
        .input-port {
            background-color: #f44336;
        }
        
        .output-port {
            background-color: #2196F3;
        }
        
        /* 右侧对话面板 */
        .chat-panel {
            width: 300px;
            background-color: #f5f5f5;
            border-left: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }
        
        .chat-panel.collapsed {
            width: 40px;
        }
        
        .chat-panel.collapsed h3,
        .chat-panel.collapsed .chat-messages,
        .chat-panel.collapsed .chat-input {
            display: none;
        }
        
        .chat-panel h3 {
            padding: 10px;
            background-color: #333;
            color: white;
            font-size: 14px;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
        }
        
        .message.user {
            background-color: #e3f2fd;
            align-self: flex-end;
        }
        
        .message.ai {
            background-color: #f1f1f1;
            align-self: flex-start;
        }
        
        .chat-input {
            padding: 10px;
            border-top: 1px solid #ddd;
            display: flex;
        }
        
        .chat-input input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .chat-input button {
            margin-left: 10px;
            padding: 0 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .chat-input button:hover {
            background-color: #45a049;
        }
        
        /* 连线样式 */
        .connection-line {
            position: absolute;
            background-color: #333;
            height: 3px;
            transform-origin: 0 0;
            z-index: 10;
            cursor: pointer;
        }
        
        .connection-line.red {
            background-color: #f44336;
        }
        
        /* 数据传输动画 */
        .connection-line.transferring {
            animation: dataTransfer 1s linear infinite;
        }
        
        @keyframes dataTransfer {
            0% { background-color: inherit; }
            50% { background-color: yellow; }
            100% { background-color: inherit; }
        }
    </style>
</head>
<body>
    <!-- 顶部控制面板 -->
    <div class="top-panel">
        <div class="project-info">简单图形化AI调用工具</div>
        <div class="project-name" id="project-name">未命名项目</div>
        <div class="control-buttons">
                <button id="run-btn">运行</button>
                <button id="pause-btn">暂停</button>
                <button id="stop-btn">停止</button>
                <button id="restart-btn">重启</button>
                <button id="generate-code-btn">生成代码</button>
                <button id="new-project-btn">新建</button>
                <button id="save-project-btn">保存</button>
                <button id="save-as-project-btn">另存为</button>
                <button id="load-project-btn">加载</button>
            </div>
    </div>
    
    <!-- 主容器 -->
    <div class="main-container">
        <!-- 左侧模块库 -->
        <div class="module-library" style="position: relative;">
            <div class="collapse-btn" id="module-library-collapse" style="top: 5px; right: 5px;">←</div>
            <div class="module-category">
                <h3>采样</h3>
                <div class="module-items" id="sampling-modules"></div>
            </div>
            <div class="module-category">
                <h3>加载器</h3>
                <div class="module-items" id="loader-modules"></div>
            </div>
            <div class="module-category">
                <h3>Latent</h3>
                <div class="module-items" id="latent-modules"></div>
            </div>
            <div class="module-category">
                <h3>图像</h3>
                <div class="module-items" id="image-modules"></div>
            </div>
            <div class="module-category">
                <h3>其它</h3>
                <div class="module-items" id="other-modules"></div>
            </div>
            <div class="module-category">
                <h3>自定义模块</h3>
                <div class="module-items" id="custom-modules"></div>
                <button id="refresh-modules-btn" style="width: 100%; margin-top: 10px; padding: 5px; font-size: 12px;">刷新</button>
            </div>
        </div>
        
        <!-- 中央画布 -->
        <div class="canvas" id="canvas">
            <!-- 缩放控制 -->
            <div class="zoom-controls">
                <button id="zoom-out">-</button>
                <div class="zoom-level">100%</div>
                <button id="zoom-in">+</button>
                <button id="resize-canvas-btn">调整画布</button>
            </div>
            <!-- 画布内容容器，用于实现缩放 -->
            <div class="canvas-content" id="canvas-content">
                <!-- 模块将被动态添加到这里 -->
            </div>
        </div>
        
        <!-- 右侧对话面板 -->
        <div class="chat-panel" style="position: relative;">
            <div class="collapse-btn" id="chat-panel-collapse" style="position: absolute; top: 5px; right: 5px;">→</div>
            <h3>对话面板</h3>
            <div class="chat-messages" id="chat-messages">
                <div class="message ai">你好！我是AI助手，有什么可以帮助你的吗？</div>
            </div>
            <div class="chat-input">
                <input type="text" id="chat-input" placeholder="输入消息...">
                <button id="send-btn">发送</button>
            </div>
        </div>
    </div>
    
    <script>
        // 全局变量
        let modules = {};
        let draggedModule = null;
        let canvas = document.getElementById('canvas');
        let canvasContent = document.getElementById('canvas-content');
        let isDrawing = false;
        let startX, startY, endX, endY;
        let connectionLines = [];
        let currentConnection = null;
        let draggedPort = null;
        let firstPort = null;
        let currentZoomLevel = 100; // 全局存储当前缩放级别
        let canvasSize = { width: 4000, height: 3000 }; // 存储当前画布大小
        let runTrigger = 'button'; // 运行触发方式：'button'（运行按钮）或 'chat'（对话激活）
        let ongoingRequests = new Map(); // 存储正在进行的API请求控制器
        
        // 初始化模块分类折叠功能
        function initModuleCategoryCollapse() {
            const categoryHeaders = document.querySelectorAll('.module-category h3');
            categoryHeaders.forEach(header => {
                header.addEventListener('click', function() {
                    const category = this.parentElement;
                    category.classList.toggle('collapsed');
                });
            });
        }
        
        // 从模块文件内容中解析模块参数
        function parseModuleParamsFromContent(content) {
            const params = {};
            try {
                const lines = content.split('\n');
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine.startsWith('#')) {
                        continue; // 跳过非注释行，继续解析后续的注释行
                    }
                    
                    // 处理普通参数
                    if (trimmedLine.includes('=') && !trimmedLine.startsWith('#variables_name=') && !trimmedLine.startsWith('#output_name=')) {
                        const keyValue = trimmedLine.substring(1).split('=', 2);
                        if (keyValue.length === 2) {
                            const key = keyValue[0];
                            let value = keyValue[1];
                            // 转换布尔值
                            if (value.toLowerCase() === 't' || value.toLowerCase() === 'true') {
                                value = true;
                            } else if (value.toLowerCase() === 'f' || value.toLowerCase() === 'false') {
                                value = false;
                            } else if (!isNaN(value)) {
                                value = parseInt(value);
                            }
                            params[key] = value;
                        }
                    } else if (trimmedLine.startsWith('#variables_name=')) {
                        params['variables_name'] = trimmedLine.substring(16);
                    } else if (trimmedLine.startsWith('#output_name=')) {
                        params['output_name'] = trimmedLine.substring(13);
                    }
                }
            } catch (error) {
                console.error('解析模块文件失败:', error);
            }
            return params;
        }
        
        // 模块状态管理
        let moduleStates = {}; // 存储模块状态
        // 不再需要模块计数器和已使用ID集合，使用UUID生成唯一ID
        
        // 运行控制
        let isRunning = false; // 是否正在运行
        let isPaused = false; // 是否暂停
        let currentStep = 0; // 当前步进
        let executionQueue = []; // 执行队列
        let executionTimer = null; // 自动执行定时器
        let pendingDelayTasks = []; // 未完成的延迟任务队列
        let autoRunInterval = 200; // 自动运行时间间隔（毫秒），默认0.2秒
        
        // 拓扑排序计算模块执行顺序
        function calculateExecutionOrder() {
            // 构建依赖图
            const graph = {};
            const inDegree = {};
            const moduleIds = Object.keys(moduleStates);
            
            // 初始化图和入度
            moduleIds.forEach(moduleId => {
                graph[moduleId] = [];
                inDegree[moduleId] = 0;
            });
            
            // 构建依赖关系
            connectionLines.forEach(connection => {
                const { startModuleId, endModuleId } = connection;
                if (graph[startModuleId] && graph[endModuleId]) {
                    // 检查是否已经存在此依赖
                    if (!graph[startModuleId].includes(endModuleId)) {
                        graph[startModuleId].push(endModuleId);
                        inDegree[endModuleId]++;
                    }
                }
            });
            
            // 执行拓扑排序
            const queue = [];
            const order = [];
            
            // 首先处理入度为0的模块
            moduleIds.forEach(moduleId => {
                if (inDegree[moduleId] === 0) {
                    // 只有excitedbydata=false的模块才自动加入执行顺序，显示模块和缓存模块总是加入
                    const excitedByData = moduleStates[moduleId].moduleData.params.excitedbydata !== false;
                    const isDisplayModule = moduleStates[moduleId].moduleData.params.name === '显示模块';
                    const isCacheModule = moduleStates[moduleId].moduleData.params.name === '缓存模块';
                    if (!excitedByData || isDisplayModule || isCacheModule) {
                        queue.push(moduleId);
                    }
                }
            });
            
            // 按照正常顺序添加入度为0的模块
            order.push(...queue);
            
            // 继续处理其他模块
            while (order.length < moduleIds.length) {
                let processed = false;
                
                // 找到所有依赖已满足的模块
                moduleIds.forEach(moduleId => {
                    if (!order.includes(moduleId) && inDegree[moduleId] > 0) {
                        // 检查所有依赖是否都已处理
                        const dependencies = connectionLines
                            .filter(conn => conn.endModuleId === moduleId)
                            .map(conn => conn.startModuleId);
                        
                        const allDependenciesProcessed = dependencies.every(depId => 
                            order.includes(depId)
                        );
                        
                        if (allDependenciesProcessed) {
                            // 检查模块是否是显示模块或缓存模块
                            const isDisplayModule = moduleStates[moduleId].moduleData.params.name === '显示模块';
                            const isCacheModule = moduleStates[moduleId].moduleData.params.name === '缓存模块';
                            const excitedByData = moduleStates[moduleId].moduleData.params.excitedbydata !== false;
                            
                            // 对于excitedbydata=true的模块，检查是否有输入数据
                            let hasInputData = true;
                            if (excitedByData && !isDisplayModule && !isCacheModule) {
                                // 检查是否有任意输入端口有数据
                                hasInputData = moduleStates[moduleId].inputValues.some(value => 
                                    value !== undefined && value !== null
                                );
                            }
                            
                            if (!excitedByData || isDisplayModule || isCacheModule || hasInputData) {
                                order.push(moduleId);
                                processed = true;
                            }
                        }
                    }
                });
                
                // 如果没有可处理的模块，说明存在循环依赖
                if (!processed) {
                    console.log('存在循环依赖，尝试处理循环依赖');
                    
                    // 尝试找到一个比大小模块作为循环的起点
                    let compareModuleId = null;
                    for (const moduleId of moduleIds) {
                        if (!order.includes(moduleId) && 
                            moduleStates[moduleId].moduleData.params.name === '比大小') {
                            compareModuleId = moduleId;
                            break;
                        }
                    }
                    
                    // 如果找到了比大小模块，将其加入执行顺序
                    if (compareModuleId) {
                        console.log('选择比大小模块作为循环起点:', compareModuleId);
                        order.push(compareModuleId);
                        processed = true;
                    } else {
                        // 尝试找到一个非缓存模块作为循环的起点
                        let nonCacheModuleId = null;
                        for (const moduleId of moduleIds) {
                            if (!order.includes(moduleId) && 
                                moduleStates[moduleId].moduleData.params.name !== '缓存模块') {
                                nonCacheModuleId = moduleId;
                                break;
                            }
                        }
                        
                        // 如果找到了非缓存模块，将其加入执行顺序
                        if (nonCacheModuleId) {
                            console.log('选择非缓存模块作为循环起点:', nonCacheModuleId);
                            order.push(nonCacheModuleId);
                            processed = true;
                        } else {
                            // 如果没有找到非缓存模块，选择第一个未处理的模块作为起点
                            for (const moduleId of moduleIds) {
                                if (!order.includes(moduleId)) {
                                    console.log('选择第一个未处理模块作为循环起点:', moduleId);
                                    order.push(moduleId);
                                    processed = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            console.log('计算出的执行顺序:', order);
            return order;
        }
        
        // 执行模块
        async function executeModule(moduleId, options = {}) {
            const { setExecuted = true, transferData = true } = options;
            const moduleState = moduleStates[moduleId];
            if (!moduleState || moduleState.executing || (moduleState.executed && setExecuted)) {
                return;
            }
            
            console.log(`执行模块: ${moduleId} - ${moduleState.moduleData.params.name}`);
            
            // 设置执行状态
            moduleState.executing = true;
            
            try {
                // 边界场景校验：检查模块是否有必要的输入/输出端口
                const inputQuantity = moduleState.moduleData.params.input_quantity || 0;
                const outputQuantity = moduleState.moduleData.params.output_quantity || 0;
                const moduleKind = moduleState.moduleData.params.kind || '未知';
                const moduleName = moduleState.moduleData.params.name || '未知模块';
                
                // 1. 无输入端口的模块校验
                if (inputQuantity === 0) {
                    let isValidInputModule = false;
                    
                    // 输入模块应该无输入端口
                    if (moduleKind === '输入模块') {
                        isValidInputModule = true;
                    }
                    // excitedbydata=true的模块可以无输入端口
                    else if (moduleState.moduleData.params.excitedbydata === true) {
                        isValidInputModule = true;
                    }
                    // 特定模块例外
                    else if (moduleName === 'user输入' || 
                             moduleName === '固定值输出模块' ||
                             moduleName === '缓存模块') {
                        isValidInputModule = true;
                    }
                    
                    if (!isValidInputModule) {
                        console.warn(`模块 ${moduleId} (${moduleName}) 无输入端口，但不是输入模块或excitedbydata=true的模块，可能无法正常执行`);
                        // 显示警告通知
                        showNotification(`警告: 模块 ${moduleName} 无输入端口，可能无法正常执行`);
                    }
                }
                
                // 2. 无输出端口的模块校验
                if (outputQuantity === 0) {
                    let isValidOutputModule = false;
                    
                    // 输出模块应该无输出端口
                    if (moduleKind === '输出模块') {
                        isValidOutputModule = true;
                    }
                    // 特定模块例外
                    else if (moduleName === '显示模块' ||
                             moduleName === '对话输出') {
                        isValidOutputModule = true;
                    }
                    
                    if (!isValidOutputModule) {
                        console.warn(`模块 ${moduleId} (${moduleName}) 无输出端口，但不是输出模块，可能无法传递数据`);
                        // 显示警告通知
                        showNotification(`警告: 模块 ${moduleName} 无输出端口，可能无法传递数据`);
                    }
                }
                
                // 3. 输入模块应该无输入端口
                if (moduleKind === '输入模块' && inputQuantity > 0) {
                    console.warn(`模块 ${moduleId} (${moduleName}) 是输入模块，但有 ${inputQuantity} 个输入端口，不符合输入模块的定义`);
                    showNotification(`警告: 模块 ${moduleName} 是输入模块，但有输入端口，可能配置错误`);
                }
                
                // 4. 输出模块应该无输出端口
                if (moduleKind === '输出模块' && outputQuantity > 0) {
                    console.warn(`模块 ${moduleId} (${moduleName}) 是输出模块，但有 ${outputQuantity} 个输出端口，不符合输出模块的定义`);
                    showNotification(`警告: 模块 ${moduleName} 是输出模块，但有输出端口，可能配置错误`);
                }
                
                // 检查是否已经被暂停或停止
                if (isPaused || !isRunning) {
                    console.log(`模块 ${moduleId} 执行被暂停或停止`);
                    moduleState.executing = false;
                    return;
                }
                
                // 获取输入数据
                const inputValues = [];
                for (let i = 0; i < inputQuantity; i++) {
                    inputValues.push(moduleState.inputValues[i] !== undefined ? moduleState.inputValues[i] : null);
                }
                console.log(`输入值: 模块=${moduleState.moduleData.params.name}, 值=${inputValues}, 类型=${inputValues.map(v => typeof v)}`);
                
                // 加载模块设置中的默认值
                const moduleKey = `module_settings_${moduleId}_${moduleState.moduleData.params.name || 'default'}`;
                const savedSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
                
                // 对于所有模块，应用设置中的默认值
                // 这样有助于自定义模块的开发使用，无需为每个模块单独添加代码
                if (Object.keys(savedSettings).length > 0) {
                    const variableNames = moduleState.moduleData.params.variables_name ? moduleState.moduleData.params.variables_name.split(',') : [];
                    variableNames.forEach((name, index) => {
                        if (savedSettings[name] !== undefined && inputValues[index] === null) {
                            inputValues[index] = savedSettings[name];
                            console.log(`应用默认值: ${name} = ${savedSettings[name]}`);
                        }
                    });
                }
                
                let outputValues = [];
                
                // 特殊处理不需要后端执行的模块
                if (moduleState.moduleData.params.name === 'user输入' || moduleState.moduleData.params.userinput === true) {
                    // 检查模块是否有输入框
                    const moduleElement = document.querySelector(`.module[data-module-id="${moduleId}"]`);
                    const moduleInput = moduleElement ? moduleElement.querySelector('.module-input') : null;
                    
                    // 获取输入值
                            let inputValue;
                            // 特殊处理固定值输出模块，确保它只输出自己的固定值
                            if (moduleState.moduleData.params.name === '固定值输出模块') {
                                // 从模块输入区域获取值，不使用对话面板的值
                                if (moduleInput) {
                                    inputValue = moduleInput.value || '';
                                    console.log(`从固定值模块输入框获取值:`, inputValue);
                                } else {
                                    const inputValueElement = moduleElement ? moduleElement.querySelector('.input-value') : null;
                                    if (inputValueElement) {
                                        inputValue = inputValueElement.textContent === '请输入固定值' ? '' : inputValueElement.textContent;
                                        console.log(`从固定值模块输入区域获取值:`, inputValue);
                                    } else {
                                        inputValue = '';
                                        console.log(`固定值模块输入区域不存在，使用空值`);
                                    }
                                }
                            } else if (runTrigger === 'button') {
                                // 通过运行按钮激活时，从模块输入区域获取值
                                if (moduleInput) {
                                    inputValue = moduleInput.value || '';
                                    console.log(`从模块输入框获取值:`, inputValue);
                                } else {
                                    const inputValueElement = moduleElement ? moduleElement.querySelector('.input-value') : null;
                                    if (inputValueElement) {
                                        inputValue = inputValueElement.textContent === '请输入固定值' ? '' : inputValueElement.textContent;
                                        console.log(`从模块输入区域获取值:`, inputValue);
                                    } else {
                                        inputValue = '';
                                        console.log(`模块输入区域不存在，使用空值`);
                                    }
                                }
                            } else if (runTrigger === 'chat') {
                                // 通过对话激活时，从对话面板获取值
                                inputValue = getUserInput();
                                console.log(`从对话面板获取值:`, inputValue);
                            } else {
                                // 默认从模块输入区域获取值
                                if (moduleInput) {
                                    inputValue = moduleInput.value || getUserInput();
                                } else {
                                    const inputValueElement = moduleElement ? moduleElement.querySelector('.input-value') : null;
                                    if (inputValueElement) {
                                        inputValue = inputValueElement.textContent === '请输入固定值' ? getUserInput() : inputValueElement.textContent;
                                    } else {
                                        inputValue = getUserInput();
                                    }
                                }
                                console.log(`默认获取输入值:`, inputValue);
                            }
                    
                    // 用户输入模块逻辑
                    outputValues = [inputValue];
                    console.log(`${moduleState.moduleData.params.name} 模块输出:`, outputValues);
                } else if (moduleState.moduleData.params.name === '对话输出') {
                    // 对话输出模块逻辑
                    const inputData = inputValues[0];
                    // 检查输入数据是否存在（包括0）
                    if (inputData !== undefined && inputData !== null) {
                        outputToChatPanel(inputData);
                    }
                    outputValues = [inputData];
                    console.log(`对话输出模块输出:`, outputValues);
                } else if (moduleState.moduleData.params.name === '显示模块') {
                    // 显示模块逻辑（与缓存模块一致）
                    const inputData = inputValues[0];
                    // 存储输入数据作为输出（与缓存模块行为一致）
                    outputValues = [inputData];
                    // 设置displayContent变量，与实际内容分离
                    moduleState.displayContent = inputData || '';
                    console.log(`显示模块输出:`, outputValues);
                    console.log(`显示模块displayContent:`, moduleState.displayContent);
                } else if (moduleState.moduleData.params.name === '缓存模块') {
                    // 缓存模块逻辑
                    const inputData = inputValues[0];
                    // 生成更高精度的时间戳（毫秒+微秒）
                    const now = Date.now();
                    const microseconds = Math.floor(Math.random() * 1000);
                    const currentTime = now * 1000 + microseconds;
                    
                    // 如果有输入数据，更新缓存
                    if (inputData !== undefined && inputData !== null) {
                        // 时序冲突处理：检查是否是最新的输入
                        if (!moduleState.lastUpdated || currentTime > moduleState.lastUpdated) {
                            outputValues = [inputData];
                            // 设置displayContent变量，与实际内容分离
                            moduleState.displayContent = inputData || '';
                            // 更新最后更新时间
                            moduleState.lastUpdated = currentTime;
                            console.log(`缓存模块更新:`, outputValues);
                            console.log(`缓存模块displayContent:`, moduleState.displayContent);
                        } else if (currentTime === moduleState.lastUpdated) {
                            // 时间戳相同的极端情况：保留当前数据，记录冲突
                            outputValues = moduleState.outputValues.length > 0 ? moduleState.outputValues : [null];
                            console.log(`缓存模块时间戳冲突，保持原有值:`, outputValues);
                        } else {
                            // 忽略旧数据，保持原有缓存
                            outputValues = moduleState.outputValues.length > 0 ? moduleState.outputValues : [null];
                            console.log(`缓存模块忽略旧数据，保持原有值:`, outputValues);
                        }
                    } else {
                        // 如果没有输入数据，保持原有缓存
                        outputValues = moduleState.outputValues.length > 0 ? moduleState.outputValues : [null];
                        // 保持displayContent不变
                        console.log(`缓存模块保持原有值:`, outputValues);
                    }
                } else {
                    // 其他模块通过后端API执行
                    const moduleName = moduleState.moduleData.name;
                    console.log(`调用后端API执行模块: ${moduleName}`, inputValues);
                    
                    // 生成唯一的请求ID
                    const requestId = `${moduleId}_${Date.now()}`;
                    // 创建AbortController
                    const controller = new AbortController();
                    const signal = controller.signal;
                    
                    // 存储控制器，以便稍后可以取消请求
                    ongoingRequests.set(requestId, controller);
                    
                    try {
                        // 调用后端API
                        const response = await fetch('/api/execute_module', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                module_name: moduleName,
                                input_values: inputValues,
                                settings: savedSettings  // 传递设置参数
                            }),
                            signal: signal  // 传递信号
                        });
                    
                        if (!response.ok) {
                            throw new Error(`API调用失败: ${response.status}`);
                        }
                        
                        const result = await response.json();
                        if (result.error) {
                            throw new Error(`模块执行失败: ${result.error}`);
                        }
                        
                        // 处理返回结果
                        // 直接使用后端返回的结果数组
                        outputValues = result.result;
                        console.log(`后端返回结果:`, outputValues);
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log(`请求已取消: ${requestId}`);
                            return;
                        }
                        throw error;
                    } finally {
                        // 无论成功还是失败，都从Map中移除控制器
                        ongoingRequests.delete(requestId);
                    }
                }
                
                // 存储输出值
                outputValues.forEach((value, index) => {
                    moduleState.outputValues[index] = value;
                    console.log(`存储输出值: 模块=${moduleState.moduleData.params.name}, 端口索引=${index}, 值=${value}, 类型=${typeof value}`);
                });
                
                // 确保输出数组长度与输出端口数量一致
                while (moduleState.outputValues.length < outputQuantity) {
                    moduleState.outputValues.push(null);
                }
                
                // 标记模块为已执行
                if (setExecuted) {
                    moduleState.executed = true;
                }
                moduleState.executing = false;
                
                console.log(`模块执行完成: ${moduleId}`, outputValues);
                
                // 传输数据到连接的模块
                if (transferData) {
                    console.log(`开始传输数据: ${moduleId}`);
                    await transferDataFunc(moduleId);
                }
                
            } catch (error) {
                console.error(`模块执行错误: ${moduleId}`, error);
                moduleState.executing = false;
            }
        }
        
        // 传输数据到连接的模块
        async function transferDataFunc(moduleId) {
            const moduleState = moduleStates[moduleId];
            if (!moduleState) return;
            
            console.log(`开始传输数据: 模块=${moduleId}, 模块名称=${moduleState.moduleData.params.name}, 输出值=${moduleState.outputValues}`);
            
            // 查找从当前模块出发的所有连线
            const outgoingConnections = connectionLines.filter(conn => 
                conn.startModuleId === moduleId
            );
            
            console.log(`传输数据: 模块=${moduleId}, 连线数量=${outgoingConnections.length}`);
            
            // 处理每条连线的数据传输
            for (const connection of outgoingConnections) {
                const { endModuleId, startPortIndex, endPortIndex, isRed } = connection;
                const endModuleState = moduleStates[endModuleId];
                
                if (!endModuleState) {
                    console.log(`目标模块不存在: ${endModuleId}`);
                    continue;
                }
                
                console.log(`处理连线: 开始端口索引=${startPortIndex}, 结束端口索引=${endPortIndex}, 目标模块名称=${endModuleState.moduleData.params.name}`);
                
                try {
                    // 获取输出值
                    const outputValue = moduleState.outputValues[startPortIndex];
                    console.log(`获取输出值: 端口索引=${startPortIndex}, 值=${outputValue}, 类型=${typeof outputValue}`);
                    
                    // 只有当输出值不是None时才传输数据
                    if (outputValue !== undefined && outputValue !== null) {
                        // 添加传输动画
                        if (connection.line) {
                            connection.line.classList.add('transferring');
                        }
                        
                        // 处理多连一场景：实现数据合并和冲突提示
                        if (endModuleState.inputValues[endPortIndex] !== undefined && endModuleState.inputValues[endPortIndex] !== null) {
                            const existingValue = endModuleState.inputValues[endPortIndex];
                            console.log(`多连一场景: 目标端口已有值=${existingValue}, 新值=${outputValue}`);
                            
                            // 检查是否需要合并数据
                            if (Array.isArray(existingValue) && !Array.isArray(outputValue)) {
                                // 现有值是数组，新值不是数组，添加到数组
                                existingValue.push(outputValue);
                                endModuleState.inputValues[endPortIndex] = existingValue;
                                console.log(`多连一场景: 合并数据到数组`, existingValue);
                            } else if (Array.isArray(existingValue) && Array.isArray(outputValue)) {
                                // 两者都是数组，合并数组
                                const mergedArray = [...existingValue, ...outputValue];
                                endModuleState.inputValues[endPortIndex] = mergedArray;
                                console.log(`多连一场景: 合并两个数组`, mergedArray);
                            } else if (typeof existingValue === 'string' && typeof outputValue === 'string') {
                                // 两者都是字符串，拼接
                                const mergedString = existingValue + '\n' + outputValue;
                                endModuleState.inputValues[endPortIndex] = mergedString;
                                console.log(`多连一场景: 拼接字符串`, mergedString);
                            } else {
                                // 其他情况，使用最后接收到的值
                                endModuleState.inputValues[endPortIndex] = outputValue;
                                console.log(`多连一场景: 使用最后接收到的值`, outputValue);
                            }
                            
                            // 显示多输入冲突提示
                            showNotification(`模块 ${endModuleId} 的端口 ${endPortIndex} 接收到多个输入，已处理`);
                        } else {
                            // 首次输入，直接赋值
                            endModuleState.inputValues[endPortIndex] = outputValue;
                        }
                        console.log(`数据传输完成: ${moduleId} -> ${endModuleId}, 端口索引: ${endPortIndex}, 值: ${outputValue}, 类型: ${typeof outputValue}`);
                        
                        connection.data = outputValue;
                        connection.transferred = true;
                        
                        console.log(`数据传输完成: ${moduleId} -> ${endModuleId}, 端口索引: ${endPortIndex}, 值: ${endModuleState.inputValues[endPortIndex]}, 类型: ${typeof endModuleState.inputValues[endPortIndex]}`);
                        console.log(`目标模块输入值: ${endModuleState.inputValues}`);
                        
                        // 延迟移除传输动画
                        setTimeout(() => {
                            if (connection.line) {
                                connection.line.classList.remove('transferring');
                            }
                        }, 1000);
                    } else {
                        console.log(`跳过传输: 输出值为undefined或null, 端口索引=${startPortIndex}`);
                    }
                    
                    // 如果是红线，激活目标模块
                    if (isRed) {
                        console.log(`红线激活目标模块: ${endModuleId}`);
                        // 检查目标模块是否有延迟
                        let timeLate = endModuleState.moduleData.params.time_late;
                        // 非数字输入处理
                        if (timeLate === undefined || timeLate === null) {
                            timeLate = 0;
                            console.log(`延迟步数为undefined或null，设为默认值0`);
                        } else if (typeof timeLate !== 'number') {
                            // 尝试转换为数字
                            const parsedTimeLate = parseInt(timeLate);
                            if (isNaN(parsedTimeLate)) {
                                timeLate = 0;
                                console.log(`延迟步数不是数字，设为默认值0`);
                            } else {
                                timeLate = parsedTimeLate;
                                console.log(`延迟步数转换为数字: ${timeLate}`);
                            }
                        }
                        // 数值范围校验
                        const validTimeLate = Number.isInteger(timeLate) && timeLate >= 0;
                        const hasDelay = validTimeLate && timeLate > 0;
                        
                        if (!hasDelay) {
                            // 无延迟模块，立即执行
                            console.log(`立即执行目标模块: ${endModuleId}`);
                            await executeModule(endModuleId);
                        } else {
                            // 有延迟模块，等待后执行
                            console.log(`延迟执行目标模块: ${endModuleId}, 延迟步数: ${timeLate}`);
                            // 延迟时间 = 延迟步数 * 1000ms（每步1秒）
                            const delayTime = timeLate * 1000;
                            
                            // 创建延迟任务对象
                            const delayTask = {
                                moduleId: endModuleId,
                                delayTime: delayTime,
                                startTime: Date.now(),
                                timer: setTimeout(async () => {
                                    // 执行前检查是否已暂停
                                    if (!isPaused && isRunning) {
                                        await executeModule(endModuleId);
                                    }
                                    // 从队列中移除任务
                                    pendingDelayTasks = pendingDelayTasks.filter(task => task !== delayTask);
                                }, delayTime)
                            };
                            
                            // 添加到延迟任务队列
                            pendingDelayTasks.push(delayTask);
                        }
                    }
                } catch (error) {
                    console.error(`数据传输错误: ${moduleId} -> ${endModuleId}, 错误: ${error.message}`);
                    // 错误处理：继续处理其他连线，不中断整个传输过程
                }
            }
        }
        
        // 执行一个步进
        async function executeStep() {
            console.log(`开始执行步进: ${currentStep}`);
            
            // 重置所有模块的执行状态，包括缓存模块
            Object.values(moduleStates).forEach(moduleState => {
                moduleState.executed = false;
                moduleState.executing = false;
            });
            
            // 重置连线传输状态
            connectionLines.forEach(connection => {
                connection.transferred = false;
                // 移除之前的运行状态标记
                removeRunStatusMarker(connection);
            });
            
            // 1. 清空所有显示模块
            console.log('清空所有显示模块');
            Object.keys(moduleStates).forEach(moduleId => {
                const moduleState = moduleStates[moduleId];
                if (moduleState.moduleData.params.name === '显示模块') {
                    // 清空显示模块的输出值
                    moduleState.outputValues = [];
                    // 清空显示模块的displayContent
                    moduleState.displayContent = '';
                    // 更新显示
                    updateModuleDisplay(moduleId);
                    console.log(`清空显示模块: ${moduleId}`);
                }
            });
            
            // 2. 固定值输出模块优先输出（只给下一个模块的端口，不运行下一个模块）
            console.log('固定值输出模块优先输出阶段');
            for (const moduleId of Object.keys(moduleStates)) {
                const moduleState = moduleStates[moduleId];
                if (moduleState.moduleData.params.name === '固定值输出模块') {
                    // 执行固定值输出模块，获取输出值
                    console.log(`执行固定值输出模块: ${moduleId}, 输入值: ${moduleState.inputValues}`);
                    await executeModule(moduleId, { setExecuted: false, transferData: false });
                    updateModuleDisplay(moduleId);
                    console.log(`固定值输出模块执行完成: ${moduleId}, 输出值: ${moduleState.outputValues}`);
                    
                    // 传输输出值到下一个模块的端口，但不运行下一个模块
                    const outgoingConnections = connectionLines.filter(conn => 
                        conn.startModuleId === moduleId
                    );
                    
                    outgoingConnections.forEach(connection => {
                        const { endModuleId, startPortIndex, endPortIndex } = connection;
                        const endModuleState = moduleStates[endModuleId];
                        
                        if (endModuleState) {
                            // 获取输出值
                            const outputValue = moduleState.outputValues[startPortIndex];
                            console.log(`固定值输出模块输出值: 端口索引=${startPortIndex}, 值=${outputValue}, 类型=${typeof outputValue}`);
                            
                            // 只有当输出值不是None时才传输数据
                            if (outputValue !== undefined && outputValue !== null) {
                                // 添加传输动画
                                if (connection.line) {
                                    connection.line.classList.add('transferring');
                                }
                                
                                // 检查下一个模块是否为输出模块
                                if (endModuleState.moduleData.params.kind !== '输出模块') {
                                    // 存储到目标模块的输入值
                                    endModuleState.inputValues[endPortIndex] = outputValue;
                                    connection.data = outputValue;
                                    connection.transferred = true;
                                    
                                    console.log(`固定值输出模块数据传输完成: ${moduleId} -> ${endModuleId}, 端口索引: ${endPortIndex}, 值: ${outputValue}, 类型: ${typeof outputValue}`);
                                    console.log(`目标模块输入值: ${endModuleState.inputValues}`);
                                    
                                    // 延迟移除传输动画
                                    setTimeout(() => {
                                        if (connection.line) {
                                            connection.line.classList.remove('transferring');
                                        }
                                    }, 1000);
                                    

                                } else {
                                    console.log(`跳过传输: 目标模块为输出模块, ${endModuleId}`);
                                }
                            } else {
                                console.log(`跳过传输: 输出值为undefined或null, 端口索引=${startPortIndex}`);
                            }
                        }
                    });
                }
            }
            
            // 3. 缓存模块输出（只给下一个模块的端口，不运行下一个模块）
            console.log('缓存模块输出阶段');
            for (const moduleId of Object.keys(moduleStates)) {
                const moduleState = moduleStates[moduleId];
                if (moduleState.moduleData.params.name === '缓存模块') {
                    // 执行缓存模块，获取输出值
                    console.log(`执行缓存模块: ${moduleId}, 输入值: ${moduleState.inputValues}`);
                    await executeModule(moduleId, { setExecuted: false, transferData: false });
                    updateModuleDisplay(moduleId);
                    console.log(`缓存模块执行完成: ${moduleId}, 输出值: ${moduleState.outputValues}`);
                    console.log(`缓存模块displayContent: ${moduleState.displayContent}`);
                    
                    // 传输输出值到下一个模块的端口，但不运行下一个模块
                    const outgoingConnections = connectionLines.filter(conn => 
                        conn.startModuleId === moduleId
                    );
                    
                    outgoingConnections.forEach(connection => {
                        const { endModuleId, startPortIndex, endPortIndex } = connection;
                        const endModuleState = moduleStates[endModuleId];
                        
                        if (endModuleState) {
                            // 获取输出值
                            const outputValue = moduleState.outputValues[startPortIndex];
                            console.log(`缓存模块输出值: 端口索引=${startPortIndex}, 值=${outputValue}, 类型=${typeof outputValue}`);
                            
                            // 只有当输出值不是None时才传输数据
                            if (outputValue !== undefined && outputValue !== null) {
                                // 添加传输动画
                                if (connection.line) {
                                    connection.line.classList.add('transferring');
                                }
                                
                                // 检查下一个模块是否为输出模块
                                if (endModuleState.moduleData.params.kind !== '输出模块') {
                                    // 存储到目标模块的输入值
                                    endModuleState.inputValues[endPortIndex] = outputValue;
                                    connection.data = outputValue;
                                    connection.transferred = true;
                                    
                                    console.log(`缓存模块数据传输完成: ${moduleId} -> ${endModuleId}, 端口索引: ${endPortIndex}, 值: ${outputValue}, 类型: ${typeof outputValue}`);
                                    console.log(`目标模块输入值: ${endModuleState.inputValues}`);
                                    
                                    // 延迟移除传输动画
                                    setTimeout(() => {
                                        if (connection.line) {
                                            connection.line.classList.remove('transferring');
                                        }
                                    }, 1000);
                                    

                                } else {
                                    console.log(`跳过传输: 目标模块为输出模块, ${endModuleId}`);
                                }
                            } else {
                                console.log(`跳过传输: 输出值为undefined或null, 端口索引=${startPortIndex}`);
                            }
                        }
                    });
                }
            }
            
            // 3. 计算执行顺序
            const executionOrder = calculateExecutionOrder();
            console.log('执行顺序:', executionOrder);
            
            // 执行所有模块（包括缓存模块）按照计算出的顺序
            for (const moduleId of executionOrder) {
                const moduleState = moduleStates[moduleId];
                console.log(`执行模块: ${moduleId}, 名称: ${moduleState.moduleData.params.name}, 输入值: ${moduleState.inputValues}`);
                await executeModule(moduleId);
                updateModuleDisplay(moduleId);
                console.log(`模块执行完成: ${moduleId}, 输出值: ${moduleState.outputValues}`);
            }
            
            // 显示连线运行状态
            connectionLines.forEach(connection => {
                if (connection.transferred) {
                    addRunStatusMarker(connection);
                }
            });
            
            // 检查是否需要停止（对话输出模块接收到内容）
            const dialogueOutputModules = Object.keys(moduleStates).filter(moduleId => {
                return moduleStates[moduleId].moduleData.params.name === '对话输出';
            });
            
            console.log('检查对话输出模块:', dialogueOutputModules);
            
            // 检查比大小模块的输出
            const compareModules = Object.keys(moduleStates).filter(moduleId => {
                return moduleStates[moduleId].moduleData.params.name === '比大小';
            });
            
            for (const moduleId of compareModules) {
                const moduleState = moduleStates[moduleId];
                console.log('比大小模块状态:', moduleState);
                console.log('比大小模块输出值:', moduleState.outputValues);
            }
            
            let shouldStop = false;
            for (const moduleId of dialogueOutputModules) {
                const moduleState = moduleStates[moduleId];
                console.log('对话输出模块状态:', moduleState);
                console.log('对话输出模块输入值:', moduleState.inputValues);
                console.log('对话输出模块输出值:', moduleState.outputValues);
                
                // 检查输入数据是否存在（包括0）
                if (moduleState.inputValues[0] !== undefined && moduleState.inputValues[0] !== null) {
                    console.log('对话输出模块接收到内容，停止运行:', moduleState.inputValues[0]);
                    showNotification('对话输出模块接收到内容，停止运行');
                    shouldStop = true;
                    break;
                } else {
                    console.log('对话输出模块未接收到内容或内容为undefined/null:', moduleState.inputValues[0]);
                }
            }
            
            // 检查是否存在循环依赖导致的无限执行
            if (!shouldStop) {
                // 检查是否所有模块都已执行
                const allModulesExecuted = Object.values(moduleStates).every(moduleState => moduleState.executed);
                
                // 检查是否所有数据都已传输
                const allDataTransferred = connectionLines.every(connection => connection.transferred);
                
                // 检查是否有输出模块接收到内容
                const outputModulesWithContent = Object.keys(moduleStates).filter(moduleId => {
                    const moduleState = moduleStates[moduleId];
                    return moduleState.moduleData.params.kind === '输出模块' && 
                           moduleState.inputValues.some(value => value !== undefined && value !== null);
                });
                
                console.log('检查执行状态: 所有模块已执行=', allModulesExecuted, '所有数据已传输=', allDataTransferred, '输出模块有内容=', outputModulesWithContent.length > 0);
                
                // 如果所有模块都已执行，所有数据都已传输，且有输出模块接收到内容，则停止运行
                if (allModulesExecuted && allDataTransferred && outputModulesWithContent.length > 0) {
                    console.log('所有模块执行完成，数据传输完成，且有输出模块接收到内容，停止运行');
                    showNotification('所有模块执行完成，停止运行');
                    shouldStop = true;
                }
            }
            
            // 只有在确定需要停止时才调用stopExecution
            if (shouldStop) {
                stopExecution();
            }
            
            currentStep++;
            console.log(`步进执行完成: ${currentStep - 1}`);
        }
        
        // 添加运行状态标记
        function addRunStatusMarker(connection) {
            // 检查是否已经有标记
            if (connection.statusMarker) {
                // 更新现有标记位置
                updateRunStatusMarker(connection);
                return;
            }
            
            // 创建标记元素
            const marker = document.createElement('div');
            marker.className = 'run-status-marker';
            marker.style.position = 'absolute';
            marker.style.width = '10px';
            marker.style.height = '10px';
            marker.style.backgroundColor = 'yellow';
            marker.style.borderRadius = '50%';
            marker.style.zIndex = '1001';
            marker.style.transform = 'translate(-50%, -50%)';
            marker.style.pointerEvents = 'none'; // 避免干扰鼠标事件
            
            // 计算标记位置（连线中间）
            const startPos = getPortPosition(connection.startPort);
            const endPos = getPortPosition(connection.endPort);
            const midX = (startPos.x + endPos.x) / 2;
            const midY = (startPos.y + endPos.y) / 2;
            
            // 考虑画布的缩放和偏移，确保标记位置正确
            marker.style.left = `${midX}px`;
            marker.style.top = `${midY}px`;
            
            // 添加到画布
            canvasContent.appendChild(marker);
            connection.statusMarker = marker;
        }
        
        // 更新运行状态标记位置
        function updateRunStatusMarker(connection) {
            if (!connection.statusMarker) {
                return;
            }
            
            try {
                // 计算标记位置（连线中间）
                const startPos = getPortPosition(connection.startPort);
                const endPos = getPortPosition(connection.endPort);
                const midX = (startPos.x + endPos.x) / 2;
                const midY = (startPos.y + endPos.y) / 2;
                
                // 考虑画布的缩放和偏移，确保标记位置正确
                // 获取当前缩放比例
                const zoomLevel = window.getCurrentZoomLevel ? window.getCurrentZoomLevel() : 100;
                const scale = zoomLevel / 100;
                
                // 应用缩放和偏移，确保标记位置正确
                connection.statusMarker.style.left = `${midX}px`;
                connection.statusMarker.style.top = `${midY}px`;
                
                // 确保标记在极端缩放比例下也能正确显示
                connection.statusMarker.style.transform = 'translate(-50%, -50%)';
                connection.statusMarker.style.zIndex = '1001';
            } catch (error) {
                console.error('更新运行状态标记位置失败:', error);
                // 如果更新失败，移除标记
                removeRunStatusMarker(connection);
            }
        }
        
        // 移除运行状态标记
        function removeRunStatusMarker(connection) {
            if (connection.statusMarker) {
                try {
                    connection.statusMarker.remove();
                } catch (error) {
                    console.error('移除运行状态标记失败:', error);
                }
                connection.statusMarker = null;
            }
        }
        
        // 同步所有连线状态标记
        function syncAllRunStatusMarkers() {
            connectionLines.forEach(connection => {
                if (connection.statusMarker) {
                    updateRunStatusMarker(connection);
                }
            });
        }
        
        // 更新模块显示
        function updateModuleDisplay(moduleId) {
            const moduleState = moduleStates[moduleId];
            if (!moduleState) return;
            
            // 查找对应的DOM元素
            const moduleElement = document.querySelector(`.module[data-module-id="${moduleId}"]`);
            if (!moduleElement) return;
            
            // 更新缓存模块的显示框
            if (moduleState.moduleData.params.name === '缓存模块') {
                const showingWindow = moduleElement.querySelector('.showing-window');
                if (showingWindow) {
                    const contentSpan = showingWindow.querySelector('.window-content');
                    
                    const displayContent = moduleState.displayContent !== undefined && moduleState.displayContent !== null ? moduleState.displayContent : '';
                    const shortDisplayContent = displayContent.toString().length > 10 ? displayContent.toString().substring(0, 10) + '...' : displayContent;
                    
                    contentSpan.textContent = `缓存内容: ${shortDisplayContent}`;
                }
            } else if (moduleState.moduleData.params.name === '显示模块') {
                // 更新显示模块的显示框
                const showingWindow = moduleElement.querySelector('.showing-window');
                if (showingWindow) {
                    const contentSpan = showingWindow.querySelector('.window-content');
                    
                    const displayContent = moduleState.displayContent !== undefined && moduleState.displayContent !== null ? moduleState.displayContent : '';
                    const shortDisplayContent = displayContent.toString().length > 10 ? displayContent.toString().substring(0, 10) + '...' : displayContent;
                    
                    contentSpan.textContent = `显示内容: ${shortDisplayContent}`;
                }
            }
        }
        
        // 显示通知
        function showNotification(message) {
            // 创建通知元素
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.right = '20px';
            notification.style.backgroundColor = '#333';
            notification.style.color = 'white';
            notification.style.padding = '10px 15px';
            notification.style.borderRadius = '4px';
            notification.style.zIndex = '3000';
            notification.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            notification.textContent = message;
            
            // 添加到文档
            document.body.appendChild(notification);
            
            // 3秒后移除
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.5s';
                setTimeout(() => {
                    notification.remove();
                }, 500);
            }, 3000);
        }
        
        // 自动运行
        function startAutoRun() {
            if (isRunning) return;
            
            isRunning = true;
            isPaused = false;
            console.log('开始自动运行，间隔:', autoRunInterval, 'ms');
            
            // 清除之前的定时器
            if (executionTimer) {
                clearInterval(executionTimer);
                executionTimer = null;
            }
            
            // 执行第一个步进
            executeStep().then(() => {
                // 第一个步进执行完成后，设置定时器自动执行下一个步进
                executionTimer = setInterval(() => {
                    if (!isRunning || isPaused) {
                        clearInterval(executionTimer);
                        executionTimer = null;
                        return;
                    }
                    
                    executeStep().then(() => {
                        // 步进执行完成后，检查是否需要停止
                        // 这里可以添加停止条件，例如达到最大步进数或用户手动停止
                    });
                }, autoRunInterval);
            });
        }
        
        // 暂停运行
        function pauseExecution() {
            isPaused = true;
            console.log('暂停运行');
            
            // 处理未完成的延迟任务
            console.log('暂停时处理延迟任务:', pendingDelayTasks.length, '个任务');
            
            // 遍历所有延迟任务，清除定时器并计算剩余时间
            pendingDelayTasks.forEach(task => {
                // 清除定时器
                clearTimeout(task.timer);
                
                // 计算剩余延迟时间
                const elapsedTime = Date.now() - task.startTime;
                const remainingTime = Math.max(0, task.delayTime - elapsedTime);
                
                // 更新任务状态为暂停
                task.paused = true;
                task.remainingTime = remainingTime;
                task.timer = null;
                
                console.log(`暂停延迟任务: ${task.moduleId}, 剩余时间: ${remainingTime}ms`);
            });
        }
        
        // 继续运行
        function resumeExecution() {
            if (!isRunning) {
                startAutoRun();
            } else {
                isPaused = false;
                console.log('继续运行，间隔:', autoRunInterval, 'ms');
                
                // 恢复暂停的延迟任务
                console.log('恢复延迟任务:', pendingDelayTasks.length, '个任务');
                
                pendingDelayTasks.forEach(task => {
                    if (task.paused) {
                        // 恢复执行延迟任务
                        console.log(`恢复延迟任务: ${task.moduleId}, 剩余时间: ${task.remainingTime}ms`);
                        
                        // 设置新的定时器
                        task.timer = setTimeout(async () => {
                            // 执行前检查是否已暂停
                            if (!isPaused && isRunning) {
                                await executeModule(task.moduleId);
                            }
                            // 从队列中移除任务
                            pendingDelayTasks = pendingDelayTasks.filter(t => t !== task);
                        }, task.remainingTime);
                        
                        // 重置任务状态
                        task.paused = false;
                        task.startTime = Date.now();
                        task.delayTime = task.remainingTime;
                        task.remainingTime = null;
                    }
                });
                
                // 清除之前的定时器
                if (executionTimer) {
                    clearInterval(executionTimer);
                    executionTimer = null;
                }
                
                // 执行一个步进，然后继续自动运行
                executeStep().then(() => {
                    // 步进执行完成后，继续自动运行
                    if (isRunning && !isPaused) {
                        executionTimer = setInterval(() => {
                            if (!isRunning || isPaused) {
                                clearInterval(executionTimer);
                                executionTimer = null;
                                return;
                            }
                            
                            executeStep().then(() => {
                                // 步进执行完成后，检查是否需要停止
                            });
                        }, autoRunInterval);
                    }
                });
            }
        }
        
        // 停止运行
        function stopExecution() {
            isRunning = false;
            isPaused = false;
            currentStep = 0;
            
            if (executionTimer) {
                clearInterval(executionTimer);
                executionTimer = null;
            }
            
            // 清除所有未完成的延迟任务
            console.log('停止时清除延迟任务:', pendingDelayTasks.length, '个任务');
            pendingDelayTasks.forEach(task => {
                if (task.timer) {
                    clearTimeout(task.timer);
                }
            });
            pendingDelayTasks = [];
            
            // 取消所有正在进行的API请求
            ongoingRequests.forEach((controller, requestId) => {
                controller.abort();
                console.log(`取消请求: ${requestId}`);
            });
            ongoingRequests.clear();
            
            // 重置模块执行状态
            Object.values(moduleStates).forEach(moduleState => {
                moduleState.executed = false;
                moduleState.executing = false;
            });
            
            // 重置连线传输状态
            connectionLines.forEach(connection => {
                connection.transferred = false;
                // 移除之前的运行状态标记
                removeRunStatusMarker(connection);
            });
            
            // 清空端口变量，明确清空范围
            Object.values(moduleStates).forEach(state => {
                // 明确需要清空的变量：只清空业务数据变量
                // 1. 清空输入值（业务数据）
                state.inputValues = state.inputValues.map(() => null);
                
                // 2. 清空输出值（业务数据），但保留缓存模块的缓存值
                if (state.moduleData.params.name !== '缓存模块') {
                    state.outputValues = state.outputValues.map(() => null);
                } else {
                    // 缓存模块保留缓存值
                    console.log(`保留缓存模块 ${state.moduleData.params.name} 的缓存值`);
                }
                
                // 3. 保留显示内容（UI展示数据）
                // 对于显示模块和缓存模块，不清空displayContent，保持显示内容
                if (state.moduleData.params.name !== '显示模块' && state.moduleData.params.name !== '缓存模块') {
                    state.displayContent = '';
                } else {
                    console.log(`保留 ${state.moduleData.params.name} 的显示内容`);
                }
                
                // 4. 保留基础配置变量（模块属性）
                // 模块的基础配置（如坐标、类型、端口数量等）已经存储在moduleData中，不需要清空
                // 这些值不会在运行过程中改变，清空它们会导致模块配置丢失
                console.log(`保留模块 ${state.moduleData.params.name} 的基础配置`);
            });
            
            console.log('停止运行，重置所有状态');
        }
        
        // 执行单个步进
        function executeSingleStep() {
            if (isRunning) return;
            
            executeStep();
        }
        
        // 加载模块
        async function loadModules() {
            try {
                const response = await fetch('/api/modules');
                if (!response.ok) {
                    throw new Error(`加载模块失败: ${response.status}`);
                }
                const data = await response.json();
                
                // 处理同名模块优先级：默认模块优先于自定义模块
                // 但保留从.aiud文件中加载的自定义模块（如果默认模块中不存在）
                const mergedModules = { ...data };
                const conflictModules = [];
                
                // 保留从.aiud文件中加载的自定义模块
                for (const [name, params] of Object.entries(modules)) {
                    if (params.source === 'custom') {
                        if (!mergedModules[name]) {
                            mergedModules[name] = params;
                        } else {
                            // 检测到模块冲突
                            const existingModule = mergedModules[name];
                            conflictModules.push({
                                name: name,
                                existingSource: existingModule.source || '默认模块',
                                newSource: params.source || '自定义模块'
                            });
                            console.log(`模块冲突: ${name} - 现有: ${existingModule.source}, 新: ${params.source}`);
                        }
                    }
                }
                
                // 显示模块冲突提示
                if (conflictModules.length > 0) {
                    let conflictMessage = '检测到模块冲突:\n';
                    conflictModules.forEach(conflict => {
                        conflictMessage += `- ${conflict.name}: ${conflict.existingSource} 优先于 ${conflict.newSource}\n`;
                    });
                    showNotification(conflictMessage);
                }
                
                // 检查是否有模块更新
                const hasModuleChanges = JSON.stringify(modules) !== JSON.stringify(mergedModules);
                
                modules = mergedModules;
                renderModules();
                
                if (hasModuleChanges) {
                    console.log('模块已更新，正在同步模块实例...');
                    // 同步更新画布上的模块实例
                    syncModuleInstances();
                    showNotification('模块库已更新');
                }
            } catch (error) {
                console.error('加载模块失败:', error);
                showNotification(`加载模块失败: ${error.message}`);
            }
        }
        
        // 同步更新模块实例
        function syncModuleInstances() {
            // 遍历所有模块实例
            Object.keys(moduleStates).forEach(moduleId => {
                const moduleState = moduleStates[moduleId];
                const moduleName = moduleState.moduleData.name;
                
                // 检查模块是否存在于更新后的模块列表中
                if (modules[moduleName]) {
                    // 更新模块数据
                    const updatedModuleData = {
                        name: moduleName,
                        params: modules[moduleName]
                    };
                    
                    // 保留原有状态，只更新模块定义
                    moduleState.moduleData = updatedModuleData;
                    
                    // 更新DOM元素
                    const moduleElement = document.querySelector(`.module[data-module-id="${moduleId}"]`);
                    if (moduleElement) {
                        // 这里可以添加DOM元素的更新逻辑，例如更新模块名称、类型等
                        console.log(`模块实例已更新: ${moduleId} - ${moduleName}`);
                    }
                } else {
                    console.warn(`模块不存在: ${moduleName}`);
                }
            });
        }
        
        // 渲染模块到模块库
        function renderModules() {
            // 清空模块库
            const categoryIds = [
                'sampling-modules', 'loader-modules', 'latent-modules', 'image-modules', 'other-modules', 'custom-modules'
            ];
            
            categoryIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.innerHTML = '';
                }
            });
            
            // 分类渲染模块
            for (const [name, params] of Object.entries(modules)) {
                const moduleItem = document.createElement('div');
                moduleItem.className = 'module-item';
                moduleItem.draggable = true;
                moduleItem.dataset.name = name;
                moduleItem.dataset.params = JSON.stringify(params);
                
                moduleItem.innerHTML = `
                    <div class="module-name">${params.name || name}</div>
                    <div class="module-kind">${params.kind || '未知'}</div>
                `;
                
                // 添加拖拽事件
                moduleItem.addEventListener('dragstart', handleDragStart);
                
                // 根据模块来源和类型分类
                let targetElementId;
                
                // 自定义模块全部归类到自定义模块分类
                if (params.source === 'custom') {
                    targetElementId = 'custom-modules';
                } else {
                    // 默认模块根据名称或类型分类
                    targetElementId = 'other-modules'; // 默认归类到其它分类
                    
                    // 根据模块名称进行分类
                    const moduleName = params.name || name;
                    
                    if (moduleName.includes('UNet') || moduleName.includes('VAE') || moduleName.includes('CLIP') || moduleName.includes('LoRA')) {
                        targetElementId = 'loader-modules';
                    } else if (moduleName.includes('采样') || moduleName.includes('K采样器')) {
                        targetElementId = 'sampling-modules';
                    } else if (moduleName.includes('Latent') || moduleName.includes('latent')) {
                        targetElementId = 'latent-modules';
                    } else if (moduleName.includes('图像') || moduleName.includes('图片')) {
                        targetElementId = 'image-modules';
                    }
                }
                
                // 检查目标元素是否存在
                const targetElement = document.getElementById(targetElementId);
                if (targetElement) {
                    targetElement.appendChild(moduleItem);
                } else {
                    // 如果目标元素不存在，使用其它分类
                    const defaultElement = document.getElementById('other-modules');
                    if (defaultElement) {
                        defaultElement.appendChild(moduleItem);
                    }
                }
            }
        }
        
        // 处理拖拽开始
        function handleDragStart(e) {
            draggedModule = e.target;
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', JSON.stringify({
                name: e.target.dataset.name,
                params: JSON.parse(e.target.dataset.params)
            }));
        }
        
        // 处理画布拖拽
        function handleCanvasDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }
        
        // 处理画布放置
        function handleCanvasDrop(e) {
            e.preventDefault();
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            createModuleOnCanvas(data, e.offsetX, e.offsetY);
        }
        
        // 项目文件默认值规则配置
        const DEFAULT_VALUES = {
            version: '0.1',
            modules: [],
            connections: [],
            canvasSize: { width: 4000, height: 3000 },
            timestamp: new Date().toISOString(),
            usedCustomModules: [],
            module: {
                id: null, // 动态生成
                name: '未知模块',
                kind: '未知',
                left: '0px',
                top: '0px',
                moduleData: {
                    name: '未知模块',
                    params: {
                        name: '未知模块',
                        kind: '未知',
                        input_quantity: 0,
                        output_quantity: 0,
                        showingwindow_quantity: 0,
                        inputtingwindow_quantity: 0,
                        setting: false,
                        userinput: false,
                        time_late: 0,
                        excitedbydata: false,
                        variables_name: '',
                        output_name: ''
                    }
                },
                settings: {},
                inputValue: ''
            },
            connection: {
                startModuleId: '',
                startPortIndex: 0,
                endModuleId: '',
                endPortIndex: 0,
                isRed: false
            }
        };
        
        // 处理项目数据，添加版本兼容和缺失字段处理
        function processProjectData(projectData) {
            try {
                // 保存原始数据作为备份
                const originalData = JSON.parse(JSON.stringify(projectData));
                
                // 创建副本，避免修改原始数据
                const processedData = JSON.parse(JSON.stringify(projectData));
                
                // 应用默认值规则
                processedData.version = processedData.version || DEFAULT_VALUES.version;
                processedData.modules = processedData.modules || DEFAULT_VALUES.modules;
                processedData.connections = processedData.connections || DEFAULT_VALUES.connections;
                processedData.canvasSize = processedData.canvasSize || DEFAULT_VALUES.canvasSize;
                processedData.timestamp = processedData.timestamp || DEFAULT_VALUES.timestamp;
                processedData.usedCustomModules = processedData.usedCustomModules || DEFAULT_VALUES.usedCustomModules;
                
                // 处理模块数据
                processedData.modules = processedData.modules.map(moduleInfo => {
                    // 应用模块默认值
                    moduleInfo.id = moduleInfo.id || `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    moduleInfo.name = moduleInfo.name || DEFAULT_VALUES.module.name;
                    moduleInfo.kind = moduleInfo.kind || DEFAULT_VALUES.module.kind;
                    moduleInfo.left = moduleInfo.left || DEFAULT_VALUES.module.left;
                    moduleInfo.top = moduleInfo.top || DEFAULT_VALUES.module.top;
                    moduleInfo.moduleData = moduleInfo.moduleData || JSON.parse(JSON.stringify(DEFAULT_VALUES.module.moduleData));
                    moduleInfo.settings = moduleInfo.settings || DEFAULT_VALUES.module.settings;
                    moduleInfo.inputValue = moduleInfo.inputValue !== undefined ? moduleInfo.inputValue : DEFAULT_VALUES.module.inputValue;
                    
                    // 确保模块参数完整
                    moduleInfo.moduleData.params = moduleInfo.moduleData.params || {};
                    // 应用模块参数默认值
                    Object.keys(DEFAULT_VALUES.module.moduleData.params).forEach(key => {
                        if (moduleInfo.moduleData.params[key] === undefined) {
                            moduleInfo.moduleData.params[key] = DEFAULT_VALUES.module.moduleData.params[key];
                        }
                    });
                    
                    return moduleInfo;
                });
                
                // 处理连接数据
                processedData.connections = processedData.connections.map(connInfo => {
                    // 应用连接默认值
                    connInfo.startModuleId = connInfo.startModuleId || DEFAULT_VALUES.connection.startModuleId;
                    connInfo.startPortIndex = connInfo.startPortIndex !== undefined ? connInfo.startPortIndex : DEFAULT_VALUES.connection.startPortIndex;
                    connInfo.endModuleId = connInfo.endModuleId || DEFAULT_VALUES.connection.endModuleId;
                    connInfo.endPortIndex = connInfo.endPortIndex !== undefined ? connInfo.endPortIndex : DEFAULT_VALUES.connection.endPortIndex;
                    connInfo.isRed = connInfo.isRed !== undefined ? connInfo.isRed : DEFAULT_VALUES.connection.isRed;
                    
                    return connInfo;
                });
                
                // 版本特定处理
                if (processedData.version < '1.0') {
                    // 处理旧版本数据
                    console.log('处理旧版本项目数据:', processedData.version);
                    // 这里可以添加针对旧版本的特定处理逻辑
                }
                
                console.log('项目数据处理完成:', processedData);
                return processedData;
            } catch (error) {
                console.error('项目数据处理失败:', error);
                // 处理失败时返回默认项目数据
                console.log('使用默认项目数据');
                return {
                    version: DEFAULT_VALUES.version,
                    modules: [],
                    connections: [],
                    canvasSize: DEFAULT_VALUES.canvasSize,
                    timestamp: DEFAULT_VALUES.timestamp,
                    usedCustomModules: []
                };
            }
        }
        
        // 生成唯一的模块ID
        function generateModuleId() {
            // 使用UUID v4生成唯一ID，格式为8-4-4-4-12的16进制数字
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // 在画布上创建模块
        function createModuleOnCanvas(moduleData, x, y) {
            const module = document.createElement('div');
            module.className = 'module';
            
            // 为模块添加唯一标识符
            const moduleId = generateModuleId();
            module.dataset.moduleId = moduleId;
            
            // 初始化模块状态
                    moduleStates[moduleId] = {
                        moduleData: moduleData,
                        inputValues: [], // 输入端口值（改为数组）
                        outputValues: [], // 输出端口值（改为数组）
                        displayContent: '', // 显示框内容（与实际内容分离）
                        executed: false, // 执行状态
                        executing: false, // 执行中状态
                        lastUpdated: null // 最后更新时间，用于处理时序冲突
                    };
                    
                    // 为缓存模块设置初始值
                    if (moduleData.params.name === '缓存模块') {
                        moduleStates[moduleId].outputValues = [null]; // 初始化为null
                        moduleStates[moduleId].displayContent = '缓存内容: 空';
                    } else if (moduleData.params.name === '显示模块') {
                        moduleStates[moduleId].outputValues = [null]; // 初始化为null
                        moduleStates[moduleId].displayContent = '显示内容: 空';
                    }
            
            // 根据输入输出端口数量设置样式
            if (moduleData.params.input_quantity === 0) {
                module.classList.add('no-input');
            }
            if (moduleData.params.output_quantity === 0) {
                module.classList.add('no-output');
            }
            
            // 调整模块宽度，使其更紧凑美观
            module.style.width = '220px';
            module.style.left = `${x - 110}px`;
            module.style.top = `${y - 40}px`;
            
            // 创建输入端口
            let inputPortsHtml = '';
            const inputNames = moduleData.params.variables_name ? moduleData.params.variables_name.split(',') : [];
            for (let i = 0; i < (moduleData.params.input_quantity || 0); i++) {
                const portName = inputNames[i] || `IN_${(i+1).toString().padStart(3, '0')}`;
                inputPortsHtml += `<div style="display: flex; align-items: center; margin: 2px 0; white-space: nowrap;">
                    <div class="port input-port" data-port="input-${i}" style="margin-right: 8px;"></div>
                    <span style="font-size: 10px; flex: 1; overflow: hidden; text-overflow: ellipsis;">${portName}</span>
                </div>`;
            }
            
            // 创建输出端口
            let outputPortsHtml = '';
            const outputNames = moduleData.params.output_name ? moduleData.params.output_name.split(',') : [];
            for (let i = 0; i < (moduleData.params.output_quantity || 0); i++) {
                const portName = outputNames[i] || `OUT_${(i+1).toString().padStart(3, '0')}`;
                outputPortsHtml += `<div style="display: flex; align-items: center; margin: 2px 0; white-space: nowrap;">
                    <span style="font-size: 10px; flex: 1; text-align: right; margin-right: 8px; overflow: hidden; text-overflow: ellipsis;">${portName}</span>
                    <div class="port output-port" data-port="output-${i}"></div>
                </div>`;
            }
            
            // 添加设置按钮
            let settingBtnHtml = '';
            if (moduleData.params.setting === true || moduleData.params.setting === 'T' || moduleData.params.setting === 'true') {
                // 转义JSON字符串中的双引号，确保在HTML属性中正确显示
                const escapedModuleData = JSON.stringify(moduleData).replace(/"/g, '&quot;');
                settingBtnHtml = `<div class="setting-btn" data-module="${escapedModuleData}">Set</div>`;
            }
            
            // 创建显示框
            let showingWindowHtml = '';
            if (moduleData.params.showingwindow_quantity > 0) {
                showingWindowHtml = `<div class="showing-window" style="margin-top: 10px; padding: 5px; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; font-size: 10px; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; position: relative;">
                    <span class="window-content" style="cursor: help;">${moduleData.params.name === '缓存模块' ? '缓存内容...' : '显示内容'}</span>
                </div>`;
            }
            
            module.innerHTML = `
                ${settingBtnHtml}
                <div class="module-header">${moduleData.params.name || moduleData.name}</div>
                <div class="module-kind">${moduleData.params.kind || '未知'}</div>
                <div class="ports" style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div class="input-ports" style="flex: 1; margin-right: 10px;">${inputPortsHtml}</div>
                    <div style="width: 1px; background-color: #ddd; height: 100%; margin: 0 10px;"></div>
                    <div class="output-ports" style="flex: 1; margin-left: 10px;">${outputPortsHtml}</div>
                </div>
                ${showingWindowHtml}
                ${moduleData.params.inputtingwindow_quantity > 0 ? `<div class="inputting-window" style="margin-top: 10px; padding: 5px; background-color: #f0f8ff; border: 1px solid #add8e6; border-radius: 4px; font-size: 10px; max-width: 100%; cursor: pointer;" onclick="openInputSettingModal('${moduleData.name}', this.closest('.module').dataset.moduleId)">
                    <span style="display: block; margin-bottom: 3px;">输入值:</span>
                    <div style="width: 100%; padding: 3px; border: 1px solid #ddd; border-radius: 2px; font-size: 10px; background-color: white;">
                        <span class="input-value">请输入固定值</span>
                    </div>
                </div>` : ''}
            `;
            
            // 添加拖拽功能
            makeDraggable(module);
            
            // 添加端口事件
            module.querySelectorAll('.port').forEach(port => {
                port.addEventListener('mousedown', handlePortMouseDown);
                port.addEventListener('click', handlePortClick);
                port.addEventListener('dblclick', handlePortDoubleClick);
            });
            
            // 添加设置按钮点击事件
            const settingBtn = module.querySelector('.setting-btn');
            if (settingBtn) {
                settingBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const moduleData = JSON.parse(settingBtn.dataset.module);
                    const moduleId = module.dataset.moduleId;
                    openSettingModal(moduleData, moduleId);
                });
            }
            
            // 添加显示框悬停事件
            const showingWindow = module.querySelector('.showing-window');
            if (showingWindow) {
                const contentSpan = showingWindow.querySelector('.window-content');
                const tooltip = showingWindow.querySelector('.tooltip');
                
                // 鼠标进入时显示完整内容
                contentSpan.addEventListener('mouseenter', function(e) {
                    // 根据模块类型获取实际内容
                    const currentModule = this.closest('.module');
                    const moduleId = parseInt(currentModule.dataset.moduleId);
                    const moduleState = moduleStates[moduleId];
                    
                    let fullContent = '';
                    if (moduleState) {
                        if (moduleState.moduleData.params.name === '缓存模块' || moduleState.moduleData.params.name === '显示模块') {
                                const displayContent = moduleState.displayContent !== undefined && moduleState.displayContent !== null ? moduleState.displayContent : '';
                                const prefix = moduleState.moduleData.params.name === '缓存模块' ? '缓存内容: ' : '显示内容: ';
                                fullContent = `${prefix}${displayContent}`;
                            } else {
                            // 对于其他模块，显示完整的默认内容
                            fullContent = contentSpan.textContent;
                        }
                    } else {
                        fullContent = contentSpan.textContent;
                    }
                    
                    // 创建一个新的tooltip元素，确保它能够正确显示
                    let tooltipElement = document.getElementById('custom-tooltip');
                    if (!tooltipElement) {
                        tooltipElement = document.createElement('div');
                        tooltipElement.id = 'custom-tooltip';
                        tooltipElement.style.cssText = `
                            display: none;
                            position: fixed;
                            background-color: #333;
                            color: white;
                            padding: 10px;
                            border-radius: 4px;
                            font-size: 12px;
                            z-index: 9999;
                            max-width: 800px;
                            max-height: 500px;
                            overflow: auto;
                            word-wrap: break-word;
                            pointer-events: none;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                        `;
                        document.body.appendChild(tooltipElement);
                    }
                    
                    tooltipElement.textContent = fullContent;
                    tooltipElement.style.display = 'block';
                    
                    // 定位tooltip到鼠标位置附近
                    tooltipElement.style.left = `${e.pageX + 10}px`;
                    tooltipElement.style.top = `${e.pageY + 10}px`;
                });
                
                // 鼠标移动时更新tooltip位置
                contentSpan.addEventListener('mousemove', function(e) {
                    const tooltipElement = document.getElementById('custom-tooltip');
                    if (tooltipElement && tooltipElement.style.display === 'block') {
                        tooltipElement.style.left = `${e.pageX + 10}px`;
                        tooltipElement.style.top = `${e.pageY + 10}px`;
                    }
                });
                
                // 鼠标离开时隐藏tooltip
                contentSpan.addEventListener('mouseleave', function() {
                    const tooltipElement = document.getElementById('custom-tooltip');
                    if (tooltipElement) {
                        tooltipElement.style.display = 'none';
                    }
                });
            }
            
            canvasContent.appendChild(module);
        }
        
        // 计算端口位置
        function getPortPosition(port) {
            // 获取模块元素
            const module = port.closest('.module');
            if (!module) return { x: 0, y: 0 };
            
            // 获取模块的位置
            const moduleLeft = parseFloat(module.style.left) || 0;
            const moduleTop = parseFloat(module.style.top) || 0;
            
            // 获取模块和端口的实际位置（不考虑变换）
            // 使用offsetLeft和offsetTop来获取相对于父元素的位置
            let portX = 0;
            let portY = 0;
            let current = port;
            
            // 计算端口相对于模块的位置
            while (current && current !== module) {
                portX += current.offsetLeft;
                portY += current.offsetTop;
                current = current.offsetParent;
            }
            
            // 计算端口中心位置
            const relativeX = portX + port.offsetWidth / 2;
            const relativeY = portY + port.offsetHeight / 2;
            
            // 计算端口相对于画布内容的绝对位置
            return {
                x: moduleLeft + relativeX,
                y: moduleTop + relativeY
            };
        }
        
        // 更新连线位置
        function updateConnectionLine(connection) {
            if (!connection || !connection.startPort || !connection.endPort) return;
            
            const startPos = getPortPosition(connection.startPort);
            const endPos = getPortPosition(connection.endPort);
            
            // 计算连线的长度和角度
            const length = Math.sqrt(Math.pow(endPos.x - startPos.x, 2) + Math.pow(endPos.y - startPos.y, 2));
            const angle = Math.atan2(endPos.y - startPos.y, endPos.x - startPos.x) * 180 / Math.PI;
            
            const line = connection.line;
            line.style.width = `${length}px`;
            line.style.left = `${startPos.x}px`;
            line.style.top = `${startPos.y + 1.5}px`;
            line.style.transform = `rotate(${angle}deg)`;
            line.style.zIndex = '1000'; // 确保连线显示在模块上方
        }
        
        // 使模块可拖拽
        function makeDraggable(element) {
            // 添加draggable属性，支持HTML5拖放API
            element.draggable = true;
            
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;
            
            function dragMouseDown(e) {
                // 只处理左键点击
                if (e.button !== 0) return;
                
                // 检查是否点击了输入框或其他可交互元素
                const target = e.target;
                if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT' || target.isContentEditable || target.closest('.inputting-window')) {
                    return; // 不处理输入元素和输入区域的点击
                }
                
                e = e || window.event;
                e.preventDefault();
                e.stopPropagation(); // 阻止事件冒泡到画布
                
                // 开始鼠标拖动
                isDragging = true;
                // 获取鼠标位置
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.addEventListener('mouseup', closeDragElement);
                document.addEventListener('mousemove', elementDrag);
            }
            
            function elementDrag(e) {
                if (!isDragging) return;
                
                e = e || window.event;
                e.preventDefault();
                // 计算新位置
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                // 检查鼠标是否在模块库区域内
                const moduleLibrary = document.querySelector('.module-library');
                const libraryRect = moduleLibrary.getBoundingClientRect();
                
                if (pos3 >= libraryRect.left && pos3 <= libraryRect.right && 
                    pos4 >= libraryRect.top && pos4 <= libraryRect.bottom) {
                    // 鼠标在模块库区域内，准备删除模块
                    moduleLibrary.style.backgroundColor = '#e3f2fd';
                } else {
                    // 鼠标不在模块库区域内，正常移动模块
                    moduleLibrary.style.backgroundColor = '#f5f5f5';
                    // 设置新位置
                    element.style.top = (element.offsetTop - pos2) + "px";
                    element.style.left = (element.offsetLeft - pos1) + "px";
                    
                    // 更新与该模块相关的所有连线
                    connectionLines.forEach(connection => {
                        if (connection.startPort.closest('.module') === element || 
                            connection.endPort.closest('.module') === element) {
                            updateConnectionLine(connection);
                        }
                    });
                }
            }
            
            function closeDragElement(e) {
                // 停止移动
                isDragging = false;
                document.removeEventListener('mouseup', closeDragElement);
                document.removeEventListener('mousemove', elementDrag);
                
                // 检查鼠标是否在模块库区域内，如果是则删除模块
                const moduleLibrary = document.querySelector('.module-library');
                const libraryRect = moduleLibrary.getBoundingClientRect();
                
                if (e && pos3 >= libraryRect.left && pos3 <= libraryRect.right && 
                    pos4 >= libraryRect.top && pos4 <= libraryRect.bottom) {
                    // 鼠标在模块库区域内，删除模块
                    console.log('删除模块:', element);
                    
                    // 删除模块状态
                    const moduleId = element.dataset.moduleId;
                    if (moduleId) {
                        delete moduleStates[moduleId];
                        console.log('删除模块状态:', moduleId);
                    }
                    
                    // 删除与该模块相关的所有连线
                    connectionLines = connectionLines.filter(connection => {
                        const isRelated = connection.startPort.closest('.module') === element || 
                                        connection.endPort.closest('.module') === element;
                        if (isRelated) {
                            connection.line.remove();
                        }
                        return !isRelated;
                    });
                    
                    // 删除模块
                    element.remove();
                    console.log('模块删除成功');
                }
                
                // 重置模块库背景色
                moduleLibrary.style.backgroundColor = '#f5f5f5';
            }
            
            // 拖放API事件处理
            function handleDragStart(e) {
                // 只处理左键拖放
                if (e.button !== 0) return;
                
                console.log('画布模块dragstart事件触发:', this);
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                // 设置拖拽数据，确保能被识别
                e.dataTransfer.setData('text/plain', 'module');
            }
            
            function handleDragEnd(e) {
                console.log('画布模块dragend事件触发:', this);
                this.classList.remove('dragging');
            }
            
            function handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
            }
            
            function handleDrop(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // 使用addEventListener替代直接赋值
            element.addEventListener('mousedown', dragMouseDown);
            // 添加拖放API事件监听器
            element.addEventListener('dragstart', handleDragStart);
            element.addEventListener('dragend', handleDragEnd);
            element.addEventListener('dragover', handleDragOver);
            element.addEventListener('drop', handleDrop);
            
            // 确保模块能响应拖放事件
            element.style.position = 'absolute';
            element.style.zIndex = '50'; // 确保模块显示在连线的下方
        }
        
        // 创建连线元素
        function createConnectionLine(x1, y1, x2, y2, isRed = false) {
            const line = document.createElement('div');
            line.className = `connection-line ${isRed ? 'red' : ''}`;
            
            // 计算连线的长度和角度
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            // 设置连线的样式
            line.style.width = `${length}px`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1 + 1.5}px`; // +1.5 是为了让线条垂直居中
            line.style.transform = `rotate(${angle}deg)`;
            line.style.zIndex = '1000'; // 确保连线显示在模块上方
            
            // 添加双击切换颜色功能
            line.addEventListener('dblclick', function() {
                line.classList.toggle('red');
            });
            
            // 添加长按事件，显示设置框
            let longPressTimer;
            line.addEventListener('mousedown', function(e) {
                e.stopPropagation();
                longPressTimer = setTimeout(function() {
                    showLineSettings(line, e.clientX, e.clientY);
                }, 500); // 500ms长按
            });
            
            line.addEventListener('mouseup', function() {
                clearTimeout(longPressTimer);
            });
            
            line.addEventListener('mouseleave', function() {
                clearTimeout(longPressTimer);
            });
            
            return line;
        }
        
        // 处理端口鼠标按下
        function handlePortMouseDown(e) {
            e.preventDefault();
            e.stopPropagation(); // 阻止事件冒泡到模块
            isDrawing = true;
            draggedPort = e.target;
            
            // 使用新的getPortPosition函数计算端口位置
            const portPos = getPortPosition(e.target);
            startX = portPos.x;
            startY = portPos.y;
            
            // 创建临时连线
            currentConnection = createConnectionLine(startX, startY, startX, startY);
            canvasContent.appendChild(currentConnection);
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        
        // 处理鼠标移动
        function handleMouseMove(e) {
            if (!isDrawing || !currentConnection) return;
            
            const canvasRect = canvas.getBoundingClientRect();
            endX = e.clientX - canvasRect.left + canvas.scrollLeft;
            endY = e.clientY - canvasRect.top + canvas.scrollTop;
            
            // 更新临时连线
            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
            
            currentConnection.style.width = `${length}px`;
            currentConnection.style.transform = `rotate(${angle}deg)`;
        }
        
        // 处理鼠标释放
        function handleMouseUp(e) {
            if (isDrawing && currentConnection) {
                isDrawing = false;
                
                // 检查是否释放到了另一个端口
                const target = e.target;
                if (target.classList.contains('port') && target !== draggedPort) {
                    // 确保是从输出端口到输入端口的连接
                    const isOutputPort = draggedPort.classList.contains('output-port');
                    const isInputPort = target.classList.contains('input-port');
                    
                    if (isOutputPort && isInputPort) {
                        // 使用新的getPortPosition函数计算目标端口的位置
                        const startPos = getPortPosition(draggedPort);
                        const endPos = getPortPosition(target);
                        
                        // 更新连线
                        const length = Math.sqrt(Math.pow(endPos.x - startPos.x, 2) + Math.pow(endPos.y - startPos.y, 2));
                        const angle = Math.atan2(endPos.y - startPos.y, endPos.x - startPos.x) * 180 / Math.PI;
                        
                        currentConnection.style.width = `${length}px`;
                        currentConnection.style.left = `${startPos.x}px`;
                        currentConnection.style.top = `${startPos.y + 1.5}px`;
                        currentConnection.style.transform = `rotate(${angle}deg)`;
                        
                        // 保存连线信息
                        connectionLines.push({
                            line: currentConnection,
                            startPort: draggedPort,
                            endPort: target,
                            isRed: currentConnection.classList.contains('red'),
                            data: null, // 传输的数据
                            transferred: false, // 数据是否已传输
                            startModuleId: draggedPort.closest('.module').dataset.moduleId,
                            endModuleId: target.closest('.module').dataset.moduleId,
                            startPortIndex: parseInt(draggedPort.dataset.port.split('-')[1]),
                            endPortIndex: parseInt(target.dataset.port.split('-')[1])
                        });
                    } else {
                        // 不是有效的连接，移除临时连线
                        currentConnection.remove();
                    }
                } else {
                    // 没有释放到端口，移除临时连线
                    currentConnection.remove();
                }
            }
            
            currentConnection = null;
            draggedPort = null;
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        }
        
        // 显示连线设置框
        function showLineSettings(line, x, y) {
            // 创建设置框
            const settingsBox = document.createElement('div');
            settingsBox.className = 'line-settings-box';
            settingsBox.style.position = 'fixed';
            settingsBox.style.left = `${x + 10}px`;
            settingsBox.style.top = `${y + 10}px`;
            settingsBox.style.backgroundColor = 'white';
            settingsBox.style.border = '1px solid #ddd';
            settingsBox.style.borderRadius = '4px';
            settingsBox.style.padding = '8px';
            settingsBox.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
            settingsBox.style.zIndex = '2000';
            settingsBox.style.minWidth = '120px';
            
            // 设置框内容
            settingsBox.innerHTML = `
                <div style="margin-bottom: 5px;">
                    <button onclick="toggleLineColor(this.parentElement.parentElement)" style="width: 100%; padding: 4px;">
                        ${line.classList.contains('red') ? '切换为黑线' : '切换为红线'}
                    </button>
                </div>
                <div>
                    <button onclick="deleteLine(this.parentElement.parentElement)" style="width: 100%; padding: 4px; color: red;">
                        删除连线
                    </button>
                </div>
            `;
            
            // 添加到文档
            document.body.appendChild(settingsBox);
            
            // 阻止设置框内部事件冒泡
            settingsBox.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // 阻止连线事件冒泡，防止点击连线关闭设置框
            line.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // 点击外部关闭设置框
            function closeSettings(e) {
                if (!settingsBox.contains(e.target) && e.target !== line) {
                    try {
                        document.body.removeChild(settingsBox);
                    } catch (error) {
                        console.log('设置框已被移除:', error);
                    }
                    document.removeEventListener('click', closeSettings);
                }
            }
            
            // 延迟添加事件监听器，确保长按后的mouseup事件不会触发
            setTimeout(function() {
                document.addEventListener('click', closeSettings);
            }, 200);
            
            // 保存当前连线引用
            settingsBox.line = line;
        }
        
        // 切换连线颜色
        function toggleLineColor(settingsBox) {
            const line = settingsBox.line;
            line.classList.toggle('red');
            // 更新按钮文本
            const button = settingsBox.querySelector('button:first-child');
            button.textContent = line.classList.contains('red') ? '切换为黑线' : '切换为红线';
            
            // 更新连线对象的isRed属性
            const connection = connectionLines.find(conn => conn.line === line);
            if (connection) {
                connection.isRed = line.classList.contains('red');
            }
        }
        
        // 删除连线
        function deleteLine(settingsBox) {
            const line = settingsBox.line;
            // 从connectionLines中移除
            connectionLines = connectionLines.filter(connection => connection.line !== line);
            // 删除DOM元素
            line.remove();
            // 关闭设置框
            document.body.removeChild(settingsBox);
        }
        
        // 处理端口点击
        function handlePortClick(e) {
            e.stopPropagation();
            
            if (!firstPort) {
                // 第一次点击，保存端口
                firstPort = e.target;
                // 改变鼠标指针为十字
                canvas.style.cursor = 'crosshair';
            } else if (firstPort === e.target) {
                // 点击同一个端口，取消操作
                firstPort = null;
                canvas.style.cursor = 'grab';
            } else {
                // 第二次点击，检查是否是有效的连接
                const targetPort = e.target;
                const isOutputPort = firstPort.classList.contains('output-port');
                const isInputPort = targetPort.classList.contains('input-port');
                
                if (isOutputPort && isInputPort) {
                    // 创建连线
                    const startPos = getPortPosition(firstPort);
                    const endPos = getPortPosition(targetPort);
                    
                    const line = createConnectionLine(startPos.x, startPos.y, endPos.x, endPos.y);
                    canvasContent.appendChild(line);
                    
                    // 保存连线信息
                    connectionLines.push({
                        line: line,
                        startPort: firstPort,
                        endPort: targetPort,
                        isRed: line.classList.contains('red'),
                        data: null, // 传输的数据
                        transferred: false, // 数据是否已传输
                        startModuleId: firstPort.closest('.module').dataset.moduleId,
                        endModuleId: targetPort.closest('.module').dataset.moduleId,
                        startPortIndex: parseInt(firstPort.dataset.port.split('-')[1]),
                        endPortIndex: parseInt(targetPort.dataset.port.split('-')[1])
                    });
                }
                
                // 重置状态
                firstPort = null;
                canvas.style.cursor = 'grab';
            }
        }
        
        // 处理端口双击
        function handlePortDoubleClick(e) {
            e.stopPropagation();
            
            const port = e.target;
            
            // 检查端口是否已经有连线
            const connectedLines = connectionLines.filter(connection => {
                return connection.startPort === port || connection.endPort === port;
            });
            
            if (connectedLines.length > 0) {
                // 如果有连线，删除所有相关连线
                connectedLines.forEach(connection => {
                    connection.line.remove();
                });
                
                // 从连线数组中移除
                connectionLines = connectionLines.filter(connection => {
                    return !connectedLines.includes(connection);
                });
            } else {
                // 如果没有连线，创建一个新的临时连线
                // 这里可以实现更复杂的逻辑，比如连接到最近的端口
                console.log('双击端口创建新连线');
            }
        }
        
        // 刷新模块
        document.getElementById('refresh-modules-btn').addEventListener('click', async function() {
            try {
                const response = await fetch('/api/refresh_modules');
                const data = await response.json();
                modules = data;
                renderModules();
                alert('模块刷新成功');
            } catch (error) {
                console.error('刷新模块失败:', error);
                alert('刷新模块失败');
            }
        });
        
        // 发送消息
        document.getElementById('send-btn').addEventListener('click', function() {
            sendMessage();
        });
        
        document.getElementById('chat-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        // 存储用户输入
        let userInput = '';
        
        // 页面加载完成后初始化模块分类折叠功能
        document.addEventListener('DOMContentLoaded', function() {
            initModuleCategoryCollapse();
        });
        
        function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            if (message) {
                // 存储用户输入
                userInput = message;
                
                // 添加用户消息
                addMessage('user', message);
                input.value = '';
                
                // 设置运行触发方式为对话
                runTrigger = 'chat';
                console.log('通过对话激活流程，runTrigger:', runTrigger);
                
                // 用户输入触发执行
                console.log('用户输入触发执行');
                startAutoRun();
            }
        }
        
        // 获取用户输入
        function getUserInput() {
            return userInput;
        }
        
        // 输出消息到对话面板
        function outputToChatPanel(content) {
            if (content) {
                addMessage('ai', content);
            }
        }
        
        function addMessage(type, content) {
            const messagesContainer = document.getElementById('chat-messages');
            const messageElement = document.createElement('div');
            messageElement.className = `message ${type}`;
            messageElement.textContent = content;
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // 画布事件监听
        canvas.addEventListener('dragover', handleCanvasDragOver);
        canvas.addEventListener('drop', handleCanvasDrop);
        
        // 初始化加载模块
        window.onload = function() {
            loadModules().then(() => {
                // 在(0,0)坐标处创建user输入模块
                // 查找user输入模块的数据
                let userInputModuleData = null;
                for (const [name, params] of Object.entries(modules)) {
                    if (params.name === 'user输入') {
                        userInputModuleData = {
                            name: name,
                            params: params
                        };
                        break;
                    }
                }
                
                // 如果找到user输入模块，创建它
                if (userInputModuleData) {
                    createModuleOnCanvas(userInputModuleData, 110, 40); // 调整坐标以确保模块完全可见
                }
            });
            initCollapseButtons();
            initZoomControls();
            initModuleDragDelete();
            initControlButtons();
        };
        
        // 初始化控制按钮事件
        function initControlButtons() {
            // 运行按钮
            document.getElementById('run-btn').addEventListener('click', function() {
                // 设置运行触发方式为按钮
                runTrigger = 'button';
                console.log('通过运行按钮激活流程，runTrigger:', runTrigger);
                
                if (isPaused) {
                    resumeExecution();
                } else {
                    startAutoRun();
                }
            });
            
            // 暂停按钮
            document.getElementById('pause-btn').addEventListener('click', function() {
                pauseExecution();
            });
            
            // 停止按钮
            document.getElementById('stop-btn').addEventListener('click', function() {
                stopExecution();
            });
            
            // 重启按钮
            document.getElementById('restart-btn').addEventListener('click', function() {
                console.log('点击重启按钮');
                // 调用后端重启API
                fetch('/api/restart', {
                    method: 'POST'
                })
                .then(response => {
                    if (!response.ok) {
                        throw new Error('重启失败');
                    }
                    return response.json();
                })
                .then(data => {
                    console.log('重启请求已发送:', data);
                    // 显示重启提示
                    alert('服务器正在重启，请稍候刷新页面...');
                    // 3秒后刷新页面
                    setTimeout(() => {
                        location.reload();
                    }, 3000);
                })
                .catch(error => {
                    console.error('重启出错:', error);
                    alert('重启请求发送失败，请手动重启服务器');
                });
            });
            
            // 生成代码按钮
            document.getElementById('generate-code-btn').addEventListener('click', function() {
                // 生成Python代码
                const pythonCode = generatePythonCode();
                
                // 创建代码展示模态框
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 9999;
                `;
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background-color: white;
                    padding: 20px;
                    border-radius: 8px;
                    width: 80%;
                    max-width: 800px;
                    max-height: 80%;
                    overflow: auto;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                `;
                
                const modalHeader = document.createElement('div');
                modalHeader.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 15px;
                    padding-bottom: 10px;
                    border-bottom: 1px solid #ddd;
                `;
                
                const modalTitle = document.createElement('h3');
                modalTitle.textContent = '生成的Python代码';
                modalTitle.style.margin = '0';
                
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '关闭';
                closeBtn.style.cssText = `
                    padding: 5px 10px;
                    background-color: #f44336;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                closeBtn.addEventListener('click', function() {
                    document.body.removeChild(modal);
                });
                
                const codeContainer = document.createElement('div');
                codeContainer.style.cssText = `
                    background-color: #f5f5f5;
                    padding: 15px;
                    border-radius: 4px;
                    font-family: 'Courier New', monospace;
                    white-space: pre-wrap;
                    line-height: 1.4;
                `;
                
                const codeElement = document.createElement('pre');
                codeElement.textContent = pythonCode;
                codeContainer.appendChild(codeElement);
                
                const copyBtn = document.createElement('button');
                copyBtn.textContent = '复制代码';
                copyBtn.style.cssText = `
                    margin-top: 15px;
                    padding: 8px 16px;
                    background-color: #4CAF50;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                copyBtn.addEventListener('click', function() {
                    navigator.clipboard.writeText(pythonCode).then(function() {
                        alert('代码已复制到剪贴板');
                    }).catch(function(err) {
                        console.error('复制失败:', err);
                    });
                });
                
                modalHeader.appendChild(modalTitle);
                modalHeader.appendChild(closeBtn);
                modalContent.appendChild(modalHeader);
                modalContent.appendChild(codeContainer);
                modalContent.appendChild(copyBtn);
                modal.appendChild(modalContent);
                
                document.body.appendChild(modal);
            });
            
            // 生成Python代码的函数
            function generatePythonCode() {
                // 收集所有模块的信息
                const modules = [];
                document.querySelectorAll('.module').forEach(module => {
                    const moduleId = module.dataset.moduleId;
                    const moduleState = moduleStates[moduleId];
                    if (moduleState) {
                        // 读取模块设置
                        const moduleKey = `module_settings_${moduleId}_${moduleState.moduleData.params.name || 'default'}`;
                        const savedSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
                        
                        modules.push({
                            id: moduleId,
                            name: moduleState.moduleData.params.name,
                            kind: moduleState.moduleData.params.kind,
                            moduleData: moduleState.moduleData,
                            settings: savedSettings
                        });
                    }
                });
                
                // 过滤掉不需要的模块（如显示模块）
                const ignoredModules = ["显示模块"];
                const functionalModules = modules.filter(module => !ignoredModules.includes(module.name));
                
                // 分析模块类型
                const hasCallModule = functionalModules.some(module => module.name === "调用模块");
                const hasCacheModule = functionalModules.some(module => module.name === "缓存模块");
                const hasCompareModule = functionalModules.some(module => module.name === "比大小");
                
                // 获取模块设置
                let compareOperator = ">";
                const compareModule = functionalModules.find(module => module.name === "比大小");
                if (compareModule) {
                    compareOperator = compareModule.settings.运算符 || ">";
                }
                
                // 获取调用模块的设置
                let callModuleSettings = {};
                const callModule = functionalModules.find(module => module.name === "调用模块");
                if (callModule) {
                    callModuleSettings = callModule.settings;
                }
                
                // 提取调用模块的具体设置
                const modelSource = callModuleSettings.model_source || "lmstudio";
                const apiKey = callModuleSettings.api_key || "";
                const model = callModuleSettings.model || "gpt-3.5-turbo";
                const temperature = callModuleSettings.temperature || "0.7";
                const maxTokens = callModuleSettings.max_tokens || "1000";
                const timeout = callModuleSettings.timeout || "30";
                const delay = callModuleSettings.delay || "0";
                const lmstudioHost = callModuleSettings.lmstudio_host || "http://localhost:1234";
                const lmstudioModel = callModuleSettings.lmstudio_model || "abliterated";
                const context = callModuleSettings.context || "";
                const prompt = callModuleSettings.prompt || "";
                
                // 获取缓存模块的设置
                let cacheModuleSettings = {};
                const cacheModule = functionalModules.find(module => module.name === "缓存模块");
                if (cacheModule) {
                    cacheModuleSettings = cacheModule.settings;
                }
                
                // 提取缓存模块的具体设置
                const cacheFile = cacheModuleSettings.cache_file || "cache.json";
                const cacheSize = cacheModuleSettings.cache_size || "100";
                
                // 生成Python代码
                let code = `#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
图形化编程生成的Python代码

功能: 根据图形化编程逻辑自动生成的代码
"""

import time
import requests
import json


def main(user_input=None):
    """主执行函数
    
    参数:
    - user_input: 用户输入内容，等效于浏览器中的用户输入
    
    返回:
    - AI的回复内容
    """
    # 获取用户输入
    if user_input is None:
        user_input = input("请输入内容: ")
    
    # 初始化变量
    context = ""
    dialogue = user_input
    
`;
                
                // 添加调用模块逻辑
                if (hasCallModule) {
                    code += '    # 调用AI模型\n';
                    code += '    def call_ai_model(dialogue, context=""):\n';
                    code += '        """调用AI模型获取回复"""\n';
                    code += '        # 模型设置\n';
                    code += '        model_source = "' + modelSource + '"\n';
                    code += '        api_key = "' + apiKey + '"\n';
                    code += '        model = "' + model + '"\n';
                    code += '        temperature = ' + temperature + '\n';
                    code += '        max_tokens = ' + maxTokens + '\n';
                    code += '        timeout = ' + timeout + '\n';
                    code += '        delay = ' + delay + '\n';
                    code += '        lmstudio_host = "' + lmstudioHost + '"\n';
                    code += '        lmstudio_model = "' + lmstudioModel + '"\n';
                    code += '        prompt = "' + prompt + '"\n';
                    code += '        \n';
                    code += '        # 处理延迟\n';
                    code += '        if delay > 0:\n';
                    code += '            time.sleep(delay)\n';
                    code += '        \n';
                    code += '        # 实际模型调用\n';
                    code += '        try:\n';
                    code += '            if model_source == "lmstudio":\n';
                    code += '                # 调用LM Studio API\n';
                    code += '                messages = [\n';
                    code += '                    {"role": "system", "content": "You are a helpful assistant."}\n';
                    code += '                ]\n';
                    code += '                \n';
                    code += '                # 添加上下文\n';
                    code += '                if context:\n';
                    code += '                    messages.append({"role": "system", "content": f"上下文信息: {context}"})\n';
                    code += '                \n';
                    code += '                # 添加用户对话\n';
                    code += '                if dialogue:\n';
                    code += '                    messages.append({"role": "user", "content": dialogue})\n';
                    code += '                \n';
                    code += '                # 构建请求数据\n';
                    code += '                payload = {\n';
                    code += '                    "model": lmstudio_model,\n';
                    code += '                    "messages": messages,\n';
                    code += '                    "temperature": temperature,\n';
                    code += '                    "max_tokens": max_tokens\n';
                    code += '                }\n';
                    code += '                \n';
                    code += '                # 发送请求\n';
                    code += '                response = requests.post(\n';
                    code += '                    f"{lmstudio_host}/v1/chat/completions",\n';
                    code += '                    headers={"Content-Type": "application/json"},\n';
                    code += '                    data=json.dumps(payload),\n';
                    code += '                    timeout=timeout\n';
                    code += '                )\n';
                    code += '                \n';
                    code += '                # 处理响应\n';
                    code += '                if response.status_code == 200:\n';
                    code += '                    response_data = response.json()\n';
                    code += '                    result = response_data["choices"][0]["message"]["content"]\n';
                    code += '                else:\n';
                    code += '                    result = f"调用LM Studio失败: {response.status_code} - {response.text}"\n';
                    code += '            else:\n';
                    code += '                # 其他模型来源的实现可以在这里添加\n';
                    code += '                result = "无法调用"\n';
                    code += '        except Exception as e:\n';
                    code += '            # 错误处理\n';
                    code += '            result = f"调用模型失败: {str(e)}"\n';
                    code += '        \n';
                    code += '        # 更新上下文\n';
                    code += '        if dialogue:\n';
                    code += '            updated_context = "用户: " + str(dialogue) + " AI: " + str(result)\n';
                    code += '        else:\n';
                    code += '            updated_context = result\n';
                    code += '        \n';
                    code += '        return result, updated_context\n';
                    code += '    \n';
                }
                
                // 添加缓存模块逻辑
                if (hasCacheModule) {
                    code += '    # 缓存处理\n';
                    code += '    def save_to_cache(data):\n';
                    code += '        """保存数据到缓存"""\n';
                    code += '        # 缓存设置\n';
                    code += '        cache_file = "' + cacheFile + '"\n';
                    code += '        cache_size = ' + cacheSize + '\n';
                    code += '        \n';
                    code += '        print(f"缓存内容: {data}")\n';
                    code += '        # 实际实现中可以添加文件写入或数据库操作\n';
                    code += '    \n';
                }
                
                // 添加比大小模块逻辑
                if (hasCompareModule) {
                    code += '    # 比大小逻辑\n';
                    code += '    def compare_values(a, b, operator="' + compareOperator + '"):\n';
                    code += '        """比较两个值的大小"""\n';
                    code += '        try:\n';
                    code += '            a = float(a)\n';
                    code += '            b = float(b)\n';
                    code += '            if operator == ">":\n';
                    code += '                return a > b\n';
                    code += '            elif operator == "<":\n';
                    code += '                return a < b\n';
                    code += '            elif operator == "==":\n';
                    code += '                return a == b\n';
                    code += '            elif operator == ">=":\n';
                    code += '                return a >= b\n';
                    code += '            elif operator == "<=":\n';
                    code += '                return a <= b\n';
                    code += '            else:\n';
                    code += '                return False\n';
                    code += '        except ValueError:\n';
                    code += '            return False\n';
                    code += '    \n';
                }
                
                // 添加主逻辑执行
                code += `    # 主逻辑执行
    print("开始处理...")
    
`;
                
                // 处理调用模块
                if (hasCallModule) {
                    code += `    # 执行AI模型调用
    ai_response, context = call_ai_model(dialogue, context)
    print(f"AI回复: {ai_response}")
    
`;
                }
                
                // 处理缓存模块
                if (hasCacheModule && hasCallModule) {
                    code += `    # 保存到缓存
    save_to_cache(ai_response)
    
`;
                }
                
                // 处理比大小模块
                if (hasCompareModule) {
                    code += '    # 执行比大小操作\n';
                    code += '    try:\n';
                    code += '        input_value = float(user_input)\n';
                    code += '        comparison_result = compare_values(input_value, 10)\n';
                    code += '        print("比较结果: " + str(input_value) + " ' + compareOperator + ' 10 = " + str(comparison_result))\n';
                    code += '    except ValueError:\n';
                    code += '        print("输入不是有效的数字，无法进行比较")\n';
                    code += '    \n';
                }
                
                // 添加返回语句
                code += `    # 返回结果
    print("处理完成")
`;
                
                if (hasCallModule) {
                    code += `    return ai_response
`;
                } else {
                    code += `    return user_input
`;
                }
                
                // 添加主函数调用
                code += `

if __name__ == "__main__":
    # 示例用法
    # 1. 传入参数调用
    # result = main("你的输入内容")
    
    # 2. 交互式调用
    user_input = input("请输入内容: ")
    result = main(user_input)
    print("\\n最终结果: " + str(result))
    print("\\n可以通过以下方式集成到其他代码中:")
    print("from generated_code import main")
    print("result = main('你的输入内容')")
`;
                
                return code;
            }
            
            // 新建项目按钮
            document.getElementById('new-project-btn').addEventListener('click', function() {
                // 弹出确认清空的弹窗
                if (confirm('确定要清空画布，创建新项目吗？')) {
                    // 清空中央画布
                    // 删除所有模块
                    document.querySelectorAll('.module').forEach(module => module.remove());
                    // 删除所有连接
                    document.querySelectorAll('.connection-line').forEach(line => line.remove());
                    // 清空连接数组
                    connectionLines = [];
                    // 清空模块状态
                    moduleStates = {};
                    // 重置模块计数器
                    moduleCounter = 0;
                    // 重置项目名
                    document.getElementById('project-name').textContent = '未命名项目';
                    // 重新创建user输入模块
                    loadModules().then(() => {
                        let userInputModuleData = null;
                        for (const [name, params] of Object.entries(modules)) {
                            if (params.name === 'user输入') {
                                userInputModuleData = {
                                    name: name,
                                    params: params
                                };
                                break;
                            }
                        }
                        
                        // 如果找到user输入模块，创建它
                        if (userInputModuleData) {
                            createModuleOnCanvas(userInputModuleData, 110, 40); // 调整坐标以确保模块完全可见
                        }
                    });
                    console.log('新建项目成功，画布已清空');
                }
            });
            
            // 保存项目按钮
            document.getElementById('save-project-btn').addEventListener('click', async function() {
                try {
                    // 收集所有模块的信息
                    const modules = [];
                    const usedCustomModules = new Set();
                    document.querySelectorAll('.module').forEach(module => {
                        const moduleId = module.dataset.moduleId;
                        const moduleState = moduleStates[moduleId];
                        if (moduleState) {
                            // 读取模块设置
                            const moduleKey = `module_settings_${moduleId}_${moduleState.moduleData.params.name || 'default'}`;
                            const savedSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
                            
                            // 获取输入值
                            let inputValue = '';
                            const inputElement = module.querySelector('.module-input');
                            if (inputElement) {
                                inputValue = inputElement.value;
                            } else {
                                const inputValueElement = module.querySelector('.input-value');
                                if (inputValueElement) {
                                    inputValue = inputValueElement.textContent === '请输入固定值' ? '' : inputValueElement.textContent;
                                }
                            }
                            
                            modules.push({
                                id: moduleId,
                                name: moduleState.moduleData.params.name,
                                kind: moduleState.moduleData.params.kind,
                                left: module.style.left,
                                top: module.style.top,
                                moduleData: moduleState.moduleData,
                                settings: savedSettings,
                                inputValue: inputValue
                            });
                            
                            // 检查是否为自定义模块
                            if (moduleState.moduleData.params.source === 'custom') {
                                usedCustomModules.add(moduleState.moduleData.name);
                            }
                        }
                    });
                    
                    // 收集所有连接的信息
                    const connections = connectionLines.map(conn => ({
                        startModuleId: conn.startModuleId,
                        startPortIndex: conn.startPortIndex,
                        endModuleId: conn.endModuleId,
                        endPortIndex: conn.endPortIndex,
                        isRed: conn.isRed || false
                    }));
                    
                    // 构建项目数据
                    const projectData = {
                        version: '1.0', // 添加版本号，用于版本兼容
                        modules: modules,
                        connections: connections,
                        canvasSize: canvasSize,
                        timestamp: new Date().toISOString(),
                        usedCustomModules: Array.from(usedCustomModules)
                    };
                    
                    // 发送POST请求到服务器保存项目
                    const response = await fetch('/api/save_project', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ project_data: projectData })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        console.log('项目保存成功:', result.file_path);
                        alert('项目保存成功！');
                    } else {
                        console.error('保存项目失败:', result.error);
                        alert('保存项目失败: ' + result.error);
                    }
                } catch (error) {
                    console.error('保存项目失败:', error);
                    alert('保存项目失败，请检查控制台错误信息。');
                }
            });
            
            // 另存为项目按钮
            document.getElementById('save-as-project-btn').addEventListener('click', async function() {
                try {
                    // 收集所有模块的信息
                    const modules = [];
                    const usedCustomModules = new Set();
                    document.querySelectorAll('.module').forEach(module => {
                        const moduleId = module.dataset.moduleId;
                        const moduleState = moduleStates[moduleId];
                        if (moduleState) {
                            // 读取模块设置
                            const moduleKey = `module_settings_${moduleId}_${moduleState.moduleData.params.name || 'default'}`;
                            const savedSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
                            
                            // 获取输入值
                            let inputValue = '';
                            const inputElement = module.querySelector('.module-input');
                            if (inputElement) {
                                inputValue = inputElement.value;
                            } else {
                                const inputValueElement = module.querySelector('.input-value');
                                if (inputValueElement) {
                                    inputValue = inputValueElement.textContent === '请输入固定值' ? '' : inputValueElement.textContent;
                                }
                            }
                            
                            modules.push({
                                id: moduleId,
                                name: moduleState.moduleData.params.name,
                                kind: moduleState.moduleData.params.kind,
                                left: module.style.left,
                                top: module.style.top,
                                moduleData: moduleState.moduleData,
                                settings: savedSettings,
                                inputValue: inputValue
                            });
                            
                            // 检查是否为自定义模块
                            if (moduleState.moduleData.params.source === 'custom') {
                                usedCustomModules.add(moduleState.moduleData.name);
                            }
                        }
                    });
                    
                    // 收集所有连接的信息
                    const connections = connectionLines.map(conn => ({
                        startModuleId: conn.startModuleId,
                        startPortIndex: conn.startPortIndex,
                        endModuleId: conn.endModuleId,
                        endPortIndex: conn.endPortIndex,
                        isRed: conn.isRed || false
                    }));
                    
                    // 构建项目数据
                    const projectData = {
                        version: '1.0', // 添加版本号，用于版本兼容
                        modules: modules,
                        connections: connections,
                        canvasSize: canvasSize,
                        timestamp: new Date().toISOString(),
                        usedCustomModules: Array.from(usedCustomModules)
                    };
                    
                    // 创建zip文件
                    const zip = new JSZip();
                    
                    // 添加项目文件
                    zip.file('project.json', JSON.stringify(projectData, null, 2));
                    
                    // 添加自定义模块文件夹
                    const customModulesFolder = zip.folder('custom_modules');
                    
                    // 这里需要从服务器获取自定义模块的内容
                    // 由于浏览器环境限制，我们无法直接访问本地文件系统
                    // 所以这里只创建文件夹结构，实际的模块文件需要由服务器处理
                    
                    // 生成zip文件
                    const zipContent = await zip.generateAsync({ type: 'blob' });
                    
                    // 生成文件名
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
                    const defaultFileName = `ai_tool_project_${timestamp}.aiud`;
                    
                    // 尝试使用File System Access API
                    if (window.showSaveFilePicker) {
                        // 使用现代浏览器的File System Access API
                        const options = {
                            suggestedName: defaultFileName,
                            types: [
                                { accept: { 'application/zip': ['.aiud'] } }
                            ]
                        };
                        
                        try {
                            const handle = await window.showSaveFilePicker(options);
                            const writableStream = await handle.createWritable();
                            await writableStream.write(zipContent);
                            await writableStream.close();
                            
                            console.log('项目另存为成功:', projectData);
                            alert('项目另存为成功！');
                        } catch (error) {
                            // 用户取消了保存操作
                            console.log('用户取消了保存操作:', error);
                        }
                    } else {
                        // 浏览器不支持File System Access API，使用传统的下载方法
                        const url = URL.createObjectURL(zipContent);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = defaultFileName;
                        
                        // 触发下载
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        
                        // 释放URL对象
                        URL.revokeObjectURL(url);
                        
                        console.log('项目另存为成功:', projectData);
                        alert('项目另存为成功！');
                    }
                } catch (error) {
                    console.error('另存为项目失败:', error);
                    alert('另存为项目失败，请检查控制台错误信息。');
                }
            });
            
            // 生成模块内容
        function generateModuleContent(moduleData) {
            // 创建输入端口
            let inputPortsHtml = '';
            const inputNames = moduleData.params.variables_name ? moduleData.params.variables_name.split(',') : [];
            for (let i = 0; i < (moduleData.params.input_quantity || 0); i++) {
                const portName = inputNames[i] || `IN_${(i+1).toString().padStart(3, '0')}`;
                inputPortsHtml += `<div style="display: flex; align-items: center; margin: 2px 0; white-space: nowrap;">
                    <div class="port input-port" data-port="input-${i}" style="margin-right: 8px;"></div>
                    <span style="font-size: 10px; flex: 1; overflow: hidden; text-overflow: ellipsis;">${portName}</span>
                </div>`;
            }
            
            // 创建输出端口
            let outputPortsHtml = '';
            const outputNames = moduleData.params.output_name ? moduleData.params.output_name.split(',') : [];
            for (let i = 0; i < (moduleData.params.output_quantity || 0); i++) {
                const portName = outputNames[i] || `OUT_${(i+1).toString().padStart(3, '0')}`;
                outputPortsHtml += `<div style="display: flex; align-items: center; margin: 2px 0; white-space: nowrap;">
                    <span style="font-size: 10px; flex: 1; text-align: right; margin-right: 8px; overflow: hidden; text-overflow: ellipsis;">${portName}</span>
                    <div class="port output-port" data-port="output-${i}"></div>
                </div>`;
            }
            
            // 添加设置按钮
            let settingBtnHtml = '';
            if (moduleData.params.setting === true || moduleData.params.setting === 'T' || moduleData.params.setting === 'true') {
                // 转义JSON字符串中的双引号，确保在HTML属性中正确显示
                const escapedModuleData = JSON.stringify(moduleData).replace(/"/g, '&quot;');
                settingBtnHtml = `<div class="setting-btn" data-module="${escapedModuleData}">Set</div>`;
            }
            
            // 创建显示框
            let showingWindowHtml = '';
            if (moduleData.params.showingwindow_quantity > 0) {
                showingWindowHtml = `<div class="showing-window" style="margin-top: 10px; padding: 5px; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; font-size: 10px; max-width: 100%; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; position: relative;">
                    <span class="window-content" style="cursor: help;">${moduleData.params.name === '缓存模块' ? '缓存内容...' : '显示内容'}</span>
                </div>`;
            }
            
            // 创建输入窗口
            let inputtingWindowHtml = '';
            if (moduleData.params.inputtingwindow_quantity > 0) {
                // 转义moduleData.name中的单引号，确保在HTML属性中正确显示
                const escapedModuleName = moduleData.name.replace(/'/g, "\\'");
                inputtingWindowHtml = `<div class="inputting-window" style="margin-top: 10px; padding: 5px; background-color: #f0f8ff; border: 1px solid #add8e6; border-radius: 4px; font-size: 10px; max-width: 100%; cursor: pointer;" onclick="openInputSettingModal('${escapedModuleName}', this.closest('.module').dataset.moduleId)">
                    <span style="display: block; margin-bottom: 3px;">输入值:</span>
                    <div style="width: 100%; padding: 3px; border: 1px solid #ddd; border-radius: 2px; font-size: 10px; background-color: white;">
                        <span class="input-value">请输入固定值</span>
                    </div>
                </div>`;
            }
            
            return `
                ${settingBtnHtml}
                <div class="module-header">${moduleData.params.name || moduleData.name}</div>
                <div class="module-kind">${moduleData.params.kind || '未知'}</div>
                <div class="ports" style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div class="input-ports" style="flex: 1; margin-right: 10px;">${inputPortsHtml}</div>
                    <div style="width: 1px; background-color: #ddd; height: 100%; margin: 0 10px;"></div>
                    <div class="output-ports" style="flex: 1; margin-left: 10px;">${outputPortsHtml}</div>
                </div>
                ${showingWindowHtml}
                ${inputtingWindowHtml}
            `;
        }
        
        // 添加模块事件监听器
        function addModuleEventListeners(module) {
            // 添加拖拽功能
            makeDraggable(module);
            
            // 添加端口事件
            module.querySelectorAll('.port').forEach(port => {
                port.addEventListener('mousedown', handlePortMouseDown);
                port.addEventListener('click', handlePortClick);
                port.addEventListener('dblclick', handlePortDoubleClick);
            });
            
            // 添加设置按钮点击事件
            const settingBtn = module.querySelector('.setting-btn');
            if (settingBtn) {
                settingBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const moduleData = JSON.parse(settingBtn.dataset.module);
                    const moduleId = module.dataset.moduleId;
                    openSettingModal(moduleData, moduleId);
                });
            }
            
            // 添加显示框悬停事件
            const showingWindow = module.querySelector('.showing-window');
            if (showingWindow) {
                const contentSpan = showingWindow.querySelector('.window-content');
                const tooltip = showingWindow.querySelector('.tooltip');
                
                // 鼠标进入时显示完整内容
                contentSpan.addEventListener('mouseenter', function(e) {
                    // 根据模块类型获取实际内容
                    const currentModule = this.closest('.module');
                    const moduleId = parseInt(currentModule.dataset.moduleId);
                    const moduleState = moduleStates[moduleId];
                    
                    let fullContent = '';
                    if (moduleState) {
                        if (moduleState.moduleData.params.name === '缓存模块' || moduleState.moduleData.params.name === '显示模块') {
                                const displayContent = moduleState.displayContent !== undefined && moduleState.displayContent !== null ? moduleState.displayContent : '';
                                const prefix = moduleState.moduleData.params.name === '缓存模块' ? '缓存内容: ' : '显示内容: ';
                                fullContent = `${prefix}${displayContent}`;
                            } else {
                            // 对于其他模块，显示完整的默认内容
                            fullContent = contentSpan.textContent;
                        }
                    } else {
                        fullContent = contentSpan.textContent;
                    }
                    
                    // 创建一个新的tooltip元素，确保它能够正确显示
                    let tooltipElement = document.getElementById('custom-tooltip');
                    if (!tooltipElement) {
                        tooltipElement = document.createElement('div');
                        tooltipElement.id = 'custom-tooltip';
                        tooltipElement.style.cssText = `
                            display: none;
                            position: fixed;
                            background-color: #333;
                            color: white;
                            padding: 10px;
                            border-radius: 4px;
                            font-size: 12px;
                            z-index: 9999;
                            max-width: 800px;
                            max-height: 500px;
                            overflow: auto;
                            word-wrap: break-word;
                            pointer-events: none;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                        `;
                        document.body.appendChild(tooltipElement);
                    }
                    
                    tooltipElement.textContent = fullContent;
                    tooltipElement.style.display = 'block';
                    
                    // 定位tooltip到鼠标位置附近
                    tooltipElement.style.left = `${e.pageX + 10}px`;
                    tooltipElement.style.top = `${e.pageY + 10}px`;
                });
                
                // 鼠标移动时更新tooltip位置
                contentSpan.addEventListener('mousemove', function(e) {
                    const tooltipElement = document.getElementById('custom-tooltip');
                    if (tooltipElement && tooltipElement.style.display === 'block') {
                        tooltipElement.style.left = `${e.pageX + 10}px`;
                        tooltipElement.style.top = `${e.pageY + 10}px`;
                    }
                });
                
                // 鼠标离开时隐藏tooltip
                contentSpan.addEventListener('mouseleave', function() {
                    const tooltipElement = document.getElementById('custom-tooltip');
                    if (tooltipElement) {
                        tooltipElement.style.display = 'none';
                    }
                });
            }
        }
        
        // 创建连接
        function createConnection(startPort, endPort, isRed = false) {
            // 确保是从输出端口到输入端口的连接
            const isOutputPort = startPort.classList.contains('output-port');
            const isInputPort = endPort.classList.contains('input-port');
            
            if (isOutputPort && isInputPort) {
                // 计算端口位置
                const startPos = getPortPosition(startPort);
                const endPos = getPortPosition(endPort);
                
                // 创建连线元素
                const line = createConnectionLine(startPos.x, startPos.y, endPos.x, endPos.y, isRed);
                canvasContent.appendChild(line);
                
                // 保存连线信息
                connectionLines.push({
                    line: line,
                    startPort: startPort,
                    endPort: endPort,
                    isRed: isRed,
                    data: null, // 传输的数据
                    transferred: false, // 数据是否已传输
                    startModuleId: startPort.closest('.module').dataset.moduleId,
                    endModuleId: endPort.closest('.module').dataset.moduleId,
                    startPortIndex: parseInt(startPort.dataset.port.split('-')[1]),
                    endPortIndex: parseInt(endPort.dataset.port.split('-')[1])
                });
            }
        }
        
        // 加载项目按钮
            document.getElementById('load-project-btn').addEventListener('click', function() {
                // 创建文件选择输入
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.aiud,.txt';
                
                // 监听文件选择事件
                input.addEventListener('change', function(e) {
                    try {
                        const file = e.target.files[0];
                        if (!file) {
                            return;
                        }
                        
                        // 从文件名中提取项目名
                        const fileName = file.name;
                        const projectName = fileName.split('.').slice(0, -1).join('.');
                        document.getElementById('project-name').textContent = projectName;
                        
                        // 检查文件类型
                        if (file.name.endsWith('.aiud')) {
                            // 处理zip格式的.aiud文件
                            const zip = new JSZip();
                            zip.loadAsync(file).then(function(zip) {
                                // 读取project.json文件
                                return Promise.all([
                                    zip.file('project.json').async('string'),
                                    // 读取custom_modules文件夹中的文件
                                    Promise.resolve(zip.folder('custom_modules'))
                                ]);
                            }).then(function([projectJson, customModulesFolder]) {
                                try {
                                    const projectData = JSON.parse(projectJson);
                                    
                                    // 版本兼容处理
                                    const processedProjectData = processProjectData(projectData);
                                    
                                    // 处理自定义模块
                                    if (customModulesFolder) {
                                        // 收集自定义模块文件
                                        const promises = [];
                                        
                                        customModulesFolder.forEach(function(relativePath, file) {
                                            if (!file.dir) {
                                                // 读取模块文件内容
                                                const promise = file.async('string').then(function(content) {
                                                    try {
                                                        // 解析模块参数
                                                        const params = parseModuleParamsFromContent(content);
                                                        params.source = 'custom';
                                                        
                                                        // 从文件名中提取模块名
                                                        const moduleName = relativePath.split('/').pop().split('.').slice(0, -1).join('.');
                                                        
                                                        // 添加到模块库
                                                        modules[moduleName] = params;
                                                        console.log('添加自定义模块:', moduleName, params);
                                                    } catch (error) {
                                                        console.error('解析自定义模块失败:', relativePath, error);
                                                        showNotification(`解析自定义模块失败: ${relativePath}`);
                                                    }
                                                }).catch(function(error) {
                                                    console.error('读取自定义模块失败:', relativePath, error);
                                                    showNotification(`读取自定义模块失败: ${relativePath}`);
                                                });
                                                promises.push(promise);
                                            }
                                        });
                                        
                                        // 等待所有模块加载完成后重新渲染模块库
                                        return Promise.all(promises).then(function() {
                                            console.log('所有自定义模块加载完成，重新渲染模块库');
                                            renderModules();
                                            return processedProjectData;
                                        });
                                    } else {
                                        return processedProjectData;
                                    }
                                } catch (error) {
                                    console.error('解析项目文件失败:', error);
                                    showNotification(`解析项目文件失败: ${error.message}`);
                                    throw error;
                                }
                            }).then(function(projectData) {
                                // 清除当前画布上的所有模块和连接
                                document.querySelectorAll('.module').forEach(module => module.remove());
                                document.querySelectorAll('.connection-line').forEach(line => line.remove());
                                connectionLines = [];
                                
                                // 恢复画布大小
                                if (projectData.canvasSize) {
                                    canvasSize.width = projectData.canvasSize.width;
                                    canvasSize.height = projectData.canvasSize.height;
                                    canvasContent.style.width = `${canvasSize.width}px`;
                                    canvasContent.style.height = `${canvasSize.height}px`;
                                }
                                
                                // 重新创建模块
                                const moduleIdMap = {}; // 用于映射旧ID到新ID
                                projectData.modules.forEach(moduleInfo => {
                                    // 创建新的模块元素
                                    const module = document.createElement('div');
                                    module.className = 'module';
                                    module.style.left = moduleInfo.left;
                                    module.style.top = moduleInfo.top;
                                    
                                    // 生成新的模块ID
                                    const newModuleId = generateModuleId();
                                    module.dataset.moduleId = newModuleId;
                                    moduleIdMap[moduleInfo.id] = newModuleId;
                                    
                                    // 生成模块内容
                                    const moduleContent = generateModuleContent(moduleInfo.moduleData);
                                    module.innerHTML = moduleContent;
                                    
                                    // 添加到画布
                                    canvasContent.appendChild(module);
                                    
                                    // 添加事件监听器
                                    addModuleEventListeners(module);
                                    
                                    // 保存模块状态
                                    moduleStates[newModuleId] = {
                                        moduleData: moduleInfo.moduleData,
                                        inputValues: [],
                                        outputValues: [],
                                        executed: false,
                                        executing: false
                                    };
                                    
                                    // 恢复模块设置
                                    if (moduleInfo.settings) {
                                        const moduleKey = `module_settings_${newModuleId}_${moduleInfo.moduleData.params.name || 'default'}`;
                                        sessionStorage.setItem(moduleKey, JSON.stringify(moduleInfo.settings));
                                    }
                                    
                                    // 恢复输入值
                                    if (moduleInfo.inputValue !== undefined) {
                                        const inputElement = module.querySelector('.module-input');
                                        if (inputElement) {
                                            inputElement.value = moduleInfo.inputValue;
                                        } else {
                                            const inputValueElement = module.querySelector('.input-value');
                                            if (inputValueElement) {
                                                inputValueElement.textContent = moduleInfo.inputValue || '请输入固定值';
                                            }
                                        }
                                    }
                                });
                                
                                // 重新创建连接
                                projectData.connections.forEach(connInfo => {
                                    const startModuleId = moduleIdMap[connInfo.startModuleId];
                                    const endModuleId = moduleIdMap[connInfo.endModuleId];
                                    
                                    if (startModuleId && endModuleId) {
                                        const startModule = document.querySelector(`.module[data-module-id="${startModuleId}"]`);
                                        const endModule = document.querySelector(`.module[data-module-id="${endModuleId}"]`);
                                        
                                        if (startModule && endModule) {
                                            const startPort = startModule.querySelectorAll('.output-port')[connInfo.startPortIndex];
                                            const endPort = endModule.querySelectorAll('.input-port')[connInfo.endPortIndex];
                                            
                                            if (startPort && endPort) {
                                                // 创建连接
                                                createConnection(startPort, endPort, connInfo.isRed);
                                            }
                                        }
                                    }
                                });
                                
                                // 重新初始化画布，确保缩放和偏移量正确
                                initZoomControls();
                                
                                console.log('项目加载成功:', projectData);
                                alert('项目加载成功！');
                            }).catch(function(error) {
                                console.error('加载zip文件失败:', error);
                                alert('加载文件失败，请确保文件格式正确。');
                            });
                        } else {
                            // 处理.txt格式的文件
                            const reader = new FileReader();
                            
                            // 监听读取完成事件
                            reader.addEventListener('load', function(e) {
                                try {
                                    const text = e.target.result;
                                    const projectData = JSON.parse(text);
                                    
                                    // 版本兼容处理
                                    const processedProjectData = processProjectData(projectData);
                                    
                                    // 清除当前画布上的所有模块和连接
                                    document.querySelectorAll('.module').forEach(module => module.remove());
                                    document.querySelectorAll('.connection-line').forEach(line => line.remove());
                                    connectionLines = [];
                                    
                                    // 恢复画布大小
                                    if (processedProjectData.canvasSize) {
                                        canvasSize.width = processedProjectData.canvasSize.width;
                                        canvasSize.height = processedProjectData.canvasSize.height;
                                        canvasContent.style.width = `${canvasSize.width}px`;
                                        canvasContent.style.height = `${canvasSize.height}px`;
                                    }
                                    
                                    // 重新创建模块
                                    const moduleIdMap = {}; // 用于映射旧ID到新ID
                                    processedProjectData.modules.forEach(moduleInfo => {
                                        try {
                                            // 创建新的模块元素
                                            const module = document.createElement('div');
                                            module.className = 'module';
                                            module.style.left = moduleInfo.left || '0px';
                                            module.style.top = moduleInfo.top || '0px';
                                            
                                            // 生成新的模块ID
                                            const newModuleId = generateModuleId();
                                            module.dataset.moduleId = newModuleId;
                                            moduleIdMap[moduleInfo.id] = newModuleId;
                                            
                                            // 生成模块内容
                                            const moduleContent = generateModuleContent(moduleInfo.moduleData);
                                            module.innerHTML = moduleContent;
                                            
                                            // 添加到画布
                                            canvasContent.appendChild(module);
                                            
                                            // 添加事件监听器
                                            addModuleEventListeners(module);
                                            
                                            // 保存模块状态
                                            moduleStates[newModuleId] = {
                                                moduleData: moduleInfo.moduleData,
                                                inputValues: [],
                                                outputValues: [],
                                                displayContent: '',
                                                executed: false,
                                                executing: false
                                            };
                                            
                                            // 恢复模块设置
                                            if (moduleInfo.settings) {
                                                const moduleKey = `module_settings_${newModuleId}_${moduleInfo.moduleData.params.name || 'default'}`;
                                                sessionStorage.setItem(moduleKey, JSON.stringify(moduleInfo.settings));
                                            }
                                            
                                            // 恢复输入值
                                            if (moduleInfo.inputValue !== undefined) {
                                                const inputElement = module.querySelector('.module-input');
                                                if (inputElement) {
                                                    inputElement.value = moduleInfo.inputValue;
                                                } else {
                                                    const inputValueElement = module.querySelector('.input-value');
                                                    if (inputValueElement) {
                                                        inputValueElement.textContent = moduleInfo.inputValue || '请输入固定值';
                                                    }
                                                }
                                            }
                                        } catch (error) {
                                            console.error('创建模块失败:', moduleInfo, error);
                                            showNotification(`创建模块失败: ${moduleInfo.name || '未知模块'}`);
                                        }
                                    });
                                    
                                    // 重新创建连接
                                    processedProjectData.connections.forEach(connInfo => {
                                        try {
                                            const startModuleId = moduleIdMap[connInfo.startModuleId];
                                            const endModuleId = moduleIdMap[connInfo.endModuleId];
                                            
                                            if (startModuleId && endModuleId) {
                                                const startModule = document.querySelector(`.module[data-module-id="${startModuleId}"]`);
                                                const endModule = document.querySelector(`.module[data-module-id="${endModuleId}"]`);
                                                
                                                if (startModule && endModule) {
                                                    const startPort = startModule.querySelectorAll('.output-port')[connInfo.startPortIndex];
                                                    const endPort = endModule.querySelectorAll('.input-port')[connInfo.endPortIndex];
                                                    
                                                    if (startPort && endPort) {
                                                        // 创建连接
                                                        createConnection(startPort, endPort, connInfo.isRed);
                                                    }
                                                }
                                            }
                                        } catch (error) {
                                            console.error('创建连接失败:', connInfo, error);
                                        }
                                    });
                                    
                                    // 重新初始化画布，确保缩放和偏移量正确
                                    initZoomControls();
                                    
                                    console.log('项目加载成功:', processedProjectData);
                                    showNotification('项目加载成功！');
                                } catch (error) {
                                    console.error('解析文件失败:', error);
                                    showNotification(`解析文件失败: ${error.message}`);
                                }
                            });
                            
                            // 监听读取错误事件
                            reader.addEventListener('error', function() {
                                console.error('读取文件失败');
                                alert('读取文件失败，请重试。');
                            });
                            
                            // 开始读取文件
                            reader.readAsText(file);
                        }
                    } catch (error) {
                        console.error('加载项目失败:', error);
                        alert('加载项目失败，请检查控制台错误信息。');
                    }
                });
                
                // 触发文件选择对话框
                input.click();
            });
        }
        
        // 初始化折叠按钮
        function initCollapseButtons() {
            // 左侧模块库折叠按钮
            const moduleLibraryCollapse = document.getElementById('module-library-collapse');
            const moduleLibrary = document.querySelector('.module-library');
            
            moduleLibraryCollapse.addEventListener('click', function() {
                moduleLibrary.classList.toggle('collapsed');
                if (moduleLibrary.classList.contains('collapsed')) {
                    moduleLibraryCollapse.textContent = '→';
                } else {
                    moduleLibraryCollapse.textContent = '←';
                }
            });
            
            // 右侧对话面板折叠按钮
            const chatPanelCollapse = document.getElementById('chat-panel-collapse');
            const chatPanel = document.querySelector('.chat-panel');
            
            chatPanelCollapse.addEventListener('click', function() {
                chatPanel.classList.toggle('collapsed');
                if (chatPanel.classList.contains('collapsed')) {
                    chatPanelCollapse.textContent = '←';
                } else {
                    chatPanelCollapse.textContent = '→';
                }
            });
        }
        
        // 调整画布大小
        function resizeCanvas() {
            // 获取当前画布大小
            const currentWidth = canvasSize.width;
            const currentHeight = canvasSize.height;
            
            // 创建一个HTML弹窗来同时设置高度和宽度
            const modal = document.createElement('div');
            modal.className = 'setting-modal';
            modal.innerHTML = `
                <div class="setting-modal-content">
                    <h3>调整画布大小</h3>
                    <form class="setting-form">
                        <div class="setting-form-group">
                            <label for="canvas-width">画布宽度</label>
                            <input type="number" id="canvas-width" name="canvas-width" value="${currentWidth}" min="100" step="100">
                        </div>
                        <div class="setting-form-group">
                            <label for="canvas-height">画布高度</label>
                            <input type="number" id="canvas-height" name="canvas-height" value="${currentHeight}" min="100" step="100">
                        </div>
                    </form>
                    <div class="setting-modal-buttons">
                        <button class="cancel-btn">取消</button>
                        <button class="save-btn">保存</button>
                    </div>
                </div>
            `;
            
            // 添加到文档
            document.body.appendChild(modal);
            
            // 取消按钮事件
            modal.querySelector('.cancel-btn').addEventListener('click', function() {
                document.body.removeChild(modal);
            });
            
            // 保存按钮事件
            modal.querySelector('.save-btn').addEventListener('click', function() {
                const widthInput = modal.querySelector('#canvas-width').value;
                const heightInput = modal.querySelector('#canvas-height').value;
                
                // 验证输入
                const newWidth = parseInt(widthInput);
                const newHeight = parseInt(heightInput);
                
                if (!isNaN(newWidth) && !isNaN(newHeight) && newWidth > 0 && newHeight > 0) {
                    // 更新画布大小
                    canvasSize.width = newWidth;
                    canvasSize.height = newHeight;
                    
                    // 更新画布内容的大小
                    canvasContent.style.width = `${newWidth}px`;
                    canvasContent.style.height = `${newHeight}px`;
                    
                    // 重新初始化画布，确保缩放和偏移量正确
                    initZoomControls();
                    
                    console.log(`画布大小已调整为: ${newWidth}px × ${newHeight}px`);
                    document.body.removeChild(modal);
                } else {
                    alert('请输入有效的画布大小！');
                }
            });
            
            // 点击模态框背景关闭
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }
        
        // 初始化缩放控制和画布拖动
        function initZoomControls() {
            // 计算最小缩放倍率，使画布高度正好充满浏览器高度
            const calculateMinZoom = () => {
                const canvasHeight = canvasSize.height; // 画布实际高度
                const containerHeight = window.innerHeight - 60; // 浏览器窗口高度减去顶部面板高度
                const minZoom = Math.max(15, Math.round((containerHeight / canvasHeight) * 100));
                return minZoom;
            };
            
            // 局部变量，避免与全局变量冲突
            let minZoom = Math.max(20, calculateMinZoom()); // 最小缩放20%
            const maxZoom = 500; // 最大缩放500%
            const zoomLevelDisplay = document.querySelector('.zoom-level');
            let zoomLevel = minZoom;
            let lastMouseX = 0;
            let lastMouseY = 0;
            let canvasOffsetX = 0;
            let canvasOffsetY = 0;
            let canvasStartX = 0;
            let canvasStartY = 0;
            let canvasStartOffsetX = 0;
            let canvasStartOffsetY = 0;
            let isDraggingCanvas = false;
            
            // 初始化画布位置和缩放倍率
            const initializeCanvas = () => {
                // 设置缩放倍率为最小
                zoomLevel = minZoom;
                updateGlobalZoomLevel(zoomLevel);
                const scale = zoomLevel / 100;
                
                // 计算画布中心位置
                const canvasWidth = canvasSize.width;
                const canvasHeight = canvasSize.height;
                const containerWidth = canvas.clientWidth;
                const containerHeight = canvas.clientHeight;
                
                // 计算偏移量，使画布中心对齐容器中心
                canvasOffsetX = (containerWidth / 2 / scale) - (canvasWidth / 2);
                canvasOffsetY = (containerHeight / 2 / scale) - (canvasHeight / 2);
                
                // 应用变换
                canvasContent.style.transform = `translate(${canvasOffsetX}px, ${canvasOffsetY}px) scale(${scale})`;
                zoomLevelDisplay.textContent = zoomLevel + '%';
                
                // 调整背景网格大小
                updateGridSize(scale);
            };
            
            // 更新背景网格大小
            const updateGridSize = (scale) => {
                const smallGridSize = 20 * scale;
                const largeGridSize = 60 * scale;
                canvasContent.style.backgroundSize = `${smallGridSize}px ${smallGridSize}px, ${smallGridSize}px ${smallGridSize}px, ${largeGridSize}px ${largeGridSize}px, ${largeGridSize}px ${largeGridSize}px`;
            };
            
            // 监听鼠标移动，记录鼠标位置
            canvas.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                // 计算鼠标在画布中的位置（相对于画布的左上角）
                lastMouseX = e.clientX - rect.left;
                lastMouseY = e.clientY - rect.top;
            });
            
            // 画布拖动功能
            canvas.addEventListener('mousedown', function(e) {
                // 只有当点击的是画布背景且不是在端口或模块上时才开始拖动
                if (e.target === canvas || e.target === canvasContent) {
                    isDraggingCanvas = true;
                    canvasStartX = e.clientX;
                    canvasStartY = e.clientY;
                    canvasStartOffsetX = canvasOffsetX;
                    canvasStartOffsetY = canvasOffsetY;
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            // 处理画布拖动
            document.addEventListener('mousemove', function(e) {
                if (isDraggingCanvas) {
                    const scale = zoomLevel / 100;
                    // 计算新的偏移量，基于起始偏移量和鼠标移动距离
                    const deltaX = e.clientX - canvasStartX;
                    const deltaY = e.clientY - canvasStartY;
                    let newOffsetX = canvasStartOffsetX + deltaX / scale;
                    let newOffsetY = canvasStartOffsetY + deltaY / scale;
                    
                    // 限制画布移动，确保画布在画面中的占比不小于四分之一
                    const canvasWidth = canvasSize.width; // 画布实际宽度
                    const canvasHeight = canvasSize.height; // 画布实际高度
                    const containerWidth = canvas.clientWidth; // 容器宽度
                    const containerHeight = canvas.clientHeight; // 容器高度
                    
                    // 计算最小可见尺寸（四分之一画面）
                    const minVisibleWidth = containerWidth / 4;
                    const minVisibleHeight = containerHeight / 4;
                    
                    // 计算偏移量边界
                    // 左边界：画布右边缘至少要在容器左边缘右侧 minVisibleWidth 处
                    const maxOffsetX = (canvasWidth * scale - minVisibleWidth) / scale;
                    // 右边界：画布左边缘至少要在容器右边缘左侧 minVisibleWidth 处
                    const minOffsetX = -((containerWidth - minVisibleWidth) / scale);
                    
                    // 上边界：画布下边缘至少要在容器上边缘下方 minVisibleHeight 处
                    const maxOffsetY = (canvasHeight * scale - minVisibleHeight) / scale;
                    // 下边界：画布上边缘至少要在容器下边缘上方 minVisibleHeight 处
                    const minOffsetY = -((containerHeight - minVisibleHeight) / scale);
                    
                    // 应用边界限制
                    newOffsetX = Math.max(minOffsetX, Math.min(maxOffsetX, newOffsetX));
                    newOffsetY = Math.max(minOffsetY, Math.min(maxOffsetY, newOffsetY));
                    
                    // 更新偏移量
                    canvasOffsetX = newOffsetX;
                    canvasOffsetY = newOffsetY;
                    
                    // 应用变换 - 确保先平移后缩放
                    canvasContent.style.transform = `translate(${canvasOffsetX}px, ${canvasOffsetY}px) scale(${scale})`;
                    
                    // 调整背景网格大小
                    updateGridSize(scale);
                    
                    // 同步连线状态标记位置
                    syncAllRunStatusMarkers();
                }
            });
            
            // 结束画布拖动
            document.addEventListener('mouseup', function() {
                if (isDraggingCanvas) {
                    isDraggingCanvas = false;
                    canvas.style.cursor = 'grab';
                }
            });
            
            // 当鼠标离开窗口时结束拖动
            document.addEventListener('mouseleave', function() {
                if (isDraggingCanvas) {
                    isDraggingCanvas = false;
                    canvas.style.cursor = 'grab';
                }
            });
            
            // 窗口大小变化时重新计算最小缩放倍率
            window.addEventListener('resize', function() {
                const oldMinZoom = minZoom;
                minZoom = calculateMinZoom();
                
                // 如果当前缩放倍率小于新的最小缩放倍率，自动调整到新的最小倍率
                if (zoomLevel < minZoom) {
                    const oldScale = zoomLevel / 100;
                    zoomLevel = minZoom;
                    const newScale = zoomLevel / 100;
                    // 使用画布中心作为缩放中心，确保画布居中
                    const centerX = canvas.clientWidth / 2;
                    const centerY = canvas.clientHeight / 2;
                    updateZoom(centerX, centerY, oldScale, newScale);
                } else {
                    // 即使不需要调整缩放倍率，也需要重新计算偏移量以确保画布在窗口大小变化时保持居中
                    const scale = zoomLevel / 100;
                    const canvasWidth = canvasSize.width;
                    const canvasHeight = canvasSize.height;
                    const containerWidth = canvas.clientWidth;
                    const containerHeight = canvas.clientHeight;
                    
                    // 计算新的偏移量，使画布中心对齐容器中心
                    let newOffsetX = (containerWidth / 2 / scale) - (canvasWidth / 2);
                    let newOffsetY = (containerHeight / 2 / scale) - (canvasHeight / 2);
                    
                    // 限制画布移动，确保画布在画面中的占比不小于四分之一
                    // 计算最小可见尺寸（四分之一画面）
                    const minVisibleWidth = containerWidth / 4;
                    const minVisibleHeight = containerHeight / 4;
                    
                    // 计算偏移量边界
                    // 左边界：画布右边缘至少要在容器左边缘右侧 minVisibleWidth 处
                    const maxOffsetX = (canvasWidth * scale - minVisibleWidth) / scale;
                    // 右边界：画布左边缘至少要在容器右边缘左侧 minVisibleWidth 处
                    const minOffsetX = -((containerWidth - minVisibleWidth) / scale);
                    
                    // 上边界：画布下边缘至少要在容器上边缘下方 minVisibleHeight 处
                    const maxOffsetY = (canvasHeight * scale - minVisibleHeight) / scale;
                    // 下边界：画布上边缘至少要在容器下边缘上方 minVisibleHeight 处
                    const minOffsetY = -((containerHeight - minVisibleHeight) / scale);
                    
                    // 应用边界限制
                    newOffsetX = Math.max(minOffsetX, Math.min(maxOffsetX, newOffsetX));
                    newOffsetY = Math.max(minOffsetY, Math.min(maxOffsetY, newOffsetY));
                    
                    // 更新偏移量
                    canvasOffsetX = newOffsetX;
                    canvasOffsetY = newOffsetY;
                    
                    // 应用变换
                    canvasContent.style.transform = `translate(${canvasOffsetX}px, ${canvasOffsetY}px) scale(${scale})`;
                    
                    // 调整背景网格大小
                    updateGridSize(scale);
                }
            });
            
            // 放大按钮
            document.getElementById('zoom-in').addEventListener('click', function() {
                const oldScale = zoomLevel / 100;
                let newZoomLevel;
                
                // 如果当前缩放倍率不是整10倍，先调整到下一个整10倍
                if (zoomLevel % 10 !== 0) {
                    newZoomLevel = Math.ceil(zoomLevel / 10) * 10;
                } else {
                    // 否则，增加10%
                    newZoomLevel = zoomLevel + 10;
                }
                
                // 确保不超过最大缩放倍率
                newZoomLevel = Math.min(newZoomLevel, maxZoom);
                
                if (newZoomLevel > zoomLevel) {
                    zoomLevel = newZoomLevel;
                    const newScale = zoomLevel / 100;
                    updateZoom(lastMouseX, lastMouseY, oldScale, newScale);
                }
            });
            
            // 缩小按钮
            document.getElementById('zoom-out').addEventListener('click', function() {
                const oldScale = zoomLevel / 100;
                let newZoomLevel = zoomLevel - 10;
                
                // 接近最小倍率时，直接缩放到最小倍率
                if (newZoomLevel > minZoom && newZoomLevel - minZoom < 10) {
                    newZoomLevel = minZoom;
                } else {
                    // 确保不低于最小缩放倍率
                    newZoomLevel = Math.max(newZoomLevel, minZoom);
                }
                
                if (newZoomLevel < zoomLevel) {
                    zoomLevel = newZoomLevel;
                    const newScale = zoomLevel / 100;
                    updateZoom(lastMouseX, lastMouseY, oldScale, newScale);
                }
            });
            
            // 调整画布大小按钮
            const resizeCanvasBtn = document.getElementById('resize-canvas-btn');
            // 克隆按钮以移除旧的事件监听器
            const newResizeCanvasBtn = resizeCanvasBtn.cloneNode(true);
            resizeCanvasBtn.parentNode.replaceChild(newResizeCanvasBtn, resizeCanvasBtn);
            // 为新按钮添加事件监听器
            newResizeCanvasBtn.addEventListener('click', function() {
                resizeCanvas();
            });
            
            // 鼠标滚轮控制缩放
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                // 计算鼠标在画布中的位置（相对于画布的左上角）
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                let newZoomLevel;
                
                if (e.deltaY < 0) {
                    // 放大
                    if (zoomLevel % 10 !== 0) {
                        // 如果当前不是整10倍，调整到下一个整10倍
                        newZoomLevel = Math.ceil(zoomLevel / 10) * 10;
                    } else {
                        // 否则，增加10%
                        newZoomLevel = zoomLevel + 10;
                    }
                    // 确保不超过最大缩放倍率
                    newZoomLevel = Math.min(newZoomLevel, maxZoom);
                } else {
                    // 缩小
                    if (zoomLevel % 10 !== 0) {
                        // 如果当前不是整10倍，调整到上一个整10倍
                        newZoomLevel = Math.floor(zoomLevel / 10) * 10;
                    } else {
                        // 否则，减少10%
                        newZoomLevel = zoomLevel - 10;
                    }
                    
                    // 接近最小倍率时，直接缩放到最小倍率
                    if (newZoomLevel > minZoom && newZoomLevel - minZoom < 10) {
                        newZoomLevel = minZoom;
                    } else {
                        // 确保不低于最小缩放倍率
                        newZoomLevel = Math.max(newZoomLevel, minZoom);
                    }
                }
                
                if (newZoomLevel !== zoomLevel) {
                    const oldScale = zoomLevel / 100;
                    zoomLevel = newZoomLevel;
                    const newScale = zoomLevel / 100;
                    updateZoom(mouseX, mouseY, oldScale, newScale);
                }
            });
            
            // 更新缩放
            function updateZoom(mouseX, mouseY, oldScale, newScale) {
                zoomLevelDisplay.textContent = zoomLevel + '%';
                updateGlobalZoomLevel(zoomLevel);
                
                // 画布内容的实际大小
                const canvasWidth = canvasSize.width;
                const canvasHeight = canvasSize.height;
                
                // 计算画布在视口中的可见大小
                const canvasVisibleWidth = canvasWidth * newScale;
                const canvasVisibleHeight = canvasHeight * newScale;
                
                // 获取画布容器的大小
                const canvasContainerWidth = canvas.clientWidth;
                const canvasContainerHeight = canvas.clientHeight;
                
                // 判断是否需要以画布中心为缩放中心
                // 当画布可见大小小于容器大小时，或者缩放到最小倍率时，应该以画布中心为中心
                const shouldCenterCanvas = (canvasVisibleWidth <= canvasContainerWidth && canvasVisibleHeight <= canvasContainerHeight) || (zoomLevel === minZoom);
                
                let newOffsetX, newOffsetY;
                
                if (shouldCenterCanvas) {
                    // 以画布中心为缩放中心
                    // 计算画布中心在视口中的位置
                    const centerX = canvasContainerWidth / 2;
                    const centerY = canvasContainerHeight / 2;
                    
                    // 计算画布中心在内容中的位置
                    const contentCenterX = canvasWidth / 2;
                    const contentCenterY = canvasHeight / 2;
                    
                    // 计算新的偏移量
                    newOffsetX = (centerX / newScale) - contentCenterX;
                    newOffsetY = (centerY / newScale) - contentCenterY;
                } else {
                    // 以鼠标指针为缩放中心
                    // 计算鼠标在画布内容中的位置（相对于画布内容的左上角）
                    // 修复：正确计算鼠标在内容中的位置
                    const mouseInContentX = (mouseX / oldScale) - canvasOffsetX;
                    const mouseInContentY = (mouseY / oldScale) - canvasOffsetY;
                    
                    // 计算新的偏移量，使鼠标在画布内容中的位置保持不变
                    newOffsetX = (mouseX / newScale) - mouseInContentX;
                    newOffsetY = (mouseY / newScale) - mouseInContentY;
                }
                
                // 限制画布移动，确保画布在画面中的占比不小于四分之一
                const containerWidth = canvas.clientWidth; // 容器宽度
                const containerHeight = canvas.clientHeight; // 容器高度
                
                // 计算最小可见尺寸（四分之一画面）
                const minVisibleWidth = containerWidth / 4;
                const minVisibleHeight = containerHeight / 4;
                
                // 计算偏移量边界
                // 左边界：画布右边缘至少要在容器左边缘右侧 minVisibleWidth 处
                const maxOffsetX = (canvasWidth * newScale - minVisibleWidth) / newScale;
                // 右边界：画布左边缘至少要在容器右边缘左侧 minVisibleWidth 处
                const minOffsetX = -((containerWidth - minVisibleWidth) / newScale);
                
                // 上边界：画布下边缘至少要在容器上边缘下方 minVisibleHeight 处
                const maxOffsetY = (canvasHeight * newScale - minVisibleHeight) / newScale;
                // 下边界：画布上边缘至少要在容器下边缘上方 minVisibleHeight 处
                const minOffsetY = -((containerHeight - minVisibleHeight) / newScale);
                
                // 应用边界限制
                newOffsetX = Math.max(minOffsetX, Math.min(maxOffsetX, newOffsetX));
                newOffsetY = Math.max(minOffsetY, Math.min(maxOffsetY, newOffsetY));
                
                // 更新偏移量
                canvasOffsetX = newOffsetX;
                canvasOffsetY = newOffsetY;
                
                // 应用变换 - 确保先平移后缩放，避免漂移
                canvasContent.style.transform = `translate(${canvasOffsetX}px, ${canvasOffsetY}px) scale(${newScale})`;
                
                // 确保画布内容始终可见，添加最小尺寸限制
                canvasContent.style.minWidth = '1px';
                canvasContent.style.minHeight = '1px';
                
                // 调整背景网格大小
                updateGridSize(newScale);
            }
            
            // 获取当前缩放级别
            window.getCurrentZoomLevel = function() {
                return currentZoomLevel;
            };
            
            // 更新全局缩放级别
            function updateGlobalZoomLevel(level) {
                currentZoomLevel = level;
            }
            
            // 初始化画布
            initializeCanvas();
        }
        
        // 初始化模块拖拽删除功能
        function initModuleDragDelete() {
            const moduleLibrary = document.querySelector('.module-library');
            
            // 为模块库添加拖放事件
            moduleLibrary.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                moduleLibrary.style.backgroundColor = '#e3f2fd';
            }, true);
            
            moduleLibrary.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                moduleLibrary.style.backgroundColor = '#f5f5f5';
            }, true);
            
            moduleLibrary.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                moduleLibrary.style.backgroundColor = '#f5f5f5';
                
                console.log('模块库drop事件触发');
                
                // 获取被拖拽的模块
                const draggedModule = document.querySelector('.module.dragging');
                console.log('找到被拖拽的模块:', draggedModule);
                
                if (draggedModule) {
                    console.log('准备删除模块:', draggedModule);
                    // 删除与该模块相关的所有连线
                    connectionLines = connectionLines.filter(connection => {
                        const isRelated = connection.startPort.closest('.module') === draggedModule || 
                                        connection.endPort.closest('.module') === draggedModule;
                        if (isRelated) {
                            connection.line.remove();
                        }
                        return !isRelated;
                    });
                    
                    // 删除模块
                    draggedModule.remove();
                    console.log('模块删除成功');
                }
            }, true);
            
            // 为所有模块库子元素添加阻止默认行为的监听器
            const moduleLibraryChildren = moduleLibrary.querySelectorAll('*');
            moduleLibraryChildren.forEach(child => {
                child.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                }, true);
                child.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                }, true);
            });
        }
        
        // 打开设置窗口
        function openInputSettingModal(moduleName, moduleId) {
            // 创建设置窗口
            const modal = document.createElement('div');
            modal.className = 'setting-modal';
            
            // 获取当前输入值
            const moduleElement = document.querySelector(`.module[data-module-id="${moduleId}"]`);
            const inputValueElement = moduleElement ? moduleElement.querySelector('.input-value') : null;
            let currentValue = inputValueElement ? inputValueElement.textContent : '请输入固定值';
            if (currentValue === '请输入固定值') {
                currentValue = '';
            }
            
            // 生成设置表单
            const formHtml = `
                <div class="setting-form-group">
                    <label for="input-value">输入值</label>
                    <textarea id="input-value" name="input-value" placeholder="请输入固定值" style="width: 100%; height: 200px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; resize: none; overflow: auto;">${currentValue}</textarea>
                </div>
            `;
            
            // 设置窗口内容
            modal.innerHTML = `
                <div class="setting-modal-content" style="width: 600px; max-width: 80%;">
                    <h3>输入值设置</h3>
                    <form class="setting-form">
                        ${formHtml}
                    </form>
                    <div class="setting-modal-buttons">
                        <button class="cancel-btn">取消</button>
                        <button class="save-btn">保存</button>
                    </div>
                </div>
            `;
            
            // 添加到文档
            document.body.appendChild(modal);
            
            // 保存按钮点击事件
            const saveBtn = modal.querySelector('.save-btn');
            saveBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                // 获取输入值
                const inputValue = modal.querySelector('#input-value').value;
                
                // 更新模块显示
                if (inputValueElement) {
                    inputValueElement.textContent = inputValue || '请输入固定值';
                }
                
                // 保存到模块状态
                const moduleState = moduleStates[moduleId];
                if (moduleState) {
                    // 这里可以根据需要保存输入值到模块状态
                }
                
                // 关闭窗口
                modal.remove();
            });
            
            // 取消按钮点击事件
            const cancelBtn = modal.querySelector('.cancel-btn');
            cancelBtn.addEventListener('click', function(e) {
                e.preventDefault();
                modal.remove();
            });
        }
        
        function openSettingModal(moduleData, moduleId) {
            // 创建设置窗口
            const modal = document.createElement('div');
            modal.className = 'setting-modal';
            
            // 获取变量名
            const variableNames = moduleData.params.variables_name ? moduleData.params.variables_name.split(',') : [];
            const variableQuantity = moduleData.params.variable_quantity || 0;
            
            // 生成设置表单
            let formHtml = '';
            
            // 检查是否为调用模块
            if (moduleData.params.kind === '调用模块') {
                // 调用模块特殊设置
                formHtml += `
                    <h4>模型选择</h4>
                    <div class="setting-form-group">
                        <label for="model_source">模型调用方式</label>
                        <select id="model_source" name="model_source" onchange="toggleModelSettings(this.value)">
                            <option value="ChatAPI">ChatAPI</option>
                            <option value="ChatGLM">ChatGLM</option>
                            <option value="aliyun">阿里云</option>
                            <option value="baidu">百度云</option>
                            <option value="lmstudio" selected>本地 LM Studio</option>
                        </select>
                    </div>
                    
                    <!-- API设置 -->
                    <div id="api_settings" class="model-settings">
                        <div class="setting-form-group">
                            <label for="api_key">API密钥</label>
                            <input type="password" id="api_key" name="api_key" placeholder="请输入API密钥">
                        </div>
                    </div>
                    
                    <!-- LM Studio设置 -->
                    <div id="lmstudio_settings" class="model-settings" style="display: none;">
                        <div class="setting-form-group">
                            <label for="lmstudio_host">主机地址</label>
                            <input type="text" id="lmstudio_host" name="lmstudio_host" value="http://localhost:1234" placeholder="请输入主机地址">
                        </div>
                        <div class="setting-form-group">
                            <label for="lmstudio_model">模型选择</label>
                            <select id="lmstudio_model" name="lmstudio_model">
                                <option value="">加载中...</option>
                            </select>
                            <button type="button" id="refresh_models" onclick="refreshLMStudioModels()">刷新模型列表</button>
                            <div id="model_status" style="font-size: 12px; color: gray; margin-top: 5px;">状态: 就绪</div>
                        </div>
                        
                        <!-- 生成参数设置 -->
                        <h4>生成参数设置</h4>
                        <div class="setting-form-group">
                            <label for="temperature">温度 (temperature)</label>
                            <input type="number" id="temperature" name="temperature" value="0.7" min="0" max="2" step="0.1" placeholder="0.7">
                        </div>
                        <div class="setting-form-group">
                            <label for="top_p">核采样 (top_p)</label>
                            <input type="number" id="top_p" name="top_p" value="0.9" min="0" max="1" step="0.05" placeholder="0.9">
                        </div>
                        <div class="setting-form-group">
                            <label for="top_k">Top-K</label>
                            <input type="number" id="top_k" name="top_k" value="40" min="0" step="1" placeholder="40">
                        </div>
                        <div class="setting-form-group">
                            <label for="repetition_penalty">重复惩罚 (repetition_penalty)</label>
                            <input type="number" id="repetition_penalty" name="repetition_penalty" value="1.0" min="0.5" max="2" step="0.1" placeholder="1.0">
                        </div>
                        <div class="setting-form-group">
                            <label for="presence_penalty">存在惩罚 (presence_penalty)</label>
                            <input type="number" id="presence_penalty" name="presence_penalty" value="0.0" min="-2" max="2" step="0.1" placeholder="0.0">
                        </div>
                        <div class="setting-form-group">
                            <label for="frequency_penalty">频率惩罚 (frequency_penalty)</label>
                            <input type="number" id="frequency_penalty" name="frequency_penalty" value="0.0" min="-2" max="2" step="0.1" placeholder="0.0">
                        </div>
                        <div class="setting-form-group">
                            <label for="max_tokens">最大生成长度 (max_tokens)</label>
                            <input type="number" id="max_tokens" name="max_tokens" value="1000" min="1" step="100" placeholder="1000">
                        </div>
                        <div class="setting-form-group">
                            <label for="stop_words">停止词 (stop_words)</label>
                            <input type="text" id="stop_words" name="stop_words" placeholder="用逗号分隔，如: 你好,再见">
                        </div>
                        <div class="setting-form-group">
                            <label for="seed">随机种子 (seed)</label>
                            <input type="number" id="seed" name="seed" value="0" min="0" step="1" placeholder="0 (随机)">
                        </div>
                    </div>
                    
                    <h4>默认值设置</h4>
                `;
            }
            
            // 生成通用变量设置
                for (let i = 0; i < variableQuantity; i++) {
                    const variableName = variableNames[i] || `变量${i+1}`;
                    // 在LM Studio模式下，隐藏下方的"模型选择"输入框
                    const isModelSelection = variableName === '模型选择';
                    const hiddenClass = isModelSelection ? ' lmstudio-hidden' : '';
                    formHtml += `
                    <div class="setting-form-group${hiddenClass}">
                        <label for="var-${i}">${variableName}</label>
                        <input type="text" id="var-${i}" name="${variableName}" placeholder="请输入默认值">
                    </div>
                `;
                }
            
            // 设置窗口内容
            modal.innerHTML = `
                <div class="setting-modal-content">
                    <h3>${moduleData.params.name || '模块'} 设置</h3>
                    <form class="setting-form">
                        ${formHtml}
                    </form>
                    <div class="setting-modal-buttons">
                        <button class="cancel-btn">取消</button>
                        <button class="save-btn">保存</button>
                    </div>
                </div>
            `;
            
            // 从会话存储中读取之前保存的设置
            const moduleKey = `module_settings_${moduleId}_${moduleData.params.name || 'default'}`;
            const savedSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
            
            // 添加到文档
            document.body.appendChild(modal);
            
            // 填充之前保存的设置
            if (Object.keys(savedSettings).length > 0) {
                console.log('加载之前保存的设置:', savedSettings);
                
                // 填充模型调用方式
                const modelSourceSelect = modal.querySelector('#model_source');
                if (modelSourceSelect && savedSettings.model_source) {
                    modelSourceSelect.value = savedSettings.model_source;
                }
                
                // 填充API密钥
                const apiKeyInput = modal.querySelector('#api_key');
                if (apiKeyInput && savedSettings.api_key) {
                    apiKeyInput.value = savedSettings.api_key;
                }
                
                // 填充LM Studio设置
                const lmstudioHostInput = modal.querySelector('#lmstudio_host');
                if (lmstudioHostInput && savedSettings.lmstudio_host) {
                    lmstudioHostInput.value = savedSettings.lmstudio_host;
                }
                
                const lmstudioModelSelect = modal.querySelector('#lmstudio_model');
                if (lmstudioModelSelect && savedSettings.lmstudio_model) {
                    // 确保模型列表已加载，然后设置选中值
                    setTimeout(() => {
                        const option = Array.from(lmstudioModelSelect.options).find(opt => opt.value === savedSettings.lmstudio_model);
                        if (option) {
                            option.selected = true;
                        }
                    }, 100);
                }
                
                // 填充生成参数设置
                const temperatureInput = modal.querySelector('#temperature');
                if (temperatureInput && savedSettings.temperature !== undefined) {
                    temperatureInput.value = savedSettings.temperature;
                }
                
                const topPInput = modal.querySelector('#top_p');
                if (topPInput && savedSettings.top_p !== undefined) {
                    topPInput.value = savedSettings.top_p;
                }
                
                const topKInput = modal.querySelector('#top_k');
                if (topKInput && savedSettings.top_k !== undefined) {
                    topKInput.value = savedSettings.top_k;
                }
                
                const repetitionPenaltyInput = modal.querySelector('#repetition_penalty');
                if (repetitionPenaltyInput && savedSettings.repetition_penalty !== undefined) {
                    repetitionPenaltyInput.value = savedSettings.repetition_penalty;
                }
                
                const presencePenaltyInput = modal.querySelector('#presence_penalty');
                if (presencePenaltyInput && savedSettings.presence_penalty !== undefined) {
                    presencePenaltyInput.value = savedSettings.presence_penalty;
                }
                
                const frequencyPenaltyInput = modal.querySelector('#frequency_penalty');
                if (frequencyPenaltyInput && savedSettings.frequency_penalty !== undefined) {
                    frequencyPenaltyInput.value = savedSettings.frequency_penalty;
                }
                
                const maxTokensInput = modal.querySelector('#max_tokens');
                if (maxTokensInput && savedSettings.max_tokens !== undefined) {
                    maxTokensInput.value = savedSettings.max_tokens;
                }
                
                const stopWordsInput = modal.querySelector('#stop_words');
                if (stopWordsInput && savedSettings.stop_words !== undefined) {
                    stopWordsInput.value = savedSettings.stop_words;
                }
                
                const seedInput = modal.querySelector('#seed');
                if (seedInput && savedSettings.seed !== undefined) {
                    seedInput.value = savedSettings.seed;
                }
                
                // 填充通用变量设置
                const variableNames = moduleData.params.variables_name ? moduleData.params.variables_name.split(',') : [];
                for (let i = 0; i < variableNames.length; i++) {
                    const variableName = variableNames[i];
                    if (savedSettings[variableName] !== undefined && savedSettings[variableName] !== null) {
                        const input = modal.querySelector(`input[name="${variableName}"]`);
                        if (input) {
                            input.value = savedSettings[variableName];
                        }
                    }
                }
            }
            
            // 添加切换模型设置的函数
            window.toggleModelSettings = function(value) {
                const apiSettings = modal.querySelector('#api_settings');
                const lmstudioSettings = modal.querySelector('#lmstudio_settings');
                const modelSelectionInputs = modal.querySelectorAll('.lmstudio-hidden');
                
                if (value === 'lmstudio') {
                    apiSettings.style.display = 'none';
                    lmstudioSettings.style.display = 'block';
                    // 隐藏默认值设置中的模型选择输入框
                    modelSelectionInputs.forEach(input => {
                        input.style.display = 'none';
                    });
                    // 加载LM Studio模型列表
                    refreshLMStudioModels();
                } else {
                    apiSettings.style.display = 'block';
                    lmstudioSettings.style.display = 'none';
                    // 对于阿里云和百度云，也隐藏默认值设置中的模型选择输入框
                    if (value === 'aliyun' || value === 'baidu') {
                        modelSelectionInputs.forEach(input => {
                            input.style.display = 'none';
                        });
                    } else {
                        // 对于其他API模式，显示默认值设置中的模型选择输入框
                        modelSelectionInputs.forEach(input => {
                            input.style.display = 'block';
                        });
                    }
                }
            };
            
            // 从LM Studio获取模型列表
            window.refreshLMStudioModels = async function() {
                const hostInput = modal.querySelector('#lmstudio_host');
                const modelSelect = modal.querySelector('#lmstudio_model');
                const refreshBtn = modal.querySelector('#refresh_models');
                const statusDiv = modal.querySelector('#model_status');
                
                if (!hostInput || !modelSelect || !refreshBtn || !statusDiv) return;
                
                const host = hostInput.value || 'http://localhost:1234';
                
                try {
                    refreshBtn.textContent = '加载中...';
                    modelSelect.innerHTML = '<option value="">加载中...</option>';
                    statusDiv.textContent = '状态: 正在获取模型列表...';
                    statusDiv.style.color = 'blue';
                    
                    // 通过后端API获取LM Studio模型列表，避免CORS错误
                    statusDiv.textContent = '状态: 通过后端API获取模型列表...';
                    
                    // 调用后端API
                    const response = await fetch(`/api/get_lmstudio_models?host=${encodeURIComponent(host)}`);
                    
                    if (!response.ok) {
                        throw new Error(`后端API错误! 状态: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    const models = data.models || [];
                    
                    statusDiv.textContent = '状态: 解析响应...';
                    
                    // 填充模型列表
                    let optionsHtml = '';
                    models.forEach(modelId => {
                        optionsHtml += `<option value="${modelId}">${modelId}</option>`;
                    });
                    
                    // 如果没有获取到模型，使用通用的模型名称作为备份
                    if (!optionsHtml) {
                        const backupModels = [
                            "abliterated",
                            "text-embedding-nomic-embed-text-v1.5"
                        ];
                        
                        backupModels.forEach(modelId => {
                            optionsHtml += `<option value="${modelId}">${modelId}</option>`;
                        });
                    }
                    
                    modelSelect.innerHTML = optionsHtml || '<option value="">未找到有效模型</option>';
                    statusDiv.textContent = `状态: 成功获取 ${models.length || 2} 个模型`;
                    statusDiv.style.color = 'green';
                    
                    console.log('通过后端API获取的LM Studio模型列表:', models.length > 0 ? models : '使用通用备份模型列表');
                    
                } catch (error) {
                    console.error('获取模型列表失败:', error);
                    
                    // 出错时使用通用的模型名称作为备份
                    const backupModels = [
                        "abliterated",
                        "text-embedding-nomic-embed-text-v1.5"
                    ];
                    
                    let optionsHtml = '';
                    backupModels.forEach(modelId => {
                        optionsHtml += `<option value="${modelId}">${modelId}</option>`;
                    });
                    
                    modelSelect.innerHTML = optionsHtml || '<option value="">未找到有效模型</option>';
                    statusDiv.textContent = `状态: 获取失败，使用通用备份模型列表 - ${error.message}`;
                    statusDiv.style.color = 'orange';
                } finally {
                    refreshBtn.textContent = '刷新模型列表';
                }
            };
            
            // 初始化模型设置显示
            const modelSourceSelect = modal.querySelector('#model_source');
            if (modelSourceSelect) {
                window.toggleModelSettings(modelSourceSelect.value);
            }
            
            // 取消按钮事件
            modal.querySelector('.cancel-btn').addEventListener('click', function() {
                document.body.removeChild(modal);
            });
            
            // 保存按钮事件
            modal.querySelector('.save-btn').addEventListener('click', function() {
                const form = modal.querySelector('.setting-form');
                const formData = new FormData(form);
                const settings = {};
                
                // 收集通用变量设置
                for (let i = 0; i < variableQuantity; i++) {
                    const variableName = variableNames[i] || `变量${i+1}`;
                    settings[variableName] = formData.get(variableName) || '';
                }
                
                // 收集调用模块特殊设置
                if (moduleData.params.kind === '调用模块') {
                    settings.model_source = formData.get('model_source') || 'ChatAPI';
                    settings.api_key = formData.get('api_key') || '';
                    settings.lmstudio_host = formData.get('lmstudio_host') || 'http://localhost:1234';
                    settings.lmstudio_model = formData.get('lmstudio_model') || '';
                    
                    // 收集生成参数设置
                    settings.temperature = parseFloat(formData.get('temperature') || '0.7');
                    settings.top_p = parseFloat(formData.get('top_p') || '0.9');
                    settings.top_k = parseInt(formData.get('top_k') || '40');
                    settings.repetition_penalty = parseFloat(formData.get('repetition_penalty') || '1.0');
                    settings.presence_penalty = parseFloat(formData.get('presence_penalty') || '0.0');
                    settings.frequency_penalty = parseFloat(formData.get('frequency_penalty') || '0.0');
                    settings.max_tokens = parseInt(formData.get('max_tokens') || '1000');
                    settings.stop_words = formData.get('stop_words') || '';
                    settings.seed = parseInt(formData.get('seed') || '0');
                }
                
                // 保存设置到会话存储
                const moduleKey = `module_settings_${moduleId}_${moduleData.params.name || 'default'}`;
                sessionStorage.setItem(moduleKey, JSON.stringify(settings));
                
                // 这里可以添加保存默认值的逻辑
                console.log('保存设置:', settings);
                console.log('设置已保存到会话存储，键名:', moduleKey);
                console.log('设置将在当前会话中保持，关闭浏览器后会被清除');
                
                // 关闭窗口
                document.body.removeChild(modal);
                
                // 显示保存成功的提示
                alert('设置已保存');
                
                // 刷新当前模块的设置（如果需要）
                console.log('设置保存完成，可以在模块执行时使用这些设置');
            });
            
            // 点击模态框背景关闭
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }
    </script>
</body>
</html>
# 简单图形化AI调用工具说明文档

## 目录
1. [项目概述](#1-项目概述)
2. [快速开始](#2-快速开始)
3. [系统架构](#3-系统架构)
4. [项目文件格式](#4-项目文件格式)
5. [模块运行与加载规则](#5-模块运行与加载规则)
6. [功能说明](#6-功能说明)
7. [内置模块说明](#7-内置模块说明)
8. [模块开发指南](#8-模块开发指南)
9. [GUI 配置与使用](#9-gui-配置与使用)
10. [常见工作流示例](#10-常见工作流示例)
11. [最佳实践](#11-最佳实践)
12. [故障排除](#12-故障排除)

---

## 1. 项目概述

### 1.1 项目简介
简单图形化AI调用工具是一个基于 Python + Flask + CustomTkinter 的图形化 AI 模型调用和流程编排工具。通过拖拽式模块配置、连线式流程定义，让 AI 应用开发更简单！

### 1.2 核心功能
- 🎨 **拖拽式模块配置** - 通过拖拽方式设置模块，每个模块有输入输出接口
- 🔗 **连线式流程定义** - 通过连线设定运行顺序、测试和数据流向
- 📝 **一键代码转换** - 将图形化编程结果一键转换为 Python 代码（基于 Python AST 的代码生成器）
  - 支持 `.aiud` 和 `.json` 格式的工作流文件
  - 插件化架构，代码生成功能独立封装在 `plugin/json2py.py` 中
  - 语法保证：使用 Python AST 生成的代码一定是语法正确的
- 🧩 **自定义模块支持** - 支持自定义模块并配有图形化的编程工具
- 📊 **运行状态可视化** - 连线上自动标出运行步骤，黄色圆圈显示当前运行状态
- 🎯 **多种模块类型** - 输入模块、调用模块、处理模块、输出模块等
- ⚡ **步进/连续运行** - 支持步进运行和连续运行两种模式
- 🔴⚫ **连线颜色切换** - 用户可通过双击连线切换红黑色
- 💾 **项目保存/加载** - 支持保存和加载 `.aiud` 格式的项目文件
- 🖼️ **AI 绘图支持** - 内置 Stable Diffusion 相关模块，支持文生图、图生图、遮罩重绘等
- 🖥️ **多引擎支持** - 支持 NVIDIA CUDA、AMD DML、ZLUDA、CPU 等多种计算引擎
- 📦 **虚拟环境管理** - 内置一键安装功能，支持 CUDA 和 DML 虚拟环境的自动化配置
- 🎛️ **GUI 配置面板** - 提供友好的 CustomTkinter 界面，用于配置和监控
- 🔌 **插件化架构** - 代码生成功能独立封装，方便维护和扩展

### 1.3 技术栈
- **后端**: Python + Flask
- **前端**: HTML/JavaScript
- **GUI**: CustomTkinter
- **AI**: PyTorch + Diffusers + Transformers

---

## 2. 快速开始

### 2.1 环境要求
- Python 3.8+
- Windows 系统（推荐）

### 2.2 安装方式

#### 方式一：GUI 一键安装（推荐）
1. 克隆或下载本项目到本地

2. 运行 GUI 配置工具：
```bash
python app.py
```

3. 在 GUI 的「高级设置」中点击「一键安装」，根据你的显卡类型选择：
   - **仅安装 CUDA** - 如果你有 NVIDIA 显卡
   - **仅安装 DML** - 如果你有 AMD/Intel 显卡
   - **全部安装** - 安装两种环境

4. 点击「一键启动」按钮，浏览器会自动打开

#### 方式二：使用 install_basic.bat（Windows）
1. 双击 `install_basic.bat` 一键安装基础依赖

2. 运行 `python app.py` 启动 GUI

3. 在 GUI 的「高级设置」中点击「一键安装」安装 AI 绘图依赖

#### 方式三：手动安装
1. 克隆或下载本项目到本地

2. 安装基础依赖：
```bash
pip install flask customtkinter pillow numpy requests
```

3. （可选）安装 AI 绘图依赖：

对于 **NVIDIA 显卡**（CUDA）：
```bash
pip install torch torchvision torchaudio --index-url https://download.pytorch.org/whl/cu121
pip install safetensors transformers accelerate diffusers
```

对于 **AMD/Intel 显卡**（DML）：
```bash
pip install torch==2.0.1 torchvision==0.15.2 torchaudio==2.0.2 --index-url https://download.pytorch.org/whl/cpu
pip install torch-directml
pip install safetensors transformers accelerate diffusers
```

4. 运行应用：
```bash
python app.py
```

5. 在浏览器中访问：`http://localhost:5000`

### 2.3 启动方式
- **GUI 启动**：运行 `python app.py`，通过 GUI 面板控制（推荐）
- **直接启动 Flask**：运行 `python app.py run`，不启动 GUI
- **Windows 快捷启动**：双击 `start_app.vbs`

### 2.4 项目结构
```
.
├── app.py                      # 主应用文件（含 GUI + Flask）
├── templates/
│   └── main.html              # 前端页面
├── plugin/                    # 插件文件夹
│   └── json2py.py             # 代码生成插件（基于 Python AST）
├── default_modules/           # 内置默认模块
│   ├── Checkpoint加载器.py
│   ├── K采样器模块.py
│   ├── VAE解码模块.py
│   ├── CLIP文本编码模块.py
│   ├── 空Latent张量生成模块.py
│   ├── 加载图像模块.py
│   ├── 图片保存_显示模块.py
│   ├── 调用模块.py
│   ├── 对话输出.py
│   ├── 显示模块.py
│   ├── 判断.py
│   ├── 比大小.py
│   ├── 缓存模块.py
│   ├── user输入.py
│   └── ... (更多内置模块)
├── custom_modules/            # 用户自定义模块
├── auto_save/                 # 自动保存目录
│   ├── cache/                 # 界面缓存
│   └── *.aiud                # 项目配置文件
├── models/                    # 模型文件夹
│   ├── checkpoints/          # SD Checkpoint 模型
│   └── vae/                  # VAE 模型
├── output/                    # 生成的图像输出目录
├── venv_cuda/                # CUDA 虚拟环境（可选）
├── venv_dml/                 # DML 虚拟环境（可选）
├── gui_settings.json          # GUI 设置文件
├── requirements.txt           # 依赖列表
├── install_basic.bat         # Windows 一键安装基础依赖
├── start_app.vbs             # Windows 快捷启动脚本
└── 说明文档.md                # 本文档
```

---

## 3. 系统架构

### 3.1 界面布局

根据示意图，系统界面布局如下：

1. **左侧模块库**：
   - 输入模块
   - 调用模块
   - 处理模块
   - 输出模块
   - 自定义模块（可扩展）

2. **中央画布**：
   - 用于拖拽放置模块
   - 用于绘制模块间的连接线
   - 显示运行状态和流程

3. **右侧对话面板**：
   - 对话功能：提供给用户一个使用自己设计的调用方式的地方
   - 对话双方：用户和AI
   - 数据流向：用户输入将作为输入模块（user输入）的数据输出，AI的回答来自"对话输出"模块
   - 上下文说明：这里看到的上下文是展示使用，LLM实际使用的上下文看的是调用模块

4. **顶部控制面板**：
   - 运行控制：开始、暂停、停止
   - 代码生成：一键转换为Python代码
   - 项目管理：新建、保存、加载

### 3.2 模块类型

1. **输入模块**：负责数据输入，支持固定输入和外部输入
2. **处理模块**：负责数据处理、转换和条件判断
   - 包含判断功能：负责条件判断和分支控制
3. **调用模块**：负责调用AI模型或其他外部服务
4. **输出模块**：负责结果输出和展示

---

## 4. 项目文件格式

### 4.1 保存

#### 4.1.1 文件基础说明
项目文件采用 `.aiud` 扩展名，使用 zip 压缩格式，包含以下内容：
- `project.json`：项目配置文件，包含模块信息、连接信息、画布大小等数据
- `custom_modules` 文件夹：包含项目中使用的自定义模块文件

#### 4.1.2 文件结构
```
.aiud文件 (zip压缩)
├── project.json
└── custom_modules/
    └── 自定义模块.py
```

#### 4.1.3 project.json 结构
```json
{
  "version": "0.1",
  "modules": [
    {
      "id": "模块ID",
      "name": "模块名称",
      "kind": "模块类型",
      "left": "X坐标",
      "top": "Y坐标",
      "moduleData": {
        "name": "模块名称",
        "params": {
          "name": "模块名称",
          "kind": "模块类型",
          "input_quantity": 输入端口数量,
          "output_quantity": 输出端口数量,
          "variables_name": "变量名称",
          "output_name": "输出端口名称"
        }
      },
      "settings": {
        "变量名": "默认值"
      }
    }
  ],
  "connections": [
    {
      "startModuleId": "起始模块ID",
      "startPortIndex": 起始端口索引,
      "endModuleId": "结束模块ID",
      "endPortIndex": 结束端口索引,
      "isRed": 是否为红线
    }
  ],
  "canvasSize": {
    "width": 画布宽度,
    "height": 画布高度
  },
  "timestamp": "保存时间戳",
  "usedCustomModules": ["使用的自定义模块名称列表"]
}
```

#### 4.1.4 字段说明
- **version**：项目文件版本号，用于版本兼容处理
- **modules**：包含所有模块的信息，每个模块包括ID、名称、类型、坐标、模块数据和设置等。
- **connections**：包含所有连接的信息，每个连接包括起始模块ID、起始端口索引、结束模块ID、结束端口索引和是否为红线等。
- **canvasSize**：包含画布大小信息，包括宽度和高度。
- **timestamp**：保存时间戳，格式为ISO格式。
- **usedCustomModules**：包含项目中使用的自定义模块名称列表。

#### 4.1.5 版本兼容处理
- 系统会自动处理不同版本的项目文件
- 对于缺失字段，会使用默认值进行填充
- 支持从旧版本项目文件平滑升级到新版本

---

## 5. 模块运行与加载规则

### 5.1 默认加载规则
在 app.py 运行时，会自动导入「默认模块文件夹」和「自定义模块文件夹」内的所有模块。

### 5.2 动态更新规则
当用户点击左侧模块库中自定义模块后方的刷新键后，系统会触发刷新，重新加载「自定义模块文件夹」中的所有模块。

### 5.3 导入项目规则
导入项目时，会自动加载项目文件携带的自定义模块，并将这些模块添加到左侧模块库的自定义模块分类中。
- 自定义模块冲突处理：当导入的模块与本地已有同名模块时，系统会：
  1. 采用默认模块优先于自定义模块的原则
  2. 保留从.aiud文件中加载的自定义模块（如果默认模块中不存在）
  3. 确保模块加载的一致性和可靠性

### 5.4 模块删除规则
删除模块时，会直接从模块状态中移除对应的模块ID，并删除与该模块相关的所有连线。

### 5.5 编码细节

协议规定：代码的第 1 个模块编号为 0（00000000），模块编号为递增的唯一标识符，删除模块时不会重新编号或前移后续模块编号。

模块ID管理：
- 系统会自动生成唯一的模块ID，避免重复
- 当模块ID达到最大值时，会自动重置为0并重新开始编号，但会跳过已使用的ID
- 删除模块时，会从已使用ID集合中移除对应的ID，以便重用
- 系统维护"已使用ID集合"，确保ID的唯一性

全局变量：00000001OT001 被指定为「子模块第 2 个输出接口」对应的全局变量名，支持自动保存。

---

## 6. 功能说明

### 6.1 模块样式

#### 6.1.1 基础样式规范
所有模块默认采用矩形设计，边缘线条清晰锐利，整体风格简洁直观，便于拖拽操作与视觉区分。

样式与尺寸依据：模块的具体样式细节（含功能关键词、贴图图标）、长度、宽度参数，均由对应模块代码文件前 12 行的注释内容指定，实现样式与模块逻辑的关联配置；
- 容错性处理：当注释格式错误或缺失时，系统会：
  1. 加载默认样式（矩形、默认端口数量）
  2. 记录解析错误但继续执行
  3. 为缺失的参数设置合理的默认值

模块内部：通过浅线条划分功能区域（含参数配置区、状态显示区、核心功能区），无重叠遮挡；表面印有模块功能关键词（如 "输入""调用""处理""输出"）及 6 个功能贴图图标，作为模块类型快速识别标识；

端口设计：输入 / 输出端口位于模块侧边缘（输入在左、输出在右），端口为模块侧边缘处的小方形区域，方形内部带有箭头标识：输入端口的箭头指向模块内部，输出端口的箭头指向模块外部，明确数据传输的方向与连线接口位置。

#### 6.1.2 特殊边缘样式规则（根据端口数量动态调整）

无输入模块（input_quantity=0）：矩形左侧边缘自动变为圆弧形，取消左侧的 "方形 + 箭头" 输入端口标识，通过形态直观体现 "无输入接口" 的特性；

无输出模块（output_quantity=0）：矩形右侧边缘自动变为圆弧形，取消右侧的 "方形 + 箭头" 输出端口标识，明确 "无输出接口" 的属性；

既有输入又有输出的模块（input_quantity≥1 且 output_quantity≥1）：保持矩形四边直角设计，左右两侧清晰标注 "方形 + 箭头" 的标准化输入 / 输出端口（格式为IN_001/OUT_001），端口标识与模块边缘齐平，便于连线操作。

### 6.2 线的种类

系统支持两种类型的连接线：

1. **黑线**：
   - 数据传递：数据从A模块到B模块，仅在B模块`excitedbydata=T`（可被数据激活）时继续传递
   - 传输数据时，颜色为红、黄相间

2. **红线**：
   - 在传输数据的同时，让B模块立即激活，用红线表示进程
   - 对于无延迟的模块，会立即执行；对于有延迟的模块，会等待延迟后再执行
   - 传输数据时，颜色为红、黄相间

**连线颜色设置**：
- 连线的红黑色是用户设置的
- 用户可以通过双击连线进行切换

### 6.3 运行方式

- **步进运行**：
  - 仅运行一次，在连线颜色点添加黄色圆圈
  - 点击步进后，向后运行一个步进
  
- **延迟运行**：
  - 步进与数据强传递运行至下一个有延迟模块
  - 延迟运行：上一步完成后隔指定时间，运行下一步

- **自动运行模式**：
  - 当前实现：每一步进执行完毕后自动停止运行，不再使用固定的时间间隔
  - 设计意图：确保每一步进都能完整执行，避免因固定间隔导致的执行不同步问题
  - 执行方式：系统会执行一个完整的步进，包括所有模块的执行和数据传输，然后停止运行

- **暂停功能**：
  - 点击暂停键后，该一步进执行完毕后暂停
  - "步进执行完毕"的判定标准：当前步进内所有模块执行+数据传输完成，且无未完成的延迟等待
  - 暂停后，模块执行会被中断，确保资源不被浪费
  - 暂停时会标记当前执行位置，记录未完成的延迟任务状态
  - 暂停后禁止新的步进启动，直至点击"继续"

- **继续运行**：
  - 点击运行键后继续以自动模式运行
  - 继续运行时会检查模块的执行状态，确保从正确的位置继续

- **边界场景校验**：
  - 无输入端口的模块应该是输入模块或excitedbydata=T的模块
  - 无输出端口的模块应该是输出模块或终点模块
  - 校验失败后的处理逻辑：系统会在执行前进行校验，对于不符合要求的模块，会记录警告信息但继续执行
  - 实现方式：在`executeModule`函数中进行边界场景校验，确保模块配置合理

- **用户输入触发**：
  - 当用户在右侧对话处发送内容后，"user输入模块"输出用户输入的内容，整体开始运行

- **对话输出触发停止**：
  - 当"对话输出"模块接受到内容后，在当前步进执行完毕后，停止运行
  - 清空范围：只清空模块输入/输出端口的业务变量，保留`displayContent`/缓存模块的缓存值
  - 清空时机：在"对话输出模块接收内容后，当前步进执行完毕的瞬间"
  - 实现方式：系统会遍历所有模块状态，清空非缓存模块和显示模块的输入输出值

- **缓存模块执行特性**：
  - 缓存模块在每次步进执行中都会进行一次输出（包括用户输入触发的初始步进）
  - 这一输出会在其他所有数据传输进行前进行
  - 缓存模块在有输入数据时会更新缓存，在无输入数据时会保持原有输出
  - 缓存模块初始化值：默认初始化为null
  - 缓存模块时序冲突处理：当接收到多个输入数据时，会根据时间戳选择最新的数据进行更新
  - 时间戳生成规则：使用系统接收数据时的毫秒级时间戳（Date.now()）
  - 多输入同时到达时的处理：缓存模块维护"输入数据时间戳记录表"，每次接收数据时记录时间戳，更新缓存时对比所有输入的时间戳
  - "最新数据"判定标准：时间戳数值最大的即为最新数据

- **显示模块执行特性**：
  - 显示模块会将输入数据作为输出
  - 显示模块会设置displayContent变量，与实际内容分离
  - 停止运行时，显示模块的displayContent变量会被保留

- **执行流程**：
  1. **初始化**：系统加载所有模块，准备执行环境
  2. **触发运行**：
     - 通过用户输入触发：用户在右侧对话处发送内容，"user输入模块"输出内容
  3. **缓存模块执行**：
     - 缓存模块在每次步进开始时进行输出
     - 这一输出在其他所有数据传输前进行
  4. **模块执行**：
     - 按照连线顺序执行各个模块
     - 每个模块调用其文件中定义的函数
     - 函数输入来自端口变量（按顺序）
     - 函数按序返回输出值，赋值给输出变量
     - 对于显示模块，会设置displayContent变量，与实际内容分离
  5. **数据传输**：
     - 输出值通过连线传输到下一个模块的输入端口
     - 支持一连多（多连一）的连接方式
     - 若为无延迟模块，则继续向后运行
  6. **步进控制**：
     - 自动运行模式：每一步进执行后等待0.2秒，自动运行下一步进
     - 暂停：点击暂停键后，当前步进执行完毕后暂停
     - 继续：点击运行键后继续以自动模式运行
     - 步进：点击步进按钮，向后运行一个步进
  7. **停止运行**：
     - 当"对话输出"模块接受到内容后，在当前步进执行完毕后停止运行
     - 将除了"缓存模块"之外的端口变量全部赋值为空
     - 保留"显示模块"和"缓存模块"的显示内容（displayContent变量）
     - 点击"停止"按钮强制停止执行

- **运行支持**：
  - 支持一连多（多连一）的连接方式
  - 当流程中需要"延迟"运行至下一个延迟模块时，若A为流程模块，且A到B的连线可以激活B，则在该"步进"内，A和B都运行

### 6.4 一键代码转换

系统提供强大的一键代码转换功能，将图形化编程结果转换为可执行的 Python 代码！

#### 6.4.1 功能特点
- **基于 Python AST 的代码生成器**
  - 使用 Python 标准库 `ast` 模块构建抽象语法树
  - 使用 `astor` 库将 AST 转换为源代码
  - **语法保证**：生成的代码一定是语法正确的
  
- **支持的文件格式**
  - `.aiud` 格式（ZIP 压缩包，包含 project.json 和自定义模块）
  - `.json` 格式（纯 JSON 工作流文件）
  
- **插件化架构**
  - 代码生成功能独立封装在 `plugin/json2py.py` 插件中
  - 方便维护和扩展
  - 核心代码生成逻辑与主应用分离

#### 6.4.2 使用步骤
1. 在 Web 界面右上角点击"生成代码"按钮
2. 在弹出的界面中选择工作流文件（.aiud 或 .json）
3. 系统会自动解析文件内容并显示文件预览
4. 点击"生成代码"按钮生成 Python 代码
5. 生成的代码会在界面上显示
6. 可以点击"复制代码"将代码复制到剪贴板
7. 可以点击"下载代码"将代码保存为 .py 文件

#### 6.4.3 生成的代码特点
- **完整的文档注释**：包含详细的功能说明
- **全局设置变量**：模块的设置值以全局变量形式放在代码开头
- **模块执行函数**：各个模块的 execute 函数被重命名并集成
- **拓扑排序执行**：按照模块连线的执行顺序（拓扑排序）调用各个模块
- **主函数封装**：完整的 main() 函数封装了整个工作流
- **示例用法**：包含示例调用代码，方便测试

#### 6.4.4 技术实现
代码生成插件位于 `plugin/json2py.py`，主要包含以下功能：
- `topological_sort()`: 拓扑排序算法，计算模块执行顺序
- `generate_python_code_from_workflow()`: 核心代码生成函数
  - 收集模块信息并建立索引
  - 拓扑排序计算执行顺序
  - 收集模块源代码并提取 execute 函数
  - 生成全局设置变量
  - 构建 AST 节点（函数定义、变量赋值、调用等）
  - 使用 astor 转换为源代码

### 6.5 模块运行逻辑

模块的运行逻辑如下：

1. **模块执行准备**：
   - 读取模块文件，获取函数名称和参数信息
   - 确定模块的输入变量数量（`input_quantity`）和总变量数量（`variable_quantity`）
   - 准备函数调用所需的输入变量值

2. **输入变量获取**：
   - 前`#input_quantity`个变量值来自输入端口的变量值
   - 所有输入变量的默认值来自"设置"界面所设置的值

3. **函数执行**：
   - 运行模块中定义的函数，传入准备好的输入变量
   - 优先调用`execute`、`run`、`process`等主执行函数
   - 对于调用模块，额外传递`settings`参数和`cancel_token`参数
   - 函数的输出值数量等于输出端口的数量
   - 特殊情况：当模块的`time_late == variable_quantity`时，输出值的数量会比输出端口数多1（多的那一个return为延迟步数的数量）

4. **输出值处理**：
   - 根据函数的返回值，对输出端口的端口变量进行赋值
   - 处理延迟步数，根据延迟步数向后执行
   - 延迟步数数值范围校验：确保延迟步数为非负整数
   - 校验失败后的处理逻辑：如果延迟步数为负数或非整数，系统会跳过该模块的延迟执行，直接执行模块
   - 实现方式：在数据传输时进行校验，使用Number.isInteger()和>=0判断
   - 对于多输出延迟逻辑：所有输出端口都会按照相同的延迟步数执行

5. **显示内容处理**：
   - 对于"显示模块"和"缓存模块"，系统会使用`displayContent`变量存储显示内容
   - `displayContent`变量与实际输出值分离，确保停止运行时显示内容不会被清空
   - 当模块有新的输入数据时，`displayContent`会被更新为新的内容
   - 当停止运行时，`displayContent`变量会被保留，而其他端口变量会被清空

6. **数据激活处理**：
   - **excitedbydata参数说明**：
     - `excitedbydata=T`：模块会被数据激活（即会被黑线激活），当依赖模块执行且至少有一个输入端口有数据时会加入执行顺序
     - `excitedbydata=F`：模块不会被数据激活（即不会被黑线激活），只会被红线激活
   - 显示模块和缓存模块总是会加入执行顺序，无论`excitedbydata`值如何
   - 对于多连一场景：直接使用最后接收到的值，无论数据类型如何
   - "最后接收"的判定维度：模块执行周期内最晚到达该端口的数据
   - 实现方式：系统会记录每个数据的接收时间戳，时间戳最大的即为最后接收到的值
   - 数据类型处理：对于数据类型不兼容的情况，系统会尝试自动转换，转换失败时会记录错误但继续执行

### 6.6 模块参数

每个模块包含以下参数：

| 参数名 | 类型 | 描述 |
|-------|------|------|
| input_quantity | 数字 | 输入端口数量 |
| variable_quantity | 数字 | 变量数量 |
| userinput | 布尔值 | 是否有用户输入 |
| showingwindow_quantity | 数字 | 内容显示窗口数 |
| inputtingwindow_quantity | 数字 | 设定窗口数 |
| setting | 布尔值 | 是否有设置窗口 |
| output_quantity | 数字 | 输出端口数量 |
| time_late | 数字 | 延迟步进数(延迟n个步进后输出) |
| name | 字符串 | 模块名称 |
| excitedbydata | 布尔值 | 是否被数据激活 |
| variables_name | 字符串 | 变量的名称，其中前input_quantity个为输入端口名 |
| kind | 字符串 | 模块的分类 |
| output_name | 字符串 | 输出端口的名称，与output_quantity数量对应 |

---

## 7. 内置模块说明

### 7.1 Stable Diffusion 相关模块

#### 7.1.1 Checkpoint加载器
- **功能**: 纯指路牌，只传模型文件路径，不加载不运算
- **输入**: 模型文件夹路径、模型文件选择（可选）
- **输出**: (model_path, vae_path, clip_path) - 三个都是字符串路径
- **特点**: 自动从 `gui_settings.json` 读取默认模型路径，自动扫描模型文件

#### 7.1.2 空Latent张量生成模块
- **功能**: 生成空的 Latent 噪声张量
- **输入**: 无
- **输出**: {"samples": latents} - Latent 张量字典
- **设置**: 宽度、高度、批量大小、种子

#### 7.1.3 CLIP文本编码模块
- **功能**: 使用 CLIP 模型编码提示词
- **输入**: clip_model_path, prompt
- **输出**: 文本向量
- **特点**: 支持模型缓存，避免重复加载

#### 7.1.4 K采样器模块
- **功能**: Stable Diffusion K 采样器（Inpaint 增强版）
- **输入**: 模型、正面条件、负面条件、Latent图像
- **输出**: 生成的 Latent 张量
- **设置**: 种子、步数、CFG、采样器名称、调度器、降噪
- **特点**: 
  - 支持遮罩重绘，mask 区域精准生成
  - Mask 边缘高斯模糊，增强提示词引导性
  - 优化 CFG 默认值，提升提示词权重

#### 7.1.5 VAE解码模块
- **功能**: 将 Latent 张量解码为 PIL 图像
- **输入**: latents, vae_model_path
- **输出**: PIL 图像
- **特点**: 强制精度/设备对齐，支持 CPU/GPU 自动选择

#### 7.1.6 图片保存/显示模块
- **功能**: 保存和显示生成的图像
- **输入**: image
- **输出**: 保存结果信息
- **设置**: 保存路径、是否保存
- **特点**: 自动从 `gui_settings.json` 读取默认保存路径

#### 7.1.7 加载图像模块
- **功能**: 从本地加载图像文件
- **输入**: 无
- **输出**: PIL 图像

#### 7.1.8 VAE图像编码模块
- **功能**: 将 PIL 图像编码为 Latent 张量

#### 7.1.9 VAE重绘编码器模块
- **功能**: 专门用于图生图/遮罩重绘的 VAE 编码器

#### 7.1.10 设置Latent噪波遮罩模块
- **功能**: 为 Latent 张量设置噪声遮罩，用于遮罩重绘

### 7.2 通用模块

#### 7.2.1 user输入
- **功能**: 获取用户输入
- **输入**: 无
- **输出**: 用户输入内容

#### 7.2.2 固定值输出模块
- **功能**: 输出固定值
- **输入**: 无
- **输出**: 用户设置的固定值

#### 7.2.3 判断模块
- **功能**: 条件判断
- **输入**: 判断值
- **输出**: (True, False) 或 (False, True)

#### 7.2.4 比大小模块
- **功能**: 比较两个数值的大小
- **输入**: 数值1, 数值2
- **输出**: 比较结果

#### 7.2.5 调用模块
- **功能**: 调用外部 API（如 LM Studio）
- **输入**: 输入文本
- **输出**: API 返回结果
- **特点**: 支持取消操作

#### 7.2.6 显示模块
- **功能**: 在界面上显示数据
- **输入**: 要显示的数据
- **输出**: 无

#### 7.2.7 对话输出
- **功能**: 专门用于显示对话内容
- **输入**: 对话文本
- **输出**: 无

#### 7.2.8 缓存模块
- **功能**: 缓存数据供后续使用
- **输入**: 要缓存的数据
- **输出**: 缓存的数据

---

## 8. 模块开发指南

### 8.1 模块基础结构

一个完整的模块由以下两部分组成：

#### 8.1.1 配置头部

模块文件的开头需要包含一系列以 `#` 开头的配置参数，这些参数定义了模块的基本属性和行为。

```python
#input_quantity=002      # 输入端口数量（三位数字）
#variable_quantity=003    # 变量数量（三位数字）
#userinput=F              # 是否支持用户输入（T/F）
#setting=T                # 是否支持设置（T/F）
#output_quantity=001      # 输出端口数量（三位数字）
#time_late=000            # 延迟时间（三位数字）
#name=示例模块            # 模块名称
#excitedbydata=T          # 是否可被数据激活（T/F）
#variables_name=输入1,输入2,参数1  # 变量名称（多个变量用逗号分隔）
#kind=处理模块            # 模块类型
#output_name=输出        # 输出名称（多个输出用逗号分隔）
```

#### 8.1.2 模块代码

配置头部之后是模块的实际代码，包括：
1. 必要的导入语句
2. 模块的核心逻辑函数
3. 主执行函数 `execute()`
4. 可选的测试代码

### 8.2 配置参数详细说明

| 参数 | 说明 | 示例值 |
|------|------|--------|
| input_quantity | 输入端口数量，格式为三位数字 | 001, 004 |
| variable_quantity | 变量数量，格式为三位数字 | 001, 004 |
| userinput | 是否支持用户输入，T/F | T, F |
| setting | 是否支持设置，T/F | T, F |
| output_quantity | 输出端口数量，格式为三位数字 | 001, 002 |
| time_late | 延迟时间 | 0, 1000 |
| excitedbydata | 是否可被数据激活，T/F | T, F |
| name | 模块名称 | 缓存模块, 调用模块 |
| kind | 模块类型 | 处理模块, 调用模块 |
| variables_name | 变量名称，多个用逗号分隔 | 模型选择,提示词,上下文,对话 |
| output_name | 输出名称，多个用逗号分隔 | 生成结果,更新后的上下文 |

### 8.3 变量传递规则

1. **前 `input_quantity` 个变量**：来自输入端口
2. **剩余变量**：来自设置界面
3. **settings 参数**（可选）：完整的设置字典，用于模块需要访问所有设置时

### 8.4 执行函数格式

每个模块必须实现一个 `execute()` 函数，这是模块的主入口点。函数的参数数量应与模块的输入端口数量匹配。

#### 8.4.1 基本格式

```python
def execute(input1, input2, ..., settings=None, cancel_token=None):
    """
    执行模块逻辑
    
    参数:
    - input1, input2, ...: 输入参数，数量与input_quantity对应
    - settings: 额外的设置参数（可选）
    - cancel_token: 取消令牌函数，用于检查是否需要取消执行（可选，主要用于调用模块）
    
    返回:
    - 输出值或输出值列表，数量与output_quantity对应
    """
    # 模块逻辑
    # ...
    
    # 返回结果
    return output
    # 或多个返回值
    # return output1, output2
```

#### 8.4.2 参数说明

- **输入参数**: 根据模块的 `input_quantity` 配置，函数会接收相应数量的输入参数。这些参数来自连接的上游模块的输出。
- **settings**: 当模块配置了 `setting=T` 时，这个参数会包含用户在设置界面中配置的值。
- **cancel_token**: 这是一个函数，用于检查执行是否应该被取消。在长时间运行的操作中，应该定期调用这个函数并在返回 `T` 时停止执行。

#### 8.4.3 返回值说明

- 函数应该返回与 `output_quantity` 配置数量相匹配的值。
- 如果只需要返回一个值，可以直接返回该值。
- 如果需要返回多个值，应该返回一个元组。
- 如果模块配置了 `time_late` 并且其值等于 `variable_quantity`，则返回值数量应该比 `output_quantity` 多1，多的那个值是延迟步数。

### 8.5 模块类型

根据 `kind` 参数，模块可以分为以下类型：

| 类型 | 说明 | 示例 |
|------|------|------|
| 处理模块 | 对输入数据进行处理并输出结果 | 缓存模块, 加法模块 |
| 调用模块 | 调用外部服务或API | 调用模块 |
| 输入模块 | 提供用户输入功能 | user输入模块 |
| 输出模块 | 展示输出结果 | 对话输出模块 |
| 加载器 | 加载器模块 | Checkpoint加载器 |
| 采样 | 采样模块 | K采样器模块 |

### 8.6 特殊数据类型处理

#### 8.6.1 PyTorch 张量
模块返回 PyTorch 张量时，系统会自动：
- 将张量存入全局缓存
- 返回 `TENSOR_REF:{uuid}` 引用
- 下游模块接收到引用时自动从缓存中取出张量

#### 8.6.2 PIL 图像
模块返回 PIL 图像时，系统会自动：
- 将图像存入全局缓存
- 返回 `IMAGE_REF:{uuid}` 引用
- 下游模块接收到引用时自动从缓存中取出图像

#### 8.6.3 PIL 图像列表
模块返回 PIL 图像列表时，系统会自动：
- 将列表存入全局缓存
- 返回 `IMAGE_LIST_REF:{uuid}` 引用

### 8.7 displayContent 机制

对于显示模块和缓存模块，系统使用 `displayContent` 变量来存储显示内容，这个变量与实际输出值分离：

- **displayContent 的用途**：专门用于在界面上显示数据
- **与输出值的分离**：displayContent 与模块的实际输出值是独立的
- **停止运行时的行为**：停止运行时，displayContent 会被保留，而其他端口变量会被清空
- **哪些模块使用**：显示模块和缓存模块会使用 displayContent

**工作原理**：
1. 当模块接收到新的输入数据时，displayContent 会被更新为新的内容
2. 界面上显示的是 displayContent 的值
3. 停止运行时，displayContent 保持不变，确保用户仍能看到之前的显示内容
4. 其他模块的端口变量会被清空

### 8.8 模块开发最佳实践

1. **清晰的文档**: 为模块和关键函数添加详细的文档字符串，说明功能、参数和返回值。
2. **错误处理**: 实现适当的错误处理，确保模块在异常情况下能够优雅失败并返回有意义的错误信息。
3. **类型检查**: 对输入参数进行类型检查和转换，确保模块的健壮性。
4. **默认值**: 为可选参数提供合理的默认值，提高模块的可用性。
5. **测试代码**: 添加测试代码，方便模块的调试和验证。
6. **模块化**: 将复杂逻辑分解为多个函数，提高代码的可读性和可维护性。
7. **性能考虑**: 对于计算密集型操作，考虑优化算法和数据结构，提高模块的执行效率。

### 8.9 模块开发示例

#### 示例 1：简单加法模块
```python
#input_quantity=002
#variable_quantity=002
#userinput=F
#setting=F
#output_quantity=001
#time_late=000
#name=加法模块
#excitedbydata=T
#variables_name=数值1,数值2
#kind=处理模块
#output_name=结果

def execute(num1, num2):
    try:
        return float(num1) + float(num2)
    except:
        return 0

# 测试代码
if __name__ == "__main__":
    test_result = execute(10, 20)
    print(f"加法测试结果: {test_result}")
```

#### 示例 2：带设置的模块
```python
#input_quantity=001
#variable_quantity=002
#userinput=F
#setting=T
#output_quantity=001
#time_late=000
#name=乘法模块
#excitedbydata=T
#variables_name=输入值,倍数
#kind=处理模块
#output_name=结果

def execute(input_val, multiplier, settings=None):
    """
    settings 参数包含完整的设置字典
    可以通过 settings.get('倍数') 获取特定设置
    """
    try:
        return float(input_val) * float(multiplier)
    except:
        return 0
```

#### 示例 3：图像处理模块
```python
#input_quantity=001
#variable_quantity=001
#userinput=F
#setting=F
#output_quantity=001
#time_late=000
#name=图像灰度化
#excitedbydata=T
#variables_name=图像
#kind=处理模块
#output_name=灰度图像

from PIL import Image

def execute(image):
    """
    接收 PIL 图像，返回灰度化后的图像
    """
    if image is None:
        return None
    
    try:
        return image.convert('L')
    except Exception as e:
        print(f"图像灰度化失败: {e}")
        return None
```

### 8.10 模块部署

1. **保存模块文件**：将开发完成的模块文件保存为 `.py` 文件。
2. **复制到模块目录**：将文件复制到 `default_modules` 目录（内置模块）或 `custom_modules` 目录（自定义模块）。
3. **刷新模块列表**：在图形化AI调用工具中，点击左侧模块库中自定义模块后方的刷新按钮，系统会重新加载模块。
4. **添加并测试**：从模块库中拖拽新模块到画布，配置参数并测试其功能。

---

## 9. GUI 配置与使用

### 9.1 GUI 启动
运行 `python app.py` 启动 GUI 配置工具。

### 9.2 GUI 功能说明

#### 9.2.1 状态栏（顶部）
- **状态标签**：显示服务器运行状态（运行中/未运行）
- **一键启动**：启动 Flask 服务器
- **终止进程**：停止 Flask 服务器
- **生成诊断包**：生成系统诊断信息

#### 9.2.2 左侧导航栏
- **设置**：基本设置页面
- **高级设置**：性能设置和环境安装
- **终端面板**：查看服务器输出

#### 9.2.3 设置页面
- **模型文件夹路径**：设置默认的模型文件夹
- **默认图片保存路径**：设置默认的图片保存路径

#### 9.2.4 高级设置页面
- **环境一键安装**：快速安装 CUDA 或 DML 虚拟环境
- **生成引擎**：选择计算引擎（CUDA/DML/ZLUDA/CPU）
- **使用 CPU 运行 VAE**：显存优化选项

#### 9.2.5 终端面板
- 实时显示服务器输出
- 支持滚动查看历史记录

### 9.3 计算引擎选择

在「高级设置」中可以选择生成引擎：

| 引擎 | 适用显卡 | 说明 |
|-----|---------|------|
| CUDA GPU | NVIDIA | 性能最佳，推荐 |
| TensorRT GPU | NVIDIA | TensorRT 加速 |
| DML GPU | AMD/Intel | DirectML 支持 |
| ZLUDA GPU | AMD | CUDA 兼容层 |
| CPU | 所有 | 兼容性最好，速度最慢 |

### 9.4 显存优化

如果显存不足，可以开启 **「使用 CPU 运行 VAE」** 选项：
- 优点：显著降低峰值显存消耗
- 缺点：稍微降低整体速度

---

## 10. 常见工作流示例

### 10.1 文生图工作流

```
user输入 → CLIP文本编码 → K采样器 ← 空Latent
                          ↓
                    VAE解码 → 图片保存/显示
                          ↑
              Checkpoint加载器
```

**模块配置**：
1. **user输入**：输入提示词（如"一只可爱的小猫"）
2. **固定值输出模块**：输入负面提示词（如"bad quality, ugly"）
3. **Checkpoint加载器**：选择 SD 模型
4. **空Latent张量生成模块**：设置图像尺寸（如 512x512）
5. **CLIP文本编码模块**（2个）：分别编码正面和负面提示词
6. **K采样器模块**：设置步数、CFG、采样器等
7. **VAE解码模块**：解码 Latent 为图像
8. **图片保存/显示模块**：保存或显示生成的图像

### 10.2 图生图工作流

```
加载图像 → VAE图像编码 → K采样器 ← CLIP文本编码
                          ↓
                    VAE解码 → 图片保存/显示
                          ↑
              Checkpoint加载器
```

**模块配置**：
1. **加载图像模块**：加载原图
2. **VAE图像编码模块**：将图像编码为 Latent
3. **Checkpoint加载器**：选择 SD 模型
4. **user输入**：输入提示词
5. **CLIP文本编码模块**：编码提示词
6. **K采样器模块**：设置降噪强度（如 0.7）
7. **VAE解码模块**：解码 Latent 为图像
8. **图片保存/显示模块**：保存或显示生成的图像

### 10.3 遮罩重绘工作流

```
加载图像 → VAE重绘编码 → 设置Latent噪波遮罩 → K采样器
                                                     ↓
                                               VAE解码 → 图片保存/显示
                                                     ↑
                                         Checkpoint加载器
```

**模块配置**：
1. **加载图像模块**：加载原图
2. **加载图像模块**（第2个）：加载 mask 图像（白色为重绘区域）
3. **VAE重绘编码器模块**：编码原图和 mask
4. **设置Latent噪波遮罩模块**：设置噪波遮罩
5. **Checkpoint加载器**：选择 SD 模型
6. **user输入**：输入提示词
7. **CLIP文本编码模块**：编码提示词
8. **K采样器模块**：设置降噪强度
9. **VAE解码模块**：解码 Latent 为图像
10. **图片保存/显示模块**：保存或显示生成的图像

### 10.4 简单对话工作流

```
user输入 → 调用模块 → 对话输出
```

**模块配置**：
1. **user输入**：输入对话内容
2. **调用模块**：配置 LM Studio API
3. **对话输出**：显示对话结果

---

## 11. 最佳实践

### 11.1 模块布局最佳实践
1. 按照数据流向从左到右排列模块
2. 相关模块放在相近位置，便于连线和查看
3. 留出足够的空间用于连线，避免连线交叉过多
4. 为复杂工作流使用模块化布局，按功能分组

### 11.2 配置优化
1. 为每个模块设置合理的默认值，减少用户配置工作量
2. 使用描述性的模块名称和端口标签，便于理解数据流向
3. 对于复杂工作流，可使用缓存模块减少重复计算
4. 合理使用延迟执行（time_late）功能，优化执行顺序

### 11.3 显存管理
1. 使用模型缓存避免重复加载
2. 显存不足时开启「使用 CPU 运行 VAE」
3. 执行完成后可以使用「停止」按钮清空缓存和显存

### 11.4 错误处理
1. 确保所有必需的模块和连线都已配置
2. 检查模块端口类型是否匹配
3. 验证模块设置是否符合要求
4. 使用终端面板查看详细的错误信息

---

## 12. 故障排除

### 12.1 常见错误

#### 12.1.1 模型加载失败
- **症状**：提示模型文件不存在或加载失败
- **解决方法**：
  - 检查模型文件夹路径是否正确
  - 确认模型文件存在（.safetensors/.ckpt/.bin）
  - 检查模型文件格式是否正确

#### 12.1.2 显存不足（OOM）
- **症状**：提示 CUDA out of memory
- **解决方法**：
  - 减小图像尺寸（如从 1024 降到 512）
  - 减小批量大小
  - 开启「使用 CPU 运行 VAE」
  - 切换到 CPU 模式

#### 12.1.3 DML 引擎无法使用
- **症状**：选择 DML 引擎后提示虚拟环境不存在
- **解决方法**：
  - 在「高级设置」中点击「一键安装」
  - 选择「仅安装 DML」或「全部安装」
  - 等待安装完成后重试

#### 12.1.4 模块执行无反应
- **症状**：点击运行后没有任何反应
- **解决方法**：
  - 检查连线是否正确
  - 确认是否使用了红线（强制激活）
  - 查看终端面板的错误信息
  - 检查模块的 `excitedbydata` 设置

#### 12.1.5 生成的图像有问题
- **症状**：图像全黑、全绿或有明显瑕疵
- **解决方法**：
  - 检查 VAE 解码模块的设备和精度设置
  - 确认模型文件正确
  - 尝试不同的采样器和参数
  - 查看终端面板的详细输出

#### 12.1.6 模块不显示在工具中
- **症状**：添加的模块不在模块库中显示
- **解决方法**：
  - 检查配置头部的格式和参数，确保所有参数都正确设置
  - 确认模块文件编码为 UTF-8

#### 12.1.7 模块执行出错
- **症状**：点击运行后模块报错
- **解决方法**：
  - 确保 `execute()` 函数的参数数量与 `input_quantity` 一致
  - 查看终端面板的错误信息

#### 12.1.8 设置不生效
- **症状**：模块设置后没有反应
- **解决方法**：
  - 在 `execute()` 函数中添加对 `settings` 参数的处理

#### 12.1.9 输出与预期不符
- **症状**：模块输出结果不对
- **解决方法**：
  - 确保返回值的数量与 `output_quantity` 配置一致

### 12.2 调试技巧

1. **添加日志**：在模块中添加 `print()` 语句，输出关键变量的值和执行状态
2. **错误捕获**：使用 `try-except` 块捕获并打印异常信息，帮助定位问题
3. **本地测试**：在模块文件末尾添加测试代码，在本地运行测试，验证模块功能
4. **简化测试**：从简单的输入开始测试，逐步增加复杂度，定位问题所在
5. **检查类型**：确保输入和输出的数据类型与预期一致，必要时进行类型转换
6. **从简单的工作流开始**：逐步添加复杂度
7. **使用显示模块查看中间结果**
8. **检查系统日志获取详细的执行信息**
9. **验证每个模块的输入和输出数据**
10. **使用「生成诊断包」功能收集系统信息**

### 12.3 验证方法

1. 确保所有必需字段都已填写
2. 检查模块 ID 和连接的一致性
3. 测试生成的文件是否可以正常加载
4. 验证工作流执行结果是否符合预期

---

## 13. 总结

本项目通过图形化界面和模块化设计，大大简化了AI模型的调用和流程编排过程，使非专业人员也能轻松构建和部署AI应用。系统支持多种运行模式和模块类型，具有良好的扩展性和定制性。

通过本工具，用户可以：
- 快速构建AI应用原型
- 可视化设计和测试AI工作流
- 一键生成可部署的代码
- 自定义和扩展功能模块

本工具为AI应用的开发和部署提供了一种直观、高效的解决方案，适合各种规模和类型的AI项目。

希望本文档能够帮助您顺利使用本工具！如果您有任何问题或建议，请随时反馈。

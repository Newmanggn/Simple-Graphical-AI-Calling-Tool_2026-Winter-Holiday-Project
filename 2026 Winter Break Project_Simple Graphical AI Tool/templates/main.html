<!DOCTYPE html>
<html lang="zh-CN">
<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>简单图形化AI调用工具</title>
        <!-- 引入JSZip库 -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            overflow: hidden;
        }
        
        /* 顶部控制面板 */
        .top-panel {
            background-color: #333;
            color: white;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            height: 60px;
        }
        
        /* 项目名样式 */
        .project-name {
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            flex: 1;
            margin: 0 20px;
        }
        
        .control-buttons {
            display: flex;
            gap: 10px;
        }
        
        .control-buttons button {
            padding: 5px 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .control-buttons button:hover {
            background-color: #45a049;
        }
        
        /* 主容器 */
        .main-container {
            display: flex;
            height: calc(100vh - 60px);
        }
        
        /* 左侧模块库 */
        .module-library {
            width: 200px;
            background-color: #f5f5f5;
            border-right: 1px solid #ddd;
            overflow-y: auto;
            padding: 10px;
            transition: width 0.3s ease;
        }
        
        .module-library.collapsed {
            width: 40px;
        }
        
        .module-library.collapsed .module-category h3,
        .module-library.collapsed .module-item {
            display: none;
        }
        
        .collapse-btn {
            position: absolute;
            top: 50%;
            right: -10px;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            background-color: #ddd;
            border: 1px solid #ccc;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        .module-library .collapse-btn {
            right: -10px;
        }
        
        .chat-panel .collapse-btn {
            left: -10px;
        }
        
        .module-category {
            margin-bottom: 20px;
        }
        
        .module-category h3 {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #666;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .module-category h3::after {
            content: '▼';
            font-size: 10px;
            transition: transform 0.3s ease;
        }
        
        .module-category.collapsed h3::after {
            transform: rotate(-90deg);
        }
        
        .module-category.collapsed .module-items {
            display: none;
        }
        
        .module-category.collapsed h3 {
            margin-bottom: 5px;
        }
        
        .module-item {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 5px;
            cursor: grab;
            transition: all 0.2s ease;
        }
        
        .module-item:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        
        .module-item:active {
            cursor: grabbing;
        }
        
        .module-item .module-name {
            font-weight: bold;
            font-size: 12px;
        }
        
        .module-item .module-kind {
            font-size: 10px;
            color: #666;
            margin-top: 2px;
        }
        
        /* 中央画布 */
        .canvas {
            flex: 1;
            background-color: white;
            position: relative;
            overflow: hidden;
            cursor: grab;
            user-select: none;
        }
        
        .canvas-content {
            position: relative;
            transform-origin: 0 0;
            background-image: linear-gradient(#e0e0e0 1px, transparent 1px),
                              linear-gradient(90deg, #e0e0e0 1px, transparent 1px),
                              linear-gradient(#999 3px, transparent 3px),
                              linear-gradient(90deg, #999 3px, transparent 3px);
            background-size: 20px 20px, 20px 20px, 60px 60px, 60px 60px;
            width: 4000px;
            height: 3000px;
            min-width: 100%;
            min-height: 100%;
        }
        
        .canvas:active {
            cursor: grabbing;
        }
        
        .module {
            position: absolute;
            background-color: white;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            width: 220px;
            min-width: 220px;
            max-width: 220px;
            box-sizing: border-box;
            min-height: 80px;
            cursor: move;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* 缩放控制 */
        .zoom-controls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 5px;
            display: flex;
            gap: 5px;
        }
        
        .zoom-controls button {
            height: 30px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .zoom-controls button:not(#resize-canvas-btn) {
            width: 30px;
        }
        
        #resize-canvas-btn {
            width: auto;
            padding: 0 10px;
        }
        
        .zoom-controls button:hover {
            background-color: #e0e0e0;
        }
        
        .zoom-controls .zoom-level {
            width: 60px;
            text-align: center;
            line-height: 30px;
            font-size: 12px;
        }
        
        /* 模块样式 */
        .module {
            position: absolute;
            background-color: white;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 10px;
            width: 220px;
            min-width: 220px;
            max-width: 220px;
            box-sizing: border-box;
            min-height: 80px;
            cursor: move;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        /* 无输入模块样式 */
        .module.no-input {
            border-top-left-radius: 20px;
            border-bottom-left-radius: 20px;
        }
        
        /* 无输出模块样式 */
        .module.no-output {
            border-top-right-radius: 20px;
            border-bottom-right-radius: 20px;
        }
        
        .module .module-header {
            font-weight: bold;
            margin-bottom: 5px;
            text-align: center;
        }
        
        .module .module-kind {
            font-size: 10px;
            color: #666;
            text-align: center;
            margin-bottom: 10px;
        }
        
        .module .ports {
            display: flex;
            justify-content: space-between;
            margin-top: 10px;
        }
        
        /* 设置按钮 */
        .setting-btn {
            position: absolute;
            top: 5px;
            right: 5px;
            padding: 2px 6px;
            background-color: #f0f0f0;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            color: #666;
        }
        
        .setting-btn:hover {
            background-color: #e0e0e0;
            color: #333;
        }
        
        /* 设置窗口 */
        .setting-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .setting-modal-content {
            background-color: white;
            border-radius: 8px;
            padding: 20px;
            width: 400px;
            max-width: 90%;
            max-height: 80%;
            overflow-y: auto;
        }
        
        .setting-modal h3 {
            margin-bottom: 20px;
            text-align: center;
        }
        
        .setting-form {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .setting-form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .setting-form-group label {
            font-size: 14px;
            font-weight: bold;
        }
        
        .setting-form-group input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .setting-modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }
        
        .setting-modal-buttons button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .setting-modal-buttons .cancel-btn {
            background-color: #f0f0f0;
        }
        
        .setting-modal-buttons .save-btn {
            background-color: #4CAF50;
            color: white;
        }
        
        .setting-modal-buttons .save-btn:hover {
            background-color: #45a049;
        }
        
        .module .input-ports {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        
        .module .output-ports {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .port {
            width: 10px;
            height: 10px;
            background-color: #333;
            border-radius: 50%;
            margin: 2px 0;
            cursor: crosshair;
        }
        
        .input-port {
            background-color: #f44336;
        }
        
        .output-port {
            background-color: #2196F3;
        }
        
        /* 右侧对话面板 */
        .chat-panel {
            width: 300px;
            background-color: #f5f5f5;
            border-left: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            transition: width 0.3s ease;
        }
        
        .chat-panel.collapsed {
            width: 40px;
        }
        
        .chat-panel.collapsed h3,
        .chat-panel.collapsed .chat-messages,
        .chat-panel.collapsed .chat-input {
            display: none;
        }
        
        .chat-panel h3 {
            padding: 10px;
            background-color: #333;
            color: white;
            font-size: 14px;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .message {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
        }
        
        .message.user {
            background-color: #e3f2fd;
            align-self: flex-end;
        }
        
        .message.ai {
            background-color: #f1f1f1;
            align-self: flex-start;
        }
        
        .chat-input {
            padding: 10px;
            border-top: 1px solid #ddd;
            display: flex;
        }
        
        .chat-input input {
            flex: 1;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        .chat-input button {
            margin-left: 10px;
            padding: 0 15px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        
        .chat-input button:hover {
            background-color: #45a049;
        }
        
        /* 连线样式 */
        .connection-line {
            position: absolute;
            background-color: #333;
            height: 3px;
            transform-origin: 0 0;
            z-index: 10;
            cursor: pointer;
        }
        
        .connection-line.red {
            background-color: #f44336;
        }
        
        /* 数据传输动画 */
        .connection-line.transferring {
            animation: dataTransfer 1s linear infinite;
        }
        
        @keyframes dataTransfer {
            0% { background-color: inherit; }
            50% { background-color: yellow; }
            100% { background-color: inherit; }
        }
        
        /* 模块错误状态 - 红色 */
        .module.error {
            background-color: #ffebee !important;
            border: 2px solid #f44336 !important;
            box-shadow: 0 0 10px rgba(244, 67, 54, 0.5) !important;
        }
        
        .module.error .module-header {
            color: #d32f2f !important;
        }
        
        .module.error .module-kind {
            color: #c62828 !important;
        }
    </style>
</head>
<body>
    <!-- 顶部控制面板 -->
    <div class="top-panel">
        <div class="project-info">简单图形化AI调用工具</div>
        <div class="project-name" id="project-name">未命名项目</div>
        <div class="control-buttons">
                <button id="run-btn">运行</button>
                <button id="stop-btn">停止</button>
                <button id="continuous-run-btn">连续运行</button>
                <button id="generate-code-btn">生成代码</button>
                <button id="new-project-btn">新建</button>
                <button id="save-project-btn">保存</button>
                <button id="save-as-project-btn">另存为</button>
                <button id="load-project-btn">加载</button>
            </div>
    </div>
    
    <!-- 主容器 -->
    <div class="main-container" style="position: relative;">
        <!-- 左侧模块库 -->
        <div class="module-library" style="position: relative;">
            <div class="collapse-btn" id="module-library-collapse" style="top: 5px; right: 5px;">←</div>
            <div class="module-category">
                <h3>采样</h3>
                <div class="module-items" id="sampling-modules"></div>
            </div>
            <div class="module-category">
                <h3>加载器</h3>
                <div class="module-items" id="loader-modules"></div>
            </div>
            <div class="module-category">
                <h3>模型条件</h3>
                <div class="module-items" id="condition-modules"></div>
            </div>
            <div class="module-category">
                <h3>Latent</h3>
                <div class="module-items" id="latent-modules"></div>
            </div>
            <div class="module-category">
                <h3>图像</h3>
                <div class="module-items" id="image-modules"></div>
            </div>
            <div class="module-category">
                <h3>其它</h3>
                <div class="module-items" id="other-modules"></div>
            </div>
            <div class="module-category">
                <h3>自定义模块</h3>
                <div class="module-items" id="custom-modules"></div>
                <button id="refresh-modules-btn" style="width: 100%; margin-top: 10px; padding: 5px; font-size: 12px;">刷新</button>
            </div>
        </div>
        
        <!-- 中央画布 -->
        <div class="canvas" id="canvas">
            <!-- 缩放控制 -->
            <div class="zoom-controls">
                <button id="zoom-out">-</button>
                <div class="zoom-level">100%</div>
                <button id="zoom-in">+</button>
                <button id="resize-canvas-btn">调整画布</button>
            </div>
            <!-- 画布内容容器，用于实现缩放 -->
            <div class="canvas-content" id="canvas-content">
                <!-- 模块将被动态添加到这里 -->
            </div>
        </div>
        
        <!-- 右侧对话面板 -->
        <div class="chat-panel" style="position: relative;">
            <div class="collapse-btn" id="chat-panel-collapse" style="position: absolute; top: 5px; right: 5px;">→</div>
            <h3>对话面板</h3>
            <div class="chat-messages" id="chat-messages">
                <div class="message ai">你好！我是AI助手，有什么可以帮助你的吗？</div>
            </div>
            <div class="chat-input">
                <input type="text" id="chat-input" placeholder="输入消息...">
                <button id="send-btn">发送</button>
            </div>
        </div>
        
        </div>
    </div>
    
    <!-- 预览窗口 -->
    <div class="preview-window" style="position: fixed; bottom: 20px; right: 340px; width: 200px; height: 150px; background-color: #ffffff; border: 2px solid #ddd; border-radius: 4px; z-index: 99999; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        <div class="preview-header" style="display: flex; justify-content: space-between; align-items: center; padding: 5px 10px; background-color: #f5f5f5; border-bottom: 1px solid #ddd; border-radius: 4px 4px 0 0;">
            <span style="font-size: 10px; color: #333;">预览</span>
            <button class="preview-toggle" style="background: none; border: none; color: #666; font-size: 10px; cursor: pointer;">×</button>
        </div>
        <div class="preview-content" style="padding: 0; height: calc(100% - 30px); overflow: hidden; position: relative;">
            <canvas class="preview-canvas" id="preview-canvas-element" style="width: 100%; height: 100%; background-color: #fafafa;"></canvas>
            <div id="viewport-box" style="position: absolute; border: 2px solid #2196F3; background-color: rgba(33, 150, 243, 0.2); cursor: move; z-index: 100; pointer-events: auto;"></div>
        </div>
    </div>
    
    <!-- 连续运行设置模态框 -->
    <div id="continuous-run-modal" class="setting-modal" style="display: none;">
        <div class="setting-modal-content">
            <h3>连续运行设置</h3>
            <div class="setting-form">
                <div class="setting-form-group">
                    <label for="continuous-run-count">运行次数</label>
                    <input type="number" id="continuous-run-count" min="1" max="100" value="1">
                </div>
            </div>
            <div class="setting-modal-buttons">
                <button class="cancel-btn" onclick="document.getElementById('continuous-run-modal').style.display = 'none';">取消</button>
                <button class="save-btn" onclick="saveContinuousRunSettings();">确定</button>
            </div>
        </div>
    </div>
    
    <script>
        // 全局变量
        let modules = {};
        let draggedModule = null;
        let canvas = document.getElementById('canvas');
        let canvasContent = document.getElementById('canvas-content');
        let isDrawing = false;
        let startX, startY, endX, endY;
        let connectionLines = [];
        let currentConnection = null;
        let draggedPort = null;
        let firstPort = null;
        let currentZoomLevel = 100; // 全局存储当前缩放级别
        let canvasSize = { width: 4000, height: 3000 }; // 存储当前画布大小
        let runTrigger = 'button'; // 运行触发方式：'button'（运行按钮）或 'chat'（对话激活）
        let ongoingRequests = new Map(); // 存储正在进行的API请求控制器
        
        // 全局视口变量
        let globalCanvasOffsetX = 0;
        let globalCanvasOffsetY = 0;
        let globalZoomScale = 1;
        let updateViewportCallback = null; // 更新视口的回调函数
        
        // 画布拖动状态
        let isDraggingCanvas = false;
        let canvasStartX = 0;
        let canvasStartY = 0;
        let canvasStartOffsetX = 0;
        let canvasStartOffsetY = 0;
        
         // 鼠标位置追踪
        let lastMouseX = 0;
        let lastMouseY = 0;
        
        // 缩放级别
        let zoomLevel = 100;
        
        // 初始化模块分类折叠功能
        function initModuleCategoryCollapse() {
            const categoryHeaders = document.querySelectorAll('.module-category h3');
            categoryHeaders.forEach(header => {
                header.addEventListener('click', function() {
                    const category = this.parentElement;
                    category.classList.toggle('collapsed');
                });
            });
        }
        
        // 从模块文件内容中解析模块参数
        function parseModuleParamsFromContent(content) {
            const params = {};
            try {
                const lines = content.split('\n');
                for (const line of lines) {
                    const trimmedLine = line.trim();
                    if (!trimmedLine.startsWith('#')) {
                        continue; // 跳过非注释行，继续解析后续的注释行
                    }
                    
                    // 处理普通参数
                    if (trimmedLine.includes('=') && !trimmedLine.startsWith('#variables_name=') && !trimmedLine.startsWith('#output_name=')) {
                        const keyValue = trimmedLine.substring(1).split('=', 2);
                        if (keyValue.length === 2) {
                            const key = keyValue[0];
                            let value = keyValue[1];
                            // 转换布尔值
                            if (value.toLowerCase() === 't' || value.toLowerCase() === 'true') {
                                value = true;
                            } else if (value.toLowerCase() === 'f' || value.toLowerCase() === 'false') {
                                value = false;
                            } else if (!isNaN(value)) {
                                value = parseInt(value);
                            }
                            params[key] = value;
                        }
                    } else if (trimmedLine.startsWith('#variables_name=')) {
                        params['variables_name'] = trimmedLine.substring(16);
                    } else if (trimmedLine.startsWith('#output_name=')) {
                        params['output_name'] = trimmedLine.substring(13);
                    }
                }
            } catch (error) {
                console.error('解析模块文件失败:', error);
            }
            return params;
        }
        
        // 模块状态管理
        let moduleStates = {}; // 存储模块状态
        // 不再需要模块计数器和已使用ID集合，使用UUID生成唯一ID
        
        // 运行控制
        let isRunning = false; // 是否正在运行
        let currentStep = 0; // 当前步进
        let executionQueue = []; // 执行队列
        let executionTimer = null; // 自动执行定时器
        let pendingDelayTasks = []; // 未完成的延迟任务队列
        let autoRunInterval = 200; // 自动运行时间间隔（毫秒），默认0.2秒
        
        // 连续运行控制
        let isContinuousRunning = false; // 是否正在连续运行
        let continuousRunCount = 1; // 连续运行次数
        let currentRunIndex = 0; // 当前运行索引
        let hasTriggeredNextRun = false; // 标记是否已触发下一次运行
        
        // 拓扑排序计算模块执行顺序
        function calculateExecutionOrder() {
            // 构建依赖图
            const graph = {};
            const inDegree = {};
            const moduleIds = Object.keys(moduleStates);
            
            // 初始化图和入度
            moduleIds.forEach(moduleId => {
                graph[moduleId] = [];
                inDegree[moduleId] = 0;
            });
            
            // 构建依赖关系
            connectionLines.forEach(connection => {
                const { startModuleId, endModuleId } = connection;
                if (graph[startModuleId] && graph[endModuleId]) {
                    // 检查是否已经存在此依赖
                    if (!graph[startModuleId].includes(endModuleId)) {
                        graph[startModuleId].push(endModuleId);
                        inDegree[endModuleId]++;
                    }
                }
            });
            
            // 执行拓扑排序
            const queue = [];
            const order = [];
            
            // 首先处理入度为0的无源模块（无输入端口的模块）
            moduleIds.forEach(moduleId => {
                if (inDegree[moduleId] === 0) {
                    const inputQuantity = moduleStates[moduleId].moduleData.params.input_quantity || 0;
                    // 无源模块（无输入端口）直接加入执行顺序
                    if (inputQuantity === 0) {
                        queue.push(moduleId);
                    }
                }
            });
            
            // 按照正常顺序添加入度为0的无源模块
            order.push(...queue);
            
            // 继续处理其他模块
            while (order.length < moduleIds.length) {
                let processed = false;
                
                // 找到所有依赖已满足的模块
                moduleIds.forEach(moduleId => {
                    if (!order.includes(moduleId)) {
                        // 检查所有依赖是否都已处理
                        const dependencies = connectionLines
                            .filter(conn => conn.endModuleId === moduleId)
                            .map(conn => conn.startModuleId);
                        
                        const allDependenciesProcessed = dependencies.length === 0 || dependencies.every(depId => 
                            order.includes(depId)
                        );
                        
                        if (allDependenciesProcessed) {
                            // 检查模块是否是显示模块或缓存模块
                            const isDisplayModule = moduleStates[moduleId].moduleData.params.name === '显示模块';
                            const isCacheModule = moduleStates[moduleId].moduleData.params.name === '缓存模块';
                            const excitedByData = moduleStates[moduleId].moduleData.params.excitedbydata !== false;
                            
                            // 对于excitedbydata=true的模块，关键是：检查所有依赖模块是否都已经在order中了
                            // 依赖模块 = 连接到该模块的所有起始模块
                            const dependencyModuleIds = connectionLines
                                .filter(conn => conn.endModuleId === moduleId)
                                .map(conn => conn.startModuleId);
                            
                            // 确保所有依赖模块都已经在order中了（即都执行过了）
                            const allDependencyModulesProcessed = dependencyModuleIds.length === 0 || 
                                dependencyModuleIds.every(depId => order.includes(depId));
                            
                            // 对于excitedbydata=true的模块，必须等待所有依赖模块执行完毕
                            let readyToExecute = true;
                            if (excitedByData && !isDisplayModule && !isCacheModule) {
                                // 关键：必须所有依赖模块都已经执行完毕
                                readyToExecute = allDependencyModulesProcessed;
                            }
                            
                            if (!excitedByData || isDisplayModule || isCacheModule || readyToExecute) {
                                order.push(moduleId);
                                processed = true;
                            }
                        }
                    }
                });
                
                // 如果没有可处理的模块，说明存在循环依赖
                if (!processed) {
                    console.log('存在循环依赖，尝试处理循环依赖');
                    
                    // 尝试找到一个比大小模块作为循环的起点
                    let compareModuleId = null;
                    for (const moduleId of moduleIds) {
                        if (!order.includes(moduleId) && 
                            moduleStates[moduleId].moduleData.params.name === '比大小') {
                            compareModuleId = moduleId;
                            break;
                        }
                    }
                    
                    // 如果找到了比大小模块，将其加入执行顺序
                    if (compareModuleId) {
                        console.log('选择比大小模块作为循环起点:', compareModuleId);
                        order.push(compareModuleId);
                        processed = true;
                    } else {
                        // 尝试找到一个非缓存模块作为循环的起点
                        let nonCacheModuleId = null;
                        for (const moduleId of moduleIds) {
                            if (!order.includes(moduleId) && 
                                moduleStates[moduleId].moduleData.params.name !== '缓存模块') {
                                nonCacheModuleId = moduleId;
                                break;
                            }
                        }
                        
                        // 如果找到了非缓存模块，将其加入执行顺序
                        if (nonCacheModuleId) {
                            console.log('选择非缓存模块作为循环起点:', nonCacheModuleId);
                            order.push(nonCacheModuleId);
                            processed = true;
                        } else {
                            // 如果没有找到非缓存模块，选择第一个未处理的模块作为起点
                            for (const moduleId of moduleIds) {
                                if (!order.includes(moduleId)) {
                                    console.log('选择第一个未处理模块作为循环起点:', moduleId);
                                    order.push(moduleId);
                                    processed = true;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
            
            console.log('计算出的执行顺序:', order);
            return order;
        }
        
        // 执行模块
        async function executeModule(moduleId, options = {}) {
            const { setExecuted = true, transferData = true } = options;
            const moduleState = moduleStates[moduleId];
            if (!moduleState || moduleState.executing || (moduleState.executed && setExecuted)) {
                return;
            }
            
            console.log(`执行模块: ${moduleId} - ${moduleState.moduleData.params.name}`);
            
            // 设置执行状态
            moduleState.executing = true;
            
            // 模块开始执行，颜色变为绿色
            const moduleElement = document.querySelector(`.module[data-module-id="${moduleId}"]`);
            if (moduleElement) {
                moduleElement.style.backgroundColor = '#4CAF50';
                moduleElement.style.color = 'white';
            }
            
            try {
                // 边界场景校验：检查模块是否有必要的输入/输出端口
                const inputQuantity = moduleState.moduleData.params.input_quantity || 0;
                const outputQuantity = moduleState.moduleData.params.output_quantity || 0;
                const moduleKind = moduleState.moduleData.params.kind || '未知';
                const moduleName = moduleState.moduleData.params.name || '未知模块';
                
                // 1. 无输入端口的模块校验
                if (inputQuantity === 0) {
                    let isValidInputModule = false;
                    
                    // 输入模块应该无输入端口
                    if (moduleKind === '输入模块') {
                        isValidInputModule = true;
                    }
                    // excitedbydata=true的模块可以无输入端口
                    else if (moduleState.moduleData.params.excitedbydata === true) {
                        isValidInputModule = true;
                    }
                    // 特定模块例外
                    else if (moduleName === 'user输入' || 
                             moduleName === '固定值输出模块' ||
                             moduleName === '缓存模块') {
                        isValidInputModule = true;
                    }
                    
                    if (!isValidInputModule) {
                        console.warn(`模块 ${moduleId} (${moduleName}) 无输入端口，但不是输入模块或excitedbydata=true的模块，可能无法正常执行`);
                        // 显示警告通知
                        showNotification(`警告: 模块 ${moduleName} 无输入端口，可能无法正常执行`);
                    }
                }
                
                // 2. 无输出端口的模块校验
                if (outputQuantity === 0) {
                    let isValidOutputModule = false;
                    
                    // 输出模块应该无输出端口
                    if (moduleKind === '输出模块') {
                        isValidOutputModule = true;
                    }
                    // 特定模块例外
                    else if (moduleName === '显示模块' ||
                             moduleName === '对话输出') {
                        isValidOutputModule = true;
                    }
                    
                    if (!isValidOutputModule) {
                        console.warn(`模块 ${moduleId} (${moduleName}) 无输出端口，但不是输出模块，可能无法传递数据`);
                        // 显示警告通知
                        showNotification(`警告: 模块 ${moduleName} 无输出端口，可能无法传递数据`);
                    }
                }
                
                // 3. 输入模块应该无输入端口
                if (moduleKind === '输入模块' && inputQuantity > 0) {
                    console.warn(`模块 ${moduleId} (${moduleName}) 是输入模块，但有 ${inputQuantity} 个输入端口，不符合输入模块的定义`);
                    showNotification(`警告: 模块 ${moduleName} 是输入模块，但有输入端口，可能配置错误`);
                }
                
                // 4. 输出模块应该无输出端口
                if (moduleKind === '输出模块' && outputQuantity > 0) {
                    console.warn(`模块 ${moduleId} (${moduleName}) 是输出模块，但有 ${outputQuantity} 个输出端口，不符合输出模块的定义`);
                    showNotification(`警告: 模块 ${moduleName} 是输出模块，但有输出端口，可能配置错误`);
                }
                
                // 检查是否已经被停止
                if (!isRunning) {
                    console.log(`模块 ${moduleId} 执行被停止`);
                    moduleState.executing = false;
                    return;
                }
                
                // 获取输入数据
                const inputValues = [];
                for (let i = 0; i < inputQuantity; i++) {
                    inputValues.push(moduleState.inputValues[i] !== undefined ? moduleState.inputValues[i] : null);
                }
                console.log(`输入值: 模块=${moduleState.moduleData.params.name}, 值=${inputValues}, 类型=${inputValues.map(v => typeof v)}`);
                
                // 加载模块设置中的默认值
                const moduleKey = `module_settings_${moduleId}_${moduleState.moduleData.params.name || 'default'}`;
                const savedSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
                
                // 对于所有模块，应用设置中的默认值
                // 这样有助于自定义模块的开发使用，无需为每个模块单独添加代码
                if (Object.keys(savedSettings).length > 0) {
                    const variableNames = moduleState.moduleData.params.variables_name ? moduleState.moduleData.params.variables_name.split(',') : [];
                    variableNames.forEach((name, index) => {
                        if (savedSettings[name] !== undefined) {
                            if (index < inputQuantity) {
                                // 有输入端口，只在inputValues[index]是null或undefined时应用
                                if (inputValues[index] === null || inputValues[index] === undefined) {
                                    inputValues[index] = savedSettings[name];
                                    console.log(`应用默认值到输入端口: ${name} = ${savedSettings[name]}`);
                                }
                            } else {
                                // 没有输入端口，直接把值加到inputValues中
                                inputValues.push(savedSettings[name]);
                                console.log(`应用默认值到变量: ${name} = ${savedSettings[name]}`);
                            }
                        }
                    });
                }
                
                let outputValues = [];
                
                // 特殊处理不需要后端执行的模块
                if (moduleState.moduleData.params.name === 'user输入' || moduleState.moduleData.params.userinput === true) {
                    // 检查模块是否有输入框
                    const moduleElement = document.querySelector(`.module[data-module-id="${moduleId}"]`);
                    const moduleInput = moduleElement ? moduleElement.querySelector('.module-input') : null;
                    
                    // 获取输入值
                            let inputValue;
                            // 特殊处理固定值输出模块，确保它只输出自己的固定值
                            if (moduleState.moduleData.params.name === '固定值输出模块') {
                                // 从模块输入区域获取值，不使用对话面板的值
                                if (moduleInput) {
                                    inputValue = moduleInput.value || '';
                                    console.log(`从固定值模块输入框获取值:`, inputValue);
                                } else {
                                    const inputValueElement = moduleElement ? moduleElement.querySelector('.input-value') : null;
                                    if (inputValueElement) {
                                        inputValue = inputValueElement.textContent === '请输入固定值' ? '' : inputValueElement.textContent;
                                        console.log(`从固定值模块输入区域获取值:`, inputValue);
                                    } else {
                                        inputValue = '';
                                        console.log(`固定值模块输入区域不存在，使用空值`);
                                    }
                                }
                            } else if (runTrigger === 'button') {
                                // 通过运行按钮激活时，从模块输入区域获取值
                                if (moduleInput) {
                                    inputValue = moduleInput.value || '';
                                    console.log(`从模块输入框获取值:`, inputValue);
                                } else {
                                    const inputValueElement = moduleElement ? moduleElement.querySelector('.input-value') : null;
                                    if (inputValueElement) {
                                        inputValue = inputValueElement.textContent === '请输入固定值' ? '' : inputValueElement.textContent;
                                        console.log(`从模块输入区域获取值:`, inputValue);
                                    } else {
                                        inputValue = '';
                                        console.log(`模块输入区域不存在，使用空值`);
                                    }
                                }
                            } else if (runTrigger === 'chat') {
                                // 通过对话激活时，从对话面板获取值
                                inputValue = getUserInput();
                                console.log(`从对话面板获取值:`, inputValue);
                            } else {
                                // 默认从模块输入区域获取值
                                if (moduleInput) {
                                    inputValue = moduleInput.value || getUserInput();
                                } else {
                                    const inputValueElement = moduleElement ? moduleElement.querySelector('.input-value') : null;
                                    if (inputValueElement) {
                                        inputValue = inputValueElement.textContent === '请输入固定值' ? getUserInput() : inputValueElement.textContent;
                                    } else {
                                        inputValue = getUserInput();
                                    }
                                }
                                console.log(`默认获取输入值:`, inputValue);
                            }
                    
                    // 用户输入模块逻辑
                    outputValues = [inputValue];
                    console.log(`${moduleState.moduleData.params.name} 模块输出:`, outputValues);
                } else if (moduleState.moduleData.params.name === '对话输出') {
                    // 对话输出模块逻辑
                    const inputData = inputValues[0];
                    // 检查输入数据是否存在（包括0）
                    if (inputData !== undefined && inputData !== null) {
                        outputToChatPanel(inputData);
                    }
                    outputValues = [inputData];
                    console.log(`对话输出模块输出:`, outputValues);
                } else if (moduleState.moduleData.params.name === '显示模块') {
                    // 显示模块逻辑（与缓存模块一致）
                    const inputData = inputValues[0];
                    // 存储输入数据作为输出（与缓存模块行为一致）
                    outputValues = [inputData];
                    // 设置displayContent变量，与实际内容分离
                    moduleState.displayContent = inputData || '';
                    console.log(`显示模块输出:`, outputValues);
                    console.log(`显示模块displayContent:`, moduleState.displayContent);
                } else if (moduleState.moduleData.params.name === '缓存模块') {
                    // 缓存模块逻辑
                    const inputData = inputValues[0];
                    // 生成更高精度的时间戳（毫秒+微秒）
                    const now = Date.now();
                    const microseconds = Math.floor(Math.random() * 1000);
                    const currentTime = now * 1000 + microseconds;
                    
                    // 如果有输入数据，更新缓存
                    if (inputData !== undefined && inputData !== null) {
                        // 时序冲突处理：检查是否是最新的输入
                        if (!moduleState.lastUpdated || currentTime > moduleState.lastUpdated) {
                            outputValues = [inputData];
                            // 设置displayContent变量，与实际内容分离
                            moduleState.displayContent = inputData || '';
                            // 更新最后更新时间
                            moduleState.lastUpdated = currentTime;
                            console.log(`缓存模块更新:`, outputValues);
                            console.log(`缓存模块displayContent:`, moduleState.displayContent);
                        } else if (currentTime === moduleState.lastUpdated) {
                            // 时间戳相同的极端情况：保留当前数据，记录冲突
                            outputValues = moduleState.outputValues.length > 0 ? moduleState.outputValues : [null];
                            console.log(`缓存模块时间戳冲突，保持原有值:`, outputValues);
                        } else {
                            // 忽略旧数据，保持原有缓存
                            outputValues = moduleState.outputValues.length > 0 ? moduleState.outputValues : [null];
                            console.log(`缓存模块忽略旧数据，保持原有值:`, outputValues);
                        }
                    } else {
                        // 如果没有输入数据，保持原有缓存
                        outputValues = moduleState.outputValues.length > 0 ? moduleState.outputValues : [null];
                        // 保持displayContent不变
                        console.log(`缓存模块保持原有值:`, outputValues);
                    }
                } else {
                    // 其他模块通过后端API执行
                    const moduleName = moduleState.moduleData.name;
                    console.log(`调用后端API执行模块: ${moduleName}`, inputValues);
                    
                    // 生成唯一的请求ID
                    const requestId = `${moduleId}_${Date.now()}`;
                    // 创建AbortController
                    const controller = new AbortController();
                    const signal = controller.signal;
                    
                    // 存储控制器，以便稍后可以取消请求
                    ongoingRequests.set(requestId, controller);
                    
                    try {
                        // 构建完整的settings对象
                        let completeSettings = {...savedSettings};
                        // 如果是加载图像模块，从moduleState中读取imageData和maskData
                        if (moduleName === '加载图像模块' && moduleState.imageData) {
                            completeSettings.imageData = moduleState.imageData;
                        }
                        if (moduleName === '加载图像模块' && moduleState.maskData) {
                            completeSettings.maskData = moduleState.maskData;
                        }
                        
                        // 调用后端API
                        const response = await fetch('/api/execute_module', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                module_name: moduleName,
                                input_values: inputValues,
                                settings: completeSettings  // 传递完整设置参数
                            }),
                            signal: signal  // 传递信号
                        });
                    
                        if (!response.ok) {
                            throw new Error(`API调用失败: ${response.status}`);
                        }
                        
                        const result = await response.json();
                        if (result.error) {
                            throw new Error(`模块执行失败: ${result.error}`);
                        }
                        
                        // 处理返回结果
                        // 直接使用后端返回的结果数组
                        outputValues = result.result;
                        console.log(`后端返回结果:`, outputValues);
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            console.log(`请求已取消: ${requestId}`);
                            return;
                        }
                        throw error;
                    } finally {
                        // 无论成功还是失败，都从Map中移除控制器
                        ongoingRequests.delete(requestId);
                    }
                }
                
                // 存储输出值
                outputValues.forEach((value, index) => {
                    moduleState.outputValues[index] = value;
                    console.log(`存储输出值: 模块=${moduleState.moduleData.params.name}, 端口索引=${index}, 值=${value}, 类型=${typeof value}`);
                });
                
                // 确保输出数组长度与输出端口数量一致
                while (moduleState.outputValues.length < outputQuantity) {
                    moduleState.outputValues.push(null);
                }
                
                // 标记模块为已执行
                if (setExecuted) {
                    moduleState.executed = true;
                }
                moduleState.executing = false;
                
                // 模块执行完成，恢复原来的颜色
                if (moduleElement) {
                    moduleElement.style.backgroundColor = '';
                    moduleElement.style.color = '';
                }
                
                console.log(`模块执行完成: ${moduleId}`, outputValues);
                
                // 处理K采样器模块的"生成后控制"
                if (moduleState.moduleData.params.name === 'K采样器模块' && savedSettings) {
                    const seedControl = savedSettings['生成后控制'];
                    let currentSeed = savedSettings['种子'];
                    
                    console.log(`生成后控制: ${seedControl}, 当前种子: ${currentSeed}`);
                    
                    if (seedControl === 'randomize') {
                        // 随机生成新种子
                        currentSeed = Math.floor(Math.random() * 2147483647);
                    } else if (seedControl === 'increment') {
                        // 递增
                        if (typeof currentSeed === 'number' || !isNaN(parseInt(currentSeed))) {
                            currentSeed = parseInt(currentSeed) + 1;
                        } else {
                            currentSeed = 0;
                        }
                    } else if (seedControl === 'decrement') {
                        // 递减
                        if (typeof currentSeed === 'number' || !isNaN(parseInt(currentSeed))) {
                            currentSeed = parseInt(currentSeed) - 1;
                        } else {
                            currentSeed = 0;
                        }
                    }
                    // fixed模式不做任何操作
                    
                    // 更新savedSettings
                    savedSettings['种子'] = currentSeed;
                    console.log(`更新后的种子: ${currentSeed}`);
                    
                    // 更新到moduleStates
                    if (moduleId) {
                        const moduleStateInStates = moduleStates[moduleId];
                        if (moduleStateInStates && moduleStateInStates.settings) {
                            moduleStateInStates.settings['种子'] = currentSeed;
                        }
                        // 更新到sessionStorage
                        const moduleKey = `module_settings_${moduleId}_${moduleState.moduleData.params.name || 'default'}`;
                        const existingSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
                        existingSettings['种子'] = currentSeed;
                        sessionStorage.setItem(moduleKey, JSON.stringify(existingSettings));
                        console.log(`种子已保存到sessionStorage: ${currentSeed}`);
                    }
                }
                
                // 处理图片模块的显示
                if (moduleState.moduleData.params.name === '图片保存/显示模块' || moduleState.moduleData.params.name === '加载图像模块') {
                    // 图片保存/显示模块：从输入值获取图片
                    if (moduleState.moduleData.params.name === '图片保存/显示模块') {
                        const imageRef = inputValues[0];
                        if (imageRef && (imageRef.startsWith('IMAGE_REF:') || imageRef.startsWith('IMAGE_LIST_REF:'))) {
                            // 获取图片base64
                            const refId = imageRef.split(':')[1];
                            try {
                                const response = await fetch(`/api/get_image_base64?image_ref=${encodeURIComponent(refId)}`);
                                const data = await response.json();
                                if (data.success) {
                                    moduleState.imageBase64 = data.image_base64;
                                    updateModuleDisplay(moduleId);
                                }
                            } catch (err) {
                                console.error('获取图片失败:', err);
                            }
                        }
                    }
                    // 加载图像模块：从savedSettings获取图片
                    else if (moduleState.moduleData.params.name === '加载图像模块') {
                        if (savedSettings && savedSettings.imageData) {
                            moduleState.imageBase64 = savedSettings.imageData;
                            updateModuleDisplay(moduleId);
                        }
                    }
                }
                
                // 传输数据到连接的模块
                if (transferData) {
                    console.log(`开始传输数据: ${moduleId}`);
                    await transferDataFunc(moduleId);
                }
                
            } catch (error) {
                console.error(`模块执行错误: ${moduleId}`, error);
                moduleState.executing = false;
                
                // 模块执行出错，恢复原来的颜色
                if (moduleElement) {
                    moduleElement.style.backgroundColor = '';
                    moduleElement.style.color = '';
                }
            }
        }
        
        // 传输数据到连接的模块
        async function transferDataFunc(moduleId) {
            const moduleState = moduleStates[moduleId];
            if (!moduleState) return;
            
            console.log(`开始传输数据: 模块=${moduleId}, 模块名称=${moduleState.moduleData.params.name}, 输出值=${moduleState.outputValues}`);
            
            // 查找从当前模块出发的所有连线
            const outgoingConnections = connectionLines.filter(conn => 
                conn.startModuleId === moduleId
            );
            
            console.log(`传输数据: 模块=${moduleId}, 连线数量=${outgoingConnections.length}`);
            
            // 处理每条连线的数据传输
            for (const connection of outgoingConnections) {
                const { endModuleId, startPortIndex, endPortIndex, isRed } = connection;
                const endModuleState = moduleStates[endModuleId];
                
                if (!endModuleState) {
                    console.log(`目标模块不存在: ${endModuleId}`);
                    continue;
                }
                
                console.log(`处理连线: 开始端口索引=${startPortIndex}, 结束端口索引=${endPortIndex}, 目标模块名称=${endModuleState.moduleData.params.name}`);
                
                try {
                    // 获取输出值
                    const outputValue = moduleState.outputValues[startPortIndex];
                    console.log(`获取输出值: 端口索引=${startPortIndex}, 值=${outputValue}, 类型=${typeof outputValue}`);
                    
                    // 只有当输出值不是None时才传输数据
                    if (outputValue !== undefined && outputValue !== null) {
                        // 添加传输动画
                        if (connection.line) {
                            connection.line.classList.add('transferring');
                        }
                        
                        // 处理多连一场景：实现数据合并和冲突提示
                        if (endModuleState.inputValues[endPortIndex] !== undefined && endModuleState.inputValues[endPortIndex] !== null) {
                            const existingValue = endModuleState.inputValues[endPortIndex];
                            console.log(`多连一场景: 目标端口已有值=${existingValue}, 新值=${outputValue}`);
                            
                            // 检查是否需要合并数据
                            if (Array.isArray(existingValue) && !Array.isArray(outputValue)) {
                                // 现有值是数组，新值不是数组，添加到数组
                                existingValue.push(outputValue);
                                endModuleState.inputValues[endPortIndex] = existingValue;
                                console.log(`多连一场景: 合并数据到数组`, existingValue);
                            } else if (Array.isArray(existingValue) && Array.isArray(outputValue)) {
                                // 两者都是数组，合并数组
                                const mergedArray = [...existingValue, ...outputValue];
                                endModuleState.inputValues[endPortIndex] = mergedArray;
                                console.log(`多连一场景: 合并两个数组`, mergedArray);
                            } else if (typeof existingValue === 'string' && typeof outputValue === 'string') {
                                // 两者都是字符串，拼接
                                const mergedString = existingValue + '\n' + outputValue;
                                endModuleState.inputValues[endPortIndex] = mergedString;
                                console.log(`多连一场景: 拼接字符串`, mergedString);
                            } else {
                                // 其他情况，使用最后接收到的值
                                endModuleState.inputValues[endPortIndex] = outputValue;
                                console.log(`多连一场景: 使用最后接收到的值`, outputValue);
                            }
                            
                            // 显示多输入冲突提示
                            showNotification(`模块 ${endModuleId} 的端口 ${endPortIndex} 接收到多个输入，已处理`);
                        } else {
                            // 首次输入，直接赋值
                            endModuleState.inputValues[endPortIndex] = outputValue;
                        }
                        console.log(`数据传输完成: ${moduleId} -> ${endModuleId}, 端口索引: ${endPortIndex}, 值: ${outputValue}, 类型: ${typeof outputValue}`);
                        
                        connection.data = outputValue;
                        connection.transferred = true;
                        
                        console.log(`数据传输完成: ${moduleId} -> ${endModuleId}, 端口索引: ${endPortIndex}, 值: ${endModuleState.inputValues[endPortIndex]}, 类型: ${typeof endModuleState.inputValues[endPortIndex]}`);
                        console.log(`目标模块输入值: ${endModuleState.inputValues}`);
                        
                        // 延迟移除传输动画
                        setTimeout(() => {
                            if (connection.line) {
                                connection.line.classList.remove('transferring');
                            }
                        }, 1000);
                    } else {
                        console.log(`跳过传输: 输出值为undefined或null, 端口索引=${startPortIndex}`);
                    }
                    
                    // 如果是红线，激活目标模块
                    if (isRed) {
                        console.log(`红线激活目标模块: ${endModuleId}`);
                        
                        // 对于 excitedbydata=true 的模块，先检查所有输入是否都已就绪
                        if (endModuleState.moduleData.params.excitedbydata === true) {
                            const inputQuantity = endModuleState.moduleData.params.input_quantity || 0;
                            let allInputsReady = true;
                            
                            for (let i = 0; i < inputQuantity; i++) {
                                if (endModuleState.inputValues[i] === undefined || endModuleState.inputValues[i] === null) {
                                    allInputsReady = false;
                                    console.log(`模块 ${endModuleId} 输入 ${i} 未就绪`);
                                    break;
                                }
                            }
                            
                            if (!allInputsReady) {
                                console.log(`模块 ${endModuleId} 输入未全部就绪，暂不执行`);
                            } else {
                                console.log(`模块 ${endModuleId} 所有输入已就绪，开始执行`);
                                // 检查目标模块是否有延迟
                                let timeLate = endModuleState.moduleData.params.time_late;
                                // 非数字输入处理
                                if (timeLate === undefined || timeLate === null) {
                                    timeLate = 0;
                                    console.log(`延迟步数为undefined或null，设为默认值0`);
                                } else if (typeof timeLate !== 'number') {
                                    // 尝试转换为数字
                                    const parsedTimeLate = parseInt(timeLate);
                                    if (isNaN(parsedTimeLate)) {
                                        timeLate = 0;
                                        console.log(`延迟步数不是数字，设为默认值0`);
                                    } else {
                                        timeLate = parsedTimeLate;
                                        console.log(`延迟步数转换为数字: ${timeLate}`);
                                    }
                                }
                                // 数值范围校验
                                const validTimeLate = Number.isInteger(timeLate) && timeLate >= 0;
                                const hasDelay = validTimeLate && timeLate > 0;
                                
                                if (!hasDelay) {
                                    // 无延迟模块，立即执行
                                    console.log(`立即执行目标模块: ${endModuleId}`);
                                    await executeModule(endModuleId);
                                } else {
                                    // 有延迟模块，等待后执行
                                    console.log(`延迟执行目标模块: ${endModuleId}, 延迟步数: ${timeLate}`);
                                    // 延迟时间 = 延迟步数 * 1000ms（每步1秒）
                                    const delayTime = timeLate * 1000;
                                    
                                    // 创建延迟任务对象
                                    const delayTask = {
                                        moduleId: endModuleId,
                                        delayTime: delayTime,
                                        startTime: Date.now(),
                                        timer: setTimeout(async () => {
                                            // 执行前检查是否正在运行
                                            if (isRunning) {
                                                await executeModule(endModuleId);
                                            }
                                            // 从队列中移除任务
                                            pendingDelayTasks = pendingDelayTasks.filter(task => task !== delayTask);
                                        }, delayTime)
                                    };
                                    
                                    // 添加到延迟任务队列
                                    pendingDelayTasks.push(delayTask);
                                }
                            }
                        } else {
                            // 非 excitedbydata 模块，直接执行
                            // 检查目标模块是否有延迟
                            let timeLate = endModuleState.moduleData.params.time_late;
                            // 非数字输入处理
                            if (timeLate === undefined || timeLate === null) {
                                timeLate = 0;
                                console.log(`延迟步数为undefined或null，设为默认值0`);
                            } else if (typeof timeLate !== 'number') {
                                // 尝试转换为数字
                                const parsedTimeLate = parseInt(timeLate);
                                if (isNaN(parsedTimeLate)) {
                                    timeLate = 0;
                                    console.log(`延迟步数不是数字，设为默认值0`);
                                } else {
                                    timeLate = parsedTimeLate;
                                    console.log(`延迟步数转换为数字: ${timeLate}`);
                                }
                            }
                            // 数值范围校验
                            const validTimeLate = Number.isInteger(timeLate) && timeLate >= 0;
                            const hasDelay = validTimeLate && timeLate > 0;
                            
                            if (!hasDelay) {
                                // 无延迟模块，立即执行
                                console.log(`立即执行目标模块: ${endModuleId}`);
                                await executeModule(endModuleId);
                            } else {
                                // 有延迟模块，等待后执行
                                console.log(`延迟执行目标模块: ${endModuleId}, 延迟步数: ${timeLate}`);
                                // 延迟时间 = 延迟步数 * 1000ms（每步1秒）
                                const delayTime = timeLate * 1000;
                                
                                // 创建延迟任务对象
                                const delayTask = {
                                    moduleId: endModuleId,
                                    delayTime: delayTime,
                                    startTime: Date.now(),
                                    timer: setTimeout(async () => {
                                        // 执行前检查是否已暂停
                                        if (isRunning) {
                                            await executeModule(endModuleId);
                                        }
                                        // 从队列中移除任务
                                        pendingDelayTasks = pendingDelayTasks.filter(task => task !== delayTask);
                                    }, delayTime)
                                };
                                
                                // 添加到延迟任务队列
                                pendingDelayTasks.push(delayTask);
                            }
                        }
                    }
                } catch (error) {
                    console.error(`数据传输错误: ${moduleId} -> ${endModuleId}, 错误: ${error.message}`);
                    // 错误处理：继续处理其他连线，不中断整个传输过程
                }
            }
        }
        
        // 执行一个步进
        async function executeStep() {
            console.log(`开始执行步进: ${currentStep}`);
            
            // 重置所有模块的执行状态，包括缓存模块
            for (const moduleId in moduleStates) {
                if (moduleStates.hasOwnProperty(moduleId)) {
                    const moduleState = moduleStates[moduleId];
                    moduleState.executed = false;
                    moduleState.executing = false;
                    
                    // 重置模块颜色
                    const moduleElement = document.querySelector('.module[data-module-id="' + moduleId + '"]');
                    if (moduleElement) {
                        moduleElement.style.backgroundColor = '';
                        moduleElement.style.color = '';
                    }
                }
            }
            
            // 重置连线传输状态
            connectionLines.forEach(connection => {
                connection.transferred = false;
                // 移除之前的运行状态标记
                removeRunStatusMarker(connection);
            });
            
            // 1. 清空所有显示模块
            console.log('清空所有显示模块');
            Object.keys(moduleStates).forEach(moduleId => {
                const moduleState = moduleStates[moduleId];
                if (moduleState.moduleData.params.name === '显示模块') {
                    // 清空显示模块的输出值
                    moduleState.outputValues = [];
                    // 清空显示模块的displayContent
                    moduleState.displayContent = '';
                    // 更新显示
                    updateModuleDisplay(moduleId);
                    console.log(`清空显示模块: ${moduleId}`);
                }
            });
            
            // 2. 固定值输出模块优先输出（只给下一个模块的端口，不运行下一个模块）
            console.log('固定值输出模块优先输出阶段');
            for (const moduleId of Object.keys(moduleStates)) {
                const moduleState = moduleStates[moduleId];
                if (moduleState.moduleData.params.name === '固定值输出模块') {
                    // 执行固定值输出模块，获取输出值
                    console.log(`执行固定值输出模块: ${moduleId}, 输入值: ${moduleState.inputValues}`);
                    await executeModule(moduleId, { setExecuted: false, transferData: false });
                    updateModuleDisplay(moduleId);
                    console.log(`固定值输出模块执行完成: ${moduleId}, 输出值: ${moduleState.outputValues}`);
                    
                    // 传输输出值到下一个模块的端口，但不运行下一个模块
                    const outgoingConnections = connectionLines.filter(conn => 
                        conn.startModuleId === moduleId
                    );
                    
                    outgoingConnections.forEach(connection => {
                        const { endModuleId, startPortIndex, endPortIndex } = connection;
                        const endModuleState = moduleStates[endModuleId];
                        
                        if (endModuleState) {
                            // 获取输出值
                            const outputValue = moduleState.outputValues[startPortIndex];
                            console.log(`固定值输出模块输出值: 端口索引=${startPortIndex}, 值=${outputValue}, 类型=${typeof outputValue}`);
                            
                            // 只有当输出值不是None时才传输数据
                            if (outputValue !== undefined && outputValue !== null) {
                                // 添加传输动画
                                if (connection.line) {
                                    connection.line.classList.add('transferring');
                                }
                                
                                // 检查下一个模块是否为输出模块
                                if (endModuleState.moduleData.params.kind !== '输出模块') {
                                    // 存储到目标模块的输入值
                                    endModuleState.inputValues[endPortIndex] = outputValue;
                                    connection.data = outputValue;
                                    connection.transferred = true;
                                    
                                    console.log(`固定值输出模块数据传输完成: ${moduleId} -> ${endModuleId}, 端口索引: ${endPortIndex}, 值: ${outputValue}, 类型: ${typeof outputValue}`);
                                    console.log(`目标模块输入值: ${endModuleState.inputValues}`);
                                    
                                    // 延迟移除传输动画
                                    setTimeout(() => {
                                        if (connection.line) {
                                            connection.line.classList.remove('transferring');
                                        }
                                    }, 1000);
                                    

                                } else {
                                    console.log(`跳过传输: 目标模块为输出模块, ${endModuleId}`);
                                }
                            } else {
                                console.log(`跳过传输: 输出值为undefined或null, 端口索引=${startPortIndex}`);
                            }
                        }
                    });
                }
            }
            
            // 3. 缓存模块输出（只给下一个模块的端口，不运行下一个模块）
            console.log('缓存模块输出阶段');
            for (const moduleId of Object.keys(moduleStates)) {
                const moduleState = moduleStates[moduleId];
                if (moduleState.moduleData.params.name === '缓存模块') {
                    // 执行缓存模块，获取输出值
                    console.log(`执行缓存模块: ${moduleId}, 输入值: ${moduleState.inputValues}`);
                    await executeModule(moduleId, { setExecuted: false, transferData: false });
                    updateModuleDisplay(moduleId);
                    console.log(`缓存模块执行完成: ${moduleId}, 输出值: ${moduleState.outputValues}`);
                    console.log(`缓存模块displayContent: ${moduleState.displayContent}`);
                    
                    // 传输输出值到下一个模块的端口，但不运行下一个模块
                    const outgoingConnections = connectionLines.filter(conn => 
                        conn.startModuleId === moduleId
                    );
                    
                    outgoingConnections.forEach(connection => {
                        const { endModuleId, startPortIndex, endPortIndex } = connection;
                        const endModuleState = moduleStates[endModuleId];
                        
                        if (endModuleState) {
                            // 获取输出值
                            const outputValue = moduleState.outputValues[startPortIndex];
                            console.log(`缓存模块输出值: 端口索引=${startPortIndex}, 值=${outputValue}, 类型=${typeof outputValue}`);
                            
                            // 只有当输出值不是None时才传输数据
                            if (outputValue !== undefined && outputValue !== null) {
                                // 添加传输动画
                                if (connection.line) {
                                    connection.line.classList.add('transferring');
                                }
                                
                                // 检查下一个模块是否为输出模块
                                if (endModuleState.moduleData.params.kind !== '输出模块') {
                                    // 存储到目标模块的输入值
                                    endModuleState.inputValues[endPortIndex] = outputValue;
                                    connection.data = outputValue;
                                    connection.transferred = true;
                                    
                                    console.log(`缓存模块数据传输完成: ${moduleId} -> ${endModuleId}, 端口索引: ${endPortIndex}, 值: ${outputValue}, 类型: ${typeof outputValue}`);
                                    console.log(`目标模块输入值: ${endModuleState.inputValues}`);
                                    
                                    // 延迟移除传输动画
                                    setTimeout(() => {
                                        if (connection.line) {
                                            connection.line.classList.remove('transferring');
                                        }
                                    }, 1000);
                                    

                                } else {
                                    console.log(`跳过传输: 目标模块为输出模块, ${endModuleId}`);
                                }
                            } else {
                                console.log(`跳过传输: 输出值为undefined或null, 端口索引=${startPortIndex}`);
                            }
                        }
                    });
                }
            }
            
            // 3. 计算执行顺序
            const executionOrder = calculateExecutionOrder();
            console.log('执行顺序:', executionOrder);
            
            // 执行所有模块（包括缓存模块）按照计算出的顺序
            for (const moduleId of executionOrder) {
                const moduleState = moduleStates[moduleId];
                console.log(`执行模块: ${moduleId}, 名称: ${moduleState.moduleData.params.name}, 输入值: ${moduleState.inputValues}`);
                await executeModule(moduleId);
                updateModuleDisplay(moduleId);
                console.log(`模块执行完成: ${moduleId}, 输出值: ${moduleState.outputValues}`);
            }
            
            // 显示连线运行状态
            connectionLines.forEach(connection => {
                if (connection.transferred) {
                    addRunStatusMarker(connection);
                }
            });
            
            // 检查是否需要停止（对话输出模块接收到内容）
            const dialogueOutputModules = Object.keys(moduleStates).filter(moduleId => {
                return moduleStates[moduleId].moduleData.params.name === '对话输出';
            });
            
            console.log('检查对话输出模块:', dialogueOutputModules);
            
            // 检查比大小模块的输出
            const compareModules = Object.keys(moduleStates).filter(moduleId => {
                return moduleStates[moduleId].moduleData.params.name === '比大小';
            });
            
            for (const moduleId of compareModules) {
                const moduleState = moduleStates[moduleId];
                console.log('比大小模块状态:', moduleState);
                console.log('比大小模块输出值:', moduleState.outputValues);
            }
            
            let shouldStop = false;
            for (const moduleId of dialogueOutputModules) {
                const moduleState = moduleStates[moduleId];
                console.log('对话输出模块状态:', moduleState);
                console.log('对话输出模块输入值:', moduleState.inputValues);
                console.log('对话输出模块输出值:', moduleState.outputValues);
                
                // 检查输入数据是否存在（包括0）
                if (moduleState.inputValues[0] !== undefined && moduleState.inputValues[0] !== null) {
                    console.log('对话输出模块接收到内容，停止运行:', moduleState.inputValues[0]);
                    showNotification('对话输出模块接收到内容，停止运行');
                    shouldStop = true;
                    break;
                } else {
                    console.log('对话输出模块未接收到内容或内容为undefined/null:', moduleState.inputValues[0]);
                }
            }
            
            // 检查是否存在循环依赖导致的无限执行
            if (!shouldStop) {
                // 检查是否所有模块都已执行
                const allModulesExecuted = Object.values(moduleStates).every(moduleState => moduleState.executed);
                
                // 检查是否所有数据都已传输
                const allDataTransferred = connectionLines.every(connection => connection.transferred);
                
                // 检查是否有输出模块接收到内容
                const outputModulesWithContent = Object.keys(moduleStates).filter(moduleId => {
                    const moduleState = moduleStates[moduleId];
                    return moduleState.moduleData.params.kind === '输出模块' && 
                           moduleState.inputValues.some(value => value !== undefined && value !== null);
                });
                
                console.log('检查执行状态: 所有模块已执行=', allModulesExecuted, '所有数据已传输=', allDataTransferred, '输出模块有内容=', outputModulesWithContent.length > 0);
                
                // 如果所有模块都已执行，所有数据都已传输，且有输出模块接收到内容，则停止运行
                if (allModulesExecuted && allDataTransferred && outputModulesWithContent.length > 0) {
                    console.log('所有模块执行完成，数据传输完成，且有输出模块接收到内容，停止运行');
                    showNotification('所有模块执行完成，停止运行');
                    shouldStop = true;
                }
            }
            
            // 只有在确定需要停止时才调用stopExecution
            if (shouldStop) {
                stopExecution();
            }
            
            currentStep++;
            console.log(`步进执行完成: ${currentStep - 1}`);
        }
        
        // 添加运行状态标记
        function addRunStatusMarker(connection) {
            // 检查是否已经有标记
            if (connection.statusMarker) {
                // 更新现有标记位置
                updateRunStatusMarker(connection);
                return;
            }
            
            // 创建标记元素
            const marker = document.createElement('div');
            marker.className = 'run-status-marker';
            marker.style.position = 'absolute';
            marker.style.width = '10px';
            marker.style.height = '10px';
            marker.style.backgroundColor = 'yellow';
            marker.style.borderRadius = '50%';
            marker.style.zIndex = '1001';
            marker.style.transform = 'translate(-50%, -50%)';
            marker.style.pointerEvents = 'none'; // 避免干扰鼠标事件
            
            // 计算标记位置（连线中间）
            const startPos = getPortPosition(connection.startPort);
            const endPos = getPortPosition(connection.endPort);
            const midX = (startPos.x + endPos.x) / 2;
            const midY = (startPos.y + endPos.y) / 2;
            
            // 考虑画布的缩放和偏移，确保标记位置正确
            marker.style.left = `${midX}px`;
            marker.style.top = `${midY}px`;
            
            // 添加到画布
            canvasContent.appendChild(marker);
            connection.statusMarker = marker;
        }
        
        // 更新运行状态标记位置
        function updateRunStatusMarker(connection) {
            if (!connection.statusMarker) {
                return;
            }
            
            try {
                // 计算标记位置（连线中间）
                const startPos = getPortPosition(connection.startPort);
                const endPos = getPortPosition(connection.endPort);
                const midX = (startPos.x + endPos.x) / 2;
                const midY = (startPos.y + endPos.y) / 2;
                
                // 考虑画布的缩放和偏移，确保标记位置正确
                // 获取当前缩放比例
                const zoomLevel = window.getCurrentZoomLevel ? window.getCurrentZoomLevel() : 100;
                const scale = zoomLevel / 100;
                
                // 应用缩放和偏移，确保标记位置正确
                connection.statusMarker.style.left = `${midX}px`;
                connection.statusMarker.style.top = `${midY}px`;
                
                // 确保标记在极端缩放比例下也能正确显示
                connection.statusMarker.style.transform = 'translate(-50%, -50%)';
                connection.statusMarker.style.zIndex = '1001';
            } catch (error) {
                console.error('更新运行状态标记位置失败:', error);
                // 如果更新失败，移除标记
                removeRunStatusMarker(connection);
            }
        }
        
        // 移除运行状态标记
        function removeRunStatusMarker(connection) {
            if (connection.statusMarker) {
                try {
                    connection.statusMarker.remove();
                } catch (error) {
                    console.error('移除运行状态标记失败:', error);
                }
                connection.statusMarker = null;
            }
        }
        
        // 同步所有连线状态标记
        function syncAllRunStatusMarkers() {
            connectionLines.forEach(connection => {
                if (connection.statusMarker) {
                    updateRunStatusMarker(connection);
                }
            });
        }
        
        // 更新模块显示
        function updateModuleDisplay(moduleId) {
            const moduleState = moduleStates[moduleId];
            if (!moduleState) return;
            
            // 查找对应的DOM元素
            const moduleElement = document.querySelector(`.module[data-module-id="${moduleId}"]`);
            if (!moduleElement) return;
            
            // 更新缓存模块的显示框
            if (moduleState.moduleData.params.name === '缓存模块') {
                const showingWindow = moduleElement.querySelector('.showing-window');
                if (showingWindow) {
                    const contentSpan = showingWindow.querySelector('.window-content');
                    
                    const displayContent = moduleState.displayContent !== undefined && moduleState.displayContent !== null ? moduleState.displayContent : '';
                    const shortDisplayContent = displayContent.toString().length > 10 ? displayContent.toString().substring(0, 10) + '...' : displayContent;
                    
                    contentSpan.textContent = `缓存内容: ${shortDisplayContent}`;
                }
            } else if (moduleState.moduleData.params.name === '显示模块') {
                // 更新显示模块的显示框
                const showingWindow = moduleElement.querySelector('.showing-window');
                if (showingWindow) {
                    const contentSpan = showingWindow.querySelector('.window-content');
                    
                    const displayContent = moduleState.displayContent !== undefined && moduleState.displayContent !== null ? moduleState.displayContent : '';
                    const shortDisplayContent = displayContent.toString().length > 10 ? displayContent.toString().substring(0, 10) + '...' : displayContent;
                    
                    contentSpan.textContent = `显示内容: ${shortDisplayContent}`;
                }
            } else if (moduleState.moduleData.params.name === '图片保存/显示模块' || moduleState.moduleData.params.name === '加载图像模块') {
                // 更新图片模块的显示框
                const showingWindow = moduleElement.querySelector('.showing-window');
                if (showingWindow) {
                    // 如果有图片数据，显示图片
                    if (moduleState.imageBase64) {
                        if (moduleState.moduleData.params.name === '加载图像模块' && moduleState.maskData) {
                            // 显示图像和遮罩的叠加效果，只在蒙版白色部分显示半透明灰色
                            showingWindow.innerHTML = `
                                <div style="position: relative; width: 100%; height: auto;">
                                    <img src="${moduleState.imageBase64}" style="width: 100%; height: auto; display: block;">
                                    <div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: url('${moduleState.maskData}'); background-size: 100% 100%; background-position: center; background-repeat: no-repeat; mix-blend-mode: overlay; opacity: 0.5;"></div>
                                </div>
                            `;
                        } else {
                            // 普通图片显示
                            showingWindow.innerHTML = `<img src="${moduleState.imageBase64}" style="width: 100%; height: auto; display: block;">`;
                        }
                    } else {
                        showingWindow.innerHTML = '<span style="color: #999; display: block; padding: 5px;">暂无图片</span>';
                    }
                }
            }
        }
        
        // 显示通知
        function showNotification(message) {
            // 创建通知元素
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.style.position = 'fixed';
            notification.style.top = '20px';
            notification.style.right = '20px';
            notification.style.backgroundColor = '#333';
            notification.style.color = 'white';
            notification.style.padding = '10px 15px';
            notification.style.borderRadius = '4px';
            notification.style.zIndex = '3000';
            notification.style.boxShadow = '0 2px 4px rgba(0,0,0,0.2)';
            notification.textContent = message;
            
            // 添加到文档
            document.body.appendChild(notification);
            
            // 3秒后移除
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transition = 'opacity 0.5s';
                setTimeout(() => {
                    notification.remove();
                }, 500);
            }, 3000);
        }
        
        // 自动运行
        function startAutoRun() {
            if (isRunning) return;
            
            isRunning = true;
            console.log('开始运行');
            
            // 清除之前的定时器
            if (executionTimer) {
                clearInterval(executionTimer);
                executionTimer = null;
            }
            
            // 只执行一次步进
            executeStep().then(() => {
                // 执行完成后自动停止
                console.log('运行完成');
                stopExecution();
            });
        }
        
        // 停止运行
        async function stopExecution() {
            // 先调用后端API停止执行
            try {
                await fetch('/api/stop_execution', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });
                console.log('已向后端发送停止信号');
            } catch (error) {
                console.log('调用停止API失败:', error);
            }
            
            isRunning = false;
            currentStep = 0;
            
            if (executionTimer) {
                clearInterval(executionTimer);
                executionTimer = null;
            }
            
            // 清除所有未完成的延迟任务
            console.log('停止时清除延迟任务:', pendingDelayTasks.length, '个任务');
            pendingDelayTasks.forEach(task => {
                if (task.timer) {
                    clearTimeout(task.timer);
                }
            });
            pendingDelayTasks = [];
            
            // 取消所有正在进行的API请求
            ongoingRequests.forEach((controller, requestId) => {
                controller.abort();
                console.log(`取消请求: ${requestId}`);
            });
            ongoingRequests.clear();
            
            // 重置模块执行状态
            for (const moduleId in moduleStates) {
                if (moduleStates.hasOwnProperty(moduleId)) {
                    const moduleState = moduleStates[moduleId];
                    moduleState.executed = false;
                    moduleState.executing = false;
                    
                    // 重置模块颜色
                    const moduleElement = document.querySelector('.module[data-module-id="' + moduleId + '"]');
                    if (moduleElement) {
                        moduleElement.style.backgroundColor = '';
                        moduleElement.style.color = '';
                    }
                }
            }
            
            // 重置连线传输状态
            connectionLines.forEach(connection => {
                connection.transferred = false;
                // 移除之前的运行状态标记
                removeRunStatusMarker(connection);
            });
            
            // 清空端口变量，明确清空范围
            Object.values(moduleStates).forEach(state => {
                // 明确需要清空的变量：只清空业务数据变量
                // 1. 清空输入值（业务数据）
                state.inputValues = state.inputValues.map(() => null);
                
                // 2. 清空输出值（业务数据），但保留缓存模块的缓存值
                if (state.moduleData.params.name !== '缓存模块') {
                    state.outputValues = state.outputValues.map(() => null);
                } else {
                    // 缓存模块保留缓存值
                    console.log(`保留缓存模块 ${state.moduleData.params.name} 的缓存值`);
                }
                
                // 3. 保留显示内容（UI展示数据）
                // 对于显示模块和缓存模块，不清空displayContent，保持显示内容
                if (state.moduleData.params.name !== '显示模块' && state.moduleData.params.name !== '缓存模块') {
                    state.displayContent = '';
                } else {
                    console.log(`保留 ${state.moduleData.params.name} 的显示内容`);
                }
                
                // 4. 保留基础配置变量（模块属性）
                // 模块的基础配置（如坐标、类型、端口数量等）已经存储在moduleData中，不需要清空
                // 这些值不会在运行过程中改变，清空它们会导致模块配置丢失
                console.log(`保留模块 ${state.moduleData.params.name} 的基础配置`);
            });
            
            console.log('停止运行，重置所有状态');
            
            // 检查是否需要继续连续运行
            if (isContinuousRunning) {
                onRunComplete();
            }
        }
        
        // 保存连续运行设置
        function saveContinuousRunSettings() {
            const countInput = document.getElementById('continuous-run-count');
            continuousRunCount = parseInt(countInput.value) || 1;
            continuousRunCount = Math.max(1, Math.min(100, continuousRunCount));
            
            document.getElementById('continuous-run-modal').style.display = 'none';
            startContinuousRun();
        }
        
        // 开始连续运行
        function startContinuousRun() {
            isContinuousRunning = true;
            currentRunIndex = 1;
            console.log(`开始连续运行，共 ${continuousRunCount} 次`);
            
            // 开始第一次运行
            console.log(`开始第 1 次运行，共 ${continuousRunCount} 次`);
            resetAndRun();
        }
        
        // 重置状态并运行
        function resetAndRun() {
            // 重置模块执行状态
            for (const moduleId in moduleStates) {
                if (moduleStates.hasOwnProperty(moduleId)) {
                    const moduleState = moduleStates[moduleId];
                    moduleState.executed = false;
                    moduleState.executing = false;
                    
                    // 重置模块颜色
                    const moduleElement = document.querySelector('.module[data-module-id="' + moduleId + '"]');
                    if (moduleElement) {
                        moduleElement.style.backgroundColor = '';
                        moduleElement.style.color = '';
                    }
                }
            }
            
            // 重置连线传输状态
            connectionLines.forEach(connection => {
                connection.transferred = false;
            });
            
            // 重置下一次运行触发标志
            hasTriggeredNextRun = false;
            
            // 开始运行
            startAutoRun();
        }
        
        // 运行下一次迭代
        function runNextIteration() {
            if (!isContinuousRunning) {
                console.log('连续运行已停止');
                currentRunIndex = 0;
                return;
            }
            
            currentRunIndex++;
            
            if (currentRunIndex > continuousRunCount) {
                console.log('连续运行完成');
                isContinuousRunning = false;
                currentRunIndex = 0;
                return;
            }
            
            console.log(`开始第 ${currentRunIndex} 次运行，共 ${continuousRunCount} 次`);
            resetAndRun();
        }
        
        // 运行完成后的回调函数
        function onRunComplete() {
            if (isContinuousRunning && !hasTriggeredNextRun) {
                hasTriggeredNextRun = true;
                console.log(`第 ${currentRunIndex} 次运行完成`);
                // 延迟一段时间后开始下一次运行，避免系统过载
                setTimeout(runNextIteration, 500);
            }
        }
        
        // 执行单个步进
        function executeSingleStep() {
            if (isRunning) return;
            
            executeStep();
        }
        
        // 加载模块
        async function loadModules() {
            try {
                const response = await fetch('/api/modules');
                if (!response.ok) {
                    throw new Error(`加载模块失败: ${response.status}`);
                }
                const data = await response.json();
                
                // 处理同名模块优先级：默认模块优先于自定义模块
                // 但保留从.aiud文件中加载的自定义模块（如果默认模块中不存在）
                const mergedModules = { ...data };
                const conflictModules = [];
                
                // 保留从.aiud文件中加载的自定义模块
                for (const [name, params] of Object.entries(modules)) {
                    if (params.source === 'custom') {
                        if (!mergedModules[name]) {
                            mergedModules[name] = params;
                        } else {
                            // 检测到模块冲突
                            const existingModule = mergedModules[name];
                            conflictModules.push({
                                name: name,
                                existingSource: existingModule.source || '默认模块',
                                newSource: params.source || '自定义模块'
                            });
                            console.log(`模块冲突: ${name} - 现有: ${existingModule.source}, 新: ${params.source}`);
                        }
                    }
                }
                
                // 显示模块冲突提示
                if (conflictModules.length > 0) {
                    let conflictMessage = '检测到模块冲突:\n';
                    conflictModules.forEach(conflict => {
                        conflictMessage += `- ${conflict.name}: ${conflict.existingSource} 优先于 ${conflict.newSource}\n`;
                    });
                    showNotification(conflictMessage);
                }
                
                // 检查是否有模块更新
                const hasModuleChanges = JSON.stringify(modules) !== JSON.stringify(mergedModules);
                
                modules = mergedModules;
                renderModules();
                
                if (hasModuleChanges) {
                    console.log('模块已更新，正在同步模块实例...');
                    // 同步更新画布上的模块实例
                    syncModuleInstances();
                    showNotification('模块库已更新');
                }
            } catch (error) {
                console.error('加载模块失败:', error);
                showNotification(`加载模块失败: ${error.message}`);
            }
        }

        async function loadFreshModules() {
            try {
                const response = await fetch('/api/modules');
                if (!response.ok) {
                    throw new Error(`加载模块失败: ${response.status}`);
                }
                const data = await response.json();
                modules = data;
                renderModules();
            } catch (error) {
                console.error('加载模块失败:', error);
                showNotification(`加载模块失败: ${error.message}`);
            }
        }
        
        // 同步更新模块实例
        function syncModuleInstances() {
            // 遍历所有模块实例
            Object.keys(moduleStates).forEach(moduleId => {
                const moduleState = moduleStates[moduleId];
                const moduleName = moduleState.moduleData.name;
                
                // 检查模块是否存在于更新后的模块列表中
                if (modules[moduleName]) {
                    // 更新模块数据
                    const updatedModuleData = {
                        name: moduleName,
                        params: modules[moduleName]
                    };
                    
                    // 重新检查兼容性（用加载时保存的原始模块数据对比）
                    const oldModuleData = moduleState.originalModuleData || moduleState.moduleData;
                    const isCompatible = isModuleCompatible(oldModuleData);
                    
                    // 保留原有状态，只更新模块定义
                    moduleState.moduleData = updatedModuleData;
                    moduleState.isCompatible = isCompatible;
                    
                    // 更新DOM元素
                    const moduleElement = document.querySelector(`.module[data-module-id="${moduleId}"]`);
                    if (moduleElement) {
                        // 重新生成模块内容（用更新后的数据）
                        const moduleContent = generateModuleContent(updatedModuleData);
                        moduleElement.innerHTML = moduleContent;
                        
                        // 重新添加事件监听器
                        addModuleEventListeners(moduleElement);
                        
                        // 应用兼容性样式
                        if (!isCompatible) {
                            moduleElement.classList.add('error');
                            console.log(`同步时标记模块为错误: ${moduleName}`);
                        } else {
                            moduleElement.classList.remove('error');
                        }
                        
                        console.log(`模块实例已更新: ${moduleId} - ${moduleName}`);
                    }
                } else {
                    console.warn(`模块不存在: ${moduleName}`);
                }
            });
        }
        
        // 渲染模块到模块库
        function renderModules() {
            // 清空模块库
            const categoryIds = [
                'sampling-modules', 'loader-modules', 'latent-modules', 'image-modules', 'other-modules', 'custom-modules'
            ];
            
            categoryIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.innerHTML = '';
                }
            });
            
            // 分类渲染模块
            for (const [name, params] of Object.entries(modules)) {
                const moduleItem = document.createElement('div');
                moduleItem.className = 'module-item';
                moduleItem.draggable = true;
                moduleItem.dataset.name = name;
                moduleItem.dataset.params = JSON.stringify(params);
                
                moduleItem.innerHTML = `
                    <div class="module-name">${params.name || name}</div>
                    <div class="module-kind">${params.kind || '未知'}</div>
                `;
                
                // 添加拖拽事件
                moduleItem.addEventListener('dragstart', handleDragStart);
                
                // 根据模块来源和类型分类
                let targetElementId;
                
                // 自定义模块全部归类到自定义模块分类
                if (params.source === 'custom') {
                    targetElementId = 'custom-modules';
                } else {
                    // 默认模块根据名称或类型分类
                    targetElementId = 'other-modules'; // 默认归类到其它分类
                    
                    // 根据模块名称进行分类
                    const moduleName = params.name || name;
                    
                    if ((moduleName.includes('UNet') || moduleName.includes('LoRA') || moduleName.includes('Checkpoint') || moduleName.includes('CLIP文本编码器加载模块')) || (moduleName.includes('VAE') && !moduleName.includes('解码模块') && !moduleName.includes('图像编码') && !moduleName.includes('重绘编码'))) {
                        targetElementId = 'loader-modules';
                    } else if (moduleName.includes('CLIP文本编码模块') || moduleName.includes('提示词编码')) {
                        targetElementId = 'condition-modules';
                    } else if (moduleName.includes('采样') || moduleName.includes('K采样器')) {
                        targetElementId = 'sampling-modules';
                    } else if (moduleName.includes('Latent') || moduleName.includes('latent') || moduleName.includes('VAE解码模块') || moduleName.includes('VAE编码') || moduleName.includes('VAE图像编码') || moduleName.includes('设置Latent噪波遮罩') || moduleName.includes('VAE重绘编码')) {
                        targetElementId = 'latent-modules';
                    } else if (moduleName.includes('图像') || moduleName.includes('图片')) {
                        targetElementId = 'image-modules';
                    }
                }
                
                // 检查目标元素是否存在
                const targetElement = document.getElementById(targetElementId);
                if (targetElement) {
                    targetElement.appendChild(moduleItem);
                } else {
                    // 如果目标元素不存在，使用其它分类
                    const defaultElement = document.getElementById('other-modules');
                    if (defaultElement) {
                        defaultElement.appendChild(moduleItem);
                    }
                }
            }
        }
        
        // 处理拖拽开始
        function handleDragStart(e) {
            draggedModule = e.target;
            e.dataTransfer.effectAllowed = 'copy';
            e.dataTransfer.setData('text/plain', JSON.stringify({
                name: e.target.dataset.name,
                params: JSON.parse(e.target.dataset.params)
            }));
        }
        
        // 处理画布拖拽
        function handleCanvasDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
        }
        
        // 处理画布放置
        function handleCanvasDrop(e) {
            e.preventDefault();
            const data = JSON.parse(e.dataTransfer.getData('text/plain'));
            createModuleOnCanvas(data, e.offsetX, e.offsetY);
        }
        
        // 项目文件默认值规则配置
        const DEFAULT_VALUES = {
            version: '0.1',
            modules: [],
            connections: [],
            canvasSize: { width: 4000, height: 3000 },
            timestamp: new Date().toISOString(),
            usedCustomModules: [],
            module: {
                id: null, // 动态生成
                name: '未知模块',
                kind: '未知',
                left: '0px',
                top: '0px',
                moduleData: {
                    name: '未知模块',
                    params: {
                        name: '未知模块',
                        kind: '未知',
                        input_quantity: 0,
                        output_quantity: 0,
                        showingwindow_quantity: 0,
                        inputtingwindow_quantity: 0,
                        setting: false,
                        userinput: false,
                        time_late: 0,
                        excitedbydata: false,
                        variables_name: '',
                        output_name: ''
                    }
                },
                settings: {},
                inputValue: ''
            },
            connection: {
                startModuleId: '',
                startPortIndex: 0,
                endModuleId: '',
                endPortIndex: 0,
                isRed: false
            }
        };
        
        // 处理项目数据，添加版本兼容和缺失字段处理
        function processProjectData(projectData) {
            try {
                // 保存原始数据作为备份
                const originalData = JSON.parse(JSON.stringify(projectData));
                
                // 创建副本，避免修改原始数据
                const processedData = JSON.parse(JSON.stringify(projectData));
                
                // 应用默认值规则
                processedData.version = processedData.version || DEFAULT_VALUES.version;
                processedData.modules = processedData.modules || DEFAULT_VALUES.modules;
                processedData.connections = processedData.connections || DEFAULT_VALUES.connections;
                processedData.canvasSize = processedData.canvasSize || DEFAULT_VALUES.canvasSize;
                processedData.timestamp = processedData.timestamp || DEFAULT_VALUES.timestamp;
                processedData.usedCustomModules = processedData.usedCustomModules || DEFAULT_VALUES.usedCustomModules;
                
                // 处理模块数据
                processedData.modules = processedData.modules.map(moduleInfo => {
                    // 应用模块默认值
                    moduleInfo.id = moduleInfo.id || `temp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
                    moduleInfo.name = moduleInfo.name || DEFAULT_VALUES.module.name;
                    moduleInfo.kind = moduleInfo.kind || DEFAULT_VALUES.module.kind;
                    moduleInfo.left = moduleInfo.left || DEFAULT_VALUES.module.left;
                    moduleInfo.top = moduleInfo.top || DEFAULT_VALUES.module.top;
                    moduleInfo.moduleData = moduleInfo.moduleData || JSON.parse(JSON.stringify(DEFAULT_VALUES.module.moduleData));
                    moduleInfo.settings = moduleInfo.settings || DEFAULT_VALUES.module.settings;
                    moduleInfo.inputValue = moduleInfo.inputValue !== undefined ? moduleInfo.inputValue : DEFAULT_VALUES.module.inputValue;
                    
                    // 确保模块参数完整
                    moduleInfo.moduleData.params = moduleInfo.moduleData.params || {};
                    // 应用模块参数默认值
                    Object.keys(DEFAULT_VALUES.module.moduleData.params).forEach(key => {
                        if (moduleInfo.moduleData.params[key] === undefined) {
                            moduleInfo.moduleData.params[key] = DEFAULT_VALUES.module.moduleData.params[key];
                        }
                    });
                    
                    return moduleInfo;
                });
                
                // 处理连接数据
                processedData.connections = processedData.connections.map(connInfo => {
                    // 应用连接默认值
                    connInfo.startModuleId = connInfo.startModuleId || DEFAULT_VALUES.connection.startModuleId;
                    connInfo.startPortIndex = connInfo.startPortIndex !== undefined ? connInfo.startPortIndex : DEFAULT_VALUES.connection.startPortIndex;
                    connInfo.endModuleId = connInfo.endModuleId || DEFAULT_VALUES.connection.endModuleId;
                    connInfo.endPortIndex = connInfo.endPortIndex !== undefined ? connInfo.endPortIndex : DEFAULT_VALUES.connection.endPortIndex;
                    connInfo.isRed = connInfo.isRed !== undefined ? connInfo.isRed : DEFAULT_VALUES.connection.isRed;
                    
                    return connInfo;
                });
                
                // 版本特定处理
                if (processedData.version < '1.0') {
                    // 处理旧版本数据
                    console.log('处理旧版本项目数据:', processedData.version);
                    // 这里可以添加针对旧版本的特定处理逻辑
                }
                
                console.log('项目数据处理完成:', processedData);
                return processedData;
            } catch (error) {
                console.error('项目数据处理失败:', error);
                // 处理失败时返回默认项目数据
                console.log('使用默认项目数据');
                return {
                    version: DEFAULT_VALUES.version,
                    modules: [],
                    connections: [],
                    canvasSize: DEFAULT_VALUES.canvasSize,
                    timestamp: DEFAULT_VALUES.timestamp,
                    usedCustomModules: []
                };
            }
        }
        
        // 生成唯一的模块ID
        function generateModuleId() {
            // 使用UUID v4生成唯一ID，格式为8-4-4-4-12的16进制数字
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c === 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // 在画布上创建模块
        function createModuleOnCanvas(moduleData, x, y) {
            const module = document.createElement('div');
            module.className = 'module';
            
            // 为模块添加唯一标识符
            const moduleId = generateModuleId();
            module.dataset.moduleId = moduleId;
            
            // 初始化模块状态
                    const inputQuantity = moduleData.params.input_quantity || 0;
                    const outputQuantity = moduleData.params.output_quantity || 0;
                    
                    moduleStates[moduleId] = {
                        moduleData: moduleData,
                        savedModuleDataAtLoadTime: moduleData, // 新创建的模块，保存时的模块数据就是当前数据
                        inputValues: new Array(inputQuantity).fill(null), // 输入端口值（改为数组）
                        outputValues: new Array(outputQuantity).fill(null), // 输出端口值（改为数组）
                        displayContent: '', // 显示框内容（与实际内容分离）
                        executed: false, // 执行状态
                        executing: false, // 执行中状态
                        lastUpdated: null // 最后更新时间，用于处理时序冲突
                    };
                    
                    // 为缓存模块设置初始值
                    if (moduleData.params.name === '缓存模块') {
                        moduleStates[moduleId].outputValues = [null]; // 初始化为null
                        moduleStates[moduleId].displayContent = '缓存内容: 空';
                    } else if (moduleData.params.name === '显示模块') {
                        moduleStates[moduleId].outputValues = [null]; // 初始化为null
                        moduleStates[moduleId].displayContent = '显示内容: 空';
                    }
            
            // 根据输入输出端口数量设置样式
            if (moduleData.params.input_quantity === 0) {
                module.classList.add('no-input');
            }
            if (moduleData.params.output_quantity === 0) {
                module.classList.add('no-output');
            }
            
            // 调整模块宽度，使其更紧凑美观
            module.style.width = '220px';
            module.style.minWidth = '220px';
            module.style.maxWidth = '220px';
            module.style.boxSizing = 'border-box';
            module.style.left = `${x - 110}px`;
            module.style.top = `${y - 40}px`;
            
            // 创建输入端口
            let inputPortsHtml = '';
            const inputNames = moduleData.params.variables_name ? moduleData.params.variables_name.split(',') : [];
            for (let i = 0; i < (moduleData.params.input_quantity || 0); i++) {
                const portName = inputNames[i] || `IN_${(i+1).toString().padStart(3, '0')}`;
                inputPortsHtml += `<div style="display: flex; align-items: center; margin: 2px 0; white-space: nowrap;">
                    <div class="port input-port" data-port="input-${i}" style="margin-right: 8px;"></div>
                    <span style="font-size: 10px; flex: 1; overflow: hidden; text-overflow: ellipsis;">${portName}</span>
                </div>`;
            }
            
            // 创建输出端口
            let outputPortsHtml = '';
            const outputNames = moduleData.params.output_name ? moduleData.params.output_name.split(',') : [];
            for (let i = 0; i < (moduleData.params.output_quantity || 0); i++) {
                const portName = outputNames[i] || `OUT_${(i+1).toString().padStart(3, '0')}`;
                outputPortsHtml += `<div style="display: flex; align-items: center; margin: 2px 0; white-space: nowrap;">
                    <span style="font-size: 10px; flex: 1; text-align: right; margin-right: 8px; overflow: hidden; text-overflow: ellipsis;">${portName}</span>
                    <div class="port output-port" data-port="output-${i}"></div>
                </div>`;
            }
            
            // 添加设置按钮
            let settingBtnHtml = '';
            if (moduleData.params.setting === true || moduleData.params.setting === 'T' || moduleData.params.setting === 'true') {
                // 转义JSON字符串中的双引号，确保在HTML属性中正确显示
                const escapedModuleData = JSON.stringify(moduleData).replace(/"/g, '&quot;');
                settingBtnHtml = `<div class="setting-btn" data-module="${escapedModuleData}">Set</div>`;
            }
            
            // 创建显示框
            let showingWindowHtml = '';
            if (moduleData.params.showingwindow_quantity > 0) {
                showingWindowHtml = `<div class="showing-window" style="margin-top: 10px; padding: 0; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; font-size: 10px; width: 100%; max-width: 100%; box-sizing: border-box; overflow: hidden; position: relative;">
                    <span class="window-content" style="cursor: help; display: block; padding: 5px;">${moduleData.params.name === '缓存模块' ? '缓存内容...' : '显示内容'}</span>
                </div>`;
            }
            
            module.innerHTML = `
                ${settingBtnHtml}
                <div class="module-header">${moduleData.params.name || moduleData.name}</div>
                <div class="module-kind">${moduleData.params.kind || '未知'}</div>
                <div class="ports" style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div class="input-ports" style="flex: 1; margin-right: 10px;">${inputPortsHtml}</div>
                    <div style="width: 1px; background-color: #ddd; height: 100%; margin: 0 10px;"></div>
                    <div class="output-ports" style="flex: 1; margin-left: 10px;">${outputPortsHtml}</div>
                </div>
                ${showingWindowHtml}
                ${moduleData.params.inputtingwindow_quantity > 0 ? `<div class="inputting-window" style="margin-top: 10px; padding: 5px; background-color: #f0f8ff; border: 1px solid #add8e6; border-radius: 4px; font-size: 10px; width: 100%; max-width: 100%; box-sizing: border-box; cursor: pointer;" onclick="openInputSettingModal('${moduleData.name}', this.closest('.module').dataset.moduleId)">
                    <span style="display: block; margin-bottom: 3px;">输入值:</span>
                    <div style="width: 100%; max-width: 100%; box-sizing: border-box; padding: 3px; border: 1px solid #ddd; border-radius: 2px; font-size: 10px; background-color: white; max-height: 120px; overflow-y: auto; word-wrap: break-word; white-space: pre-wrap;">
                        <span class="input-value">请输入固定值</span>
                    </div>
                </div>` : ''}
            `;
            
            // 添加拖拽功能
            makeDraggable(module);
            
            // 添加端口事件
            module.querySelectorAll('.port').forEach(port => {
                port.addEventListener('mousedown', handlePortMouseDown);
                port.addEventListener('click', handlePortClick);
                port.addEventListener('dblclick', handlePortDoubleClick);
            });
            
            // 添加设置按钮点击事件
            const settingBtn = module.querySelector('.setting-btn');
            if (settingBtn) {
                settingBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const moduleData = JSON.parse(settingBtn.dataset.module);
                    const moduleId = module.dataset.moduleId;
                    openSettingModal(moduleData, moduleId);
                });
            }
            
            // 添加显示框悬停事件
            const showingWindow = module.querySelector('.showing-window');
            if (showingWindow) {
                const contentSpan = showingWindow.querySelector('.window-content');
                const tooltip = showingWindow.querySelector('.tooltip');
                
                // 鼠标进入时显示完整内容
                contentSpan.addEventListener('mouseenter', function(e) {
                    // 根据模块类型获取实际内容
                    const currentModule = this.closest('.module');
                    const moduleId = parseInt(currentModule.dataset.moduleId);
                    const moduleState = moduleStates[moduleId];
                    
                    let fullContent = '';
                    if (moduleState) {
                        if (moduleState.moduleData.params.name === '缓存模块' || moduleState.moduleData.params.name === '显示模块') {
                                const displayContent = moduleState.displayContent !== undefined && moduleState.displayContent !== null ? moduleState.displayContent : '';
                                const prefix = moduleState.moduleData.params.name === '缓存模块' ? '缓存内容: ' : '显示内容: ';
                                fullContent = `${prefix}${displayContent}`;
                            } else {
                            // 对于其他模块，显示完整的默认内容
                            fullContent = contentSpan.textContent;
                        }
                    } else {
                        fullContent = contentSpan.textContent;
                    }
                    
                    // 创建一个新的tooltip元素，确保它能够正确显示
                    let tooltipElement = document.getElementById('custom-tooltip');
                    if (!tooltipElement) {
                        tooltipElement = document.createElement('div');
                        tooltipElement.id = 'custom-tooltip';
                        tooltipElement.style.cssText = `
                            display: none;
                            position: fixed;
                            background-color: #333;
                            color: white;
                            padding: 10px;
                            border-radius: 4px;
                            font-size: 12px;
                            z-index: 9999;
                            max-width: 800px;
                            max-height: 500px;
                            overflow: auto;
                            word-wrap: break-word;
                            pointer-events: none;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                        `;
                        document.body.appendChild(tooltipElement);
                    }
                    
                    tooltipElement.textContent = fullContent;
                    tooltipElement.style.display = 'block';
                    
                    // 定位tooltip到鼠标位置附近
                    tooltipElement.style.left = `${e.pageX + 10}px`;
                    tooltipElement.style.top = `${e.pageY + 10}px`;
                });
                
                // 鼠标移动时更新tooltip位置
                contentSpan.addEventListener('mousemove', function(e) {
                    const tooltipElement = document.getElementById('custom-tooltip');
                    if (tooltipElement && tooltipElement.style.display === 'block') {
                        tooltipElement.style.left = `${e.pageX + 10}px`;
                        tooltipElement.style.top = `${e.pageY + 10}px`;
                    }
                });
                
                // 鼠标离开时隐藏tooltip
                contentSpan.addEventListener('mouseleave', function() {
                    const tooltipElement = document.getElementById('custom-tooltip');
                    if (tooltipElement) {
                        tooltipElement.style.display = 'none';
                    }
                });
            }
            
            canvasContent.appendChild(module);
        }
        
        // 计算端口位置
        function getPortPosition(port) {
            // 获取模块元素
            const module = port.closest('.module');
            if (!module) return { x: 0, y: 0 };
            
            // 获取模块的位置
            const moduleLeft = parseFloat(module.style.left) || 0;
            const moduleTop = parseFloat(module.style.top) || 0;
            
            // 获取模块和端口的实际位置（不考虑变换）
            // 使用offsetLeft和offsetTop来获取相对于父元素的位置
            let portX = 0;
            let portY = 0;
            let current = port;
            
            // 计算端口相对于模块的位置
            while (current && current !== module) {
                portX += current.offsetLeft;
                portY += current.offsetTop;
                current = current.offsetParent;
            }
            
            // 计算端口中心位置
            const relativeX = portX + port.offsetWidth / 2;
            const relativeY = portY + port.offsetHeight / 2;
            
            // 计算端口相对于画布内容的绝对位置
            return {
                x: moduleLeft + relativeX,
                y: moduleTop + relativeY
            };
        }
        
        // 更新连线位置
        function updateConnectionLine(connection) {
            if (!connection || !connection.startPort || !connection.endPort) return;
            
            const startPos = getPortPosition(connection.startPort);
            const endPos = getPortPosition(connection.endPort);
            
            // 计算连线的长度和角度
            const length = Math.sqrt(Math.pow(endPos.x - startPos.x, 2) + Math.pow(endPos.y - startPos.y, 2));
            const angle = Math.atan2(endPos.y - startPos.y, endPos.x - startPos.x) * 180 / Math.PI;
            
            const line = connection.line;
            line.style.width = `${length}px`;
            line.style.left = `${startPos.x}px`;
            line.style.top = `${startPos.y + 1.5}px`;
            line.style.transform = `rotate(${angle}deg)`;
            line.style.zIndex = '1000'; // 确保连线显示在模块上方
        }
        
        // 使模块可拖拽
        function makeDraggable(element) {
            // 添加draggable属性，支持HTML5拖放API
            element.draggable = true;
            
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;
            
            function dragMouseDown(e) {
                // 只处理左键点击
                if (e.button !== 0) return;
                
                // 检查是否点击了输入框或其他可交互元素
                const target = e.target;
                if (target.tagName === 'INPUT' || target.tagName === 'TEXTAREA' || target.tagName === 'SELECT' || target.isContentEditable || target.closest('.inputting-window')) {
                    return; // 不处理输入元素和输入区域的点击
                }
                
                e = e || window.event;
                e.preventDefault();
                e.stopPropagation(); // 阻止事件冒泡到画布
                
                // 开始鼠标拖动
                isDragging = true;
                // 获取鼠标位置
                pos3 = e.clientX;
                pos4 = e.clientY;
                document.addEventListener('mouseup', closeDragElement);
                document.addEventListener('mousemove', elementDrag);
            }
            
            function elementDrag(e) {
                if (!isDragging) return;
                
                e = e || window.event;
                e.preventDefault();
                // 计算新位置
                pos1 = pos3 - e.clientX;
                pos2 = pos4 - e.clientY;
                pos3 = e.clientX;
                pos4 = e.clientY;
                
                // 检查鼠标是否在模块库区域内
                const moduleLibrary = document.querySelector('.module-library');
                const libraryRect = moduleLibrary.getBoundingClientRect();
                
                if (pos3 >= libraryRect.left && pos3 <= libraryRect.right && 
                    pos4 >= libraryRect.top && pos4 <= libraryRect.bottom) {
                    // 鼠标在模块库区域内，准备删除模块
                    moduleLibrary.style.backgroundColor = '#e3f2fd';
                } else {
                    // 鼠标不在模块库区域内，正常移动模块
                    moduleLibrary.style.backgroundColor = '#f5f5f5';
                    // 设置新位置
                    element.style.top = (element.offsetTop - pos2) + "px";
                    element.style.left = (element.offsetLeft - pos1) + "px";
                    
                    // 更新与该模块相关的所有连线
                    connectionLines.forEach(connection => {
                        if (connection.startPort.closest('.module') === element || 
                            connection.endPort.closest('.module') === element) {
                            updateConnectionLine(connection);
                        }
                    });
                }
            }
            
            function closeDragElement(e) {
                // 停止移动
                isDragging = false;
                document.removeEventListener('mouseup', closeDragElement);
                document.removeEventListener('mousemove', elementDrag);
                
                // 检查鼠标是否在模块库区域内，如果是则删除模块
                const moduleLibrary = document.querySelector('.module-library');
                const libraryRect = moduleLibrary.getBoundingClientRect();
                
                if (e && pos3 >= libraryRect.left && pos3 <= libraryRect.right && 
                    pos4 >= libraryRect.top && pos4 <= libraryRect.bottom) {
                    // 鼠标在模块库区域内，删除模块
                    console.log('删除模块:', element);
                    
                    // 删除模块状态
                    const moduleId = element.dataset.moduleId;
                    if (moduleId) {
                        delete moduleStates[moduleId];
                        console.log('删除模块状态:', moduleId);
                    }
                    
                    // 删除与该模块相关的所有连线
                    connectionLines = connectionLines.filter(connection => {
                        const isRelated = connection.startPort.closest('.module') === element || 
                                        connection.endPort.closest('.module') === element;
                        if (isRelated) {
                            connection.line.remove();
                        }
                        return !isRelated;
                    });
                    
                    // 删除模块
                    element.remove();
                    console.log('模块删除成功');
                }
                
                // 重置模块库背景色
                moduleLibrary.style.backgroundColor = '#f5f5f5';
            }
            
            // 拖放API事件处理
            function handleDragStart(e) {
                // 只处理左键拖放
                if (e.button !== 0) return;
                
                console.log('画布模块dragstart事件触发:', this);
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
                // 设置拖拽数据，确保能被识别
                e.dataTransfer.setData('text/plain', 'module');
            }
            
            function handleDragEnd(e) {
                console.log('画布模块dragend事件触发:', this);
                this.classList.remove('dragging');
            }
            
            function handleDragOver(e) {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'move';
            }
            
            function handleDrop(e) {
                e.preventDefault();
                e.stopPropagation();
            }
            
            // 使用addEventListener替代直接赋值
            element.addEventListener('mousedown', dragMouseDown);
            // 添加拖放API事件监听器
            element.addEventListener('dragstart', handleDragStart);
            element.addEventListener('dragend', handleDragEnd);
            element.addEventListener('dragover', handleDragOver);
            element.addEventListener('drop', handleDrop);
            
            // 确保模块能响应拖放事件
            element.style.position = 'absolute';
            element.style.zIndex = '50'; // 确保模块显示在连线的下方
        }
        
        // 创建连线元素
        function createConnectionLine(x1, y1, x2, y2, isRed = false) {
            const line = document.createElement('div');
            line.className = `connection-line ${isRed ? 'red' : ''}`;
            
            // 计算连线的长度和角度
            const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
            const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
            
            // 设置连线的样式
            line.style.width = `${length}px`;
            line.style.left = `${x1}px`;
            line.style.top = `${y1 + 1.5}px`; // +1.5 是为了让线条垂直居中
            line.style.transform = `rotate(${angle}deg)`;
            line.style.zIndex = '1000'; // 确保连线显示在模块上方
            
            // 添加双击切换颜色功能
            line.addEventListener('dblclick', function() {
                line.classList.toggle('red');
            });
            
            // 添加长按事件，显示设置框
            let longPressTimer;
            line.addEventListener('mousedown', function(e) {
                e.stopPropagation();
                longPressTimer = setTimeout(function() {
                    showLineSettings(line, e.clientX, e.clientY);
                }, 500); // 500ms长按
            });
            
            line.addEventListener('mouseup', function() {
                clearTimeout(longPressTimer);
            });
            
            line.addEventListener('mouseleave', function() {
                clearTimeout(longPressTimer);
            });
            
            return line;
        }
        
        // 处理端口鼠标按下
        function handlePortMouseDown(e) {
            e.preventDefault();
            e.stopPropagation(); // 阻止事件冒泡到模块
            isDrawing = true;
            draggedPort = e.target;
            
            // 使用新的getPortPosition函数计算端口位置
            const portPos = getPortPosition(e.target);
            startX = portPos.x;
            startY = portPos.y;
            
            // 创建临时连线
            currentConnection = createConnectionLine(startX, startY, startX, startY);
            canvasContent.appendChild(currentConnection);
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp);
        }
        
        // 处理鼠标移动
        function handleMouseMove(e) {
            if (!isDrawing || !currentConnection) return;
            
            const canvasRect = canvas.getBoundingClientRect();
            endX = e.clientX - canvasRect.left + canvas.scrollLeft;
            endY = e.clientY - canvasRect.top + canvas.scrollTop;
            
            // 更新临时连线
            const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
            const angle = Math.atan2(endY - startY, endX - startX) * 180 / Math.PI;
            
            currentConnection.style.width = `${length}px`;
            currentConnection.style.transform = `rotate(${angle}deg)`;
        }
        
        // 处理鼠标释放
        function handleMouseUp(e) {
            if (isDrawing && currentConnection) {
                isDrawing = false;
                
                // 检查是否释放到了另一个端口
                const target = e.target;
                if (target.classList.contains('port') && target !== draggedPort) {
                    // 确保是从输出端口到输入端口的连接
                    const isOutputPort = draggedPort.classList.contains('output-port');
                    const isInputPort = target.classList.contains('input-port');
                    
                    if (isOutputPort && isInputPort) {
                        // 使用新的getPortPosition函数计算目标端口的位置
                        const startPos = getPortPosition(draggedPort);
                        const endPos = getPortPosition(target);
                        
                        // 更新连线
                        const length = Math.sqrt(Math.pow(endPos.x - startPos.x, 2) + Math.pow(endPos.y - startPos.y, 2));
                        const angle = Math.atan2(endPos.y - startPos.y, endPos.x - startPos.x) * 180 / Math.PI;
                        
                        currentConnection.style.width = `${length}px`;
                        currentConnection.style.left = `${startPos.x}px`;
                        currentConnection.style.top = `${startPos.y + 1.5}px`;
                        currentConnection.style.transform = `rotate(${angle}deg)`;
                        
                        // 保存连线信息
                        connectionLines.push({
                            line: currentConnection,
                            startPort: draggedPort,
                            endPort: target,
                            isRed: currentConnection.classList.contains('red'),
                            data: null, // 传输的数据
                            transferred: false, // 数据是否已传输
                            startModuleId: draggedPort.closest('.module').dataset.moduleId,
                            endModuleId: target.closest('.module').dataset.moduleId,
                            startPortIndex: parseInt(draggedPort.dataset.port.split('-')[1]),
                            endPortIndex: parseInt(target.dataset.port.split('-')[1])
                        });
                    } else {
                        // 不是有效的连接，移除临时连线
                        currentConnection.remove();
                    }
                } else {
                    // 没有释放到端口，移除临时连线
                    currentConnection.remove();
                }
            }
            
            currentConnection = null;
            draggedPort = null;
            document.removeEventListener('mousemove', handleMouseMove);
            document.removeEventListener('mouseup', handleMouseUp);
        }
        
        // 显示连线设置框
        function showLineSettings(line, x, y) {
            // 创建设置框
            const settingsBox = document.createElement('div');
            settingsBox.className = 'line-settings-box';
            settingsBox.style.position = 'fixed';
            settingsBox.style.left = `${x + 10}px`;
            settingsBox.style.top = `${y + 10}px`;
            settingsBox.style.backgroundColor = 'white';
            settingsBox.style.border = '1px solid #ddd';
            settingsBox.style.borderRadius = '4px';
            settingsBox.style.padding = '8px';
            settingsBox.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
            settingsBox.style.zIndex = '2000';
            settingsBox.style.minWidth = '120px';
            
            // 设置框内容
            settingsBox.innerHTML = `
                <div style="margin-bottom: 5px;">
                    <button onclick="toggleLineColor(this.parentElement.parentElement)" style="width: 100%; padding: 4px;">
                        ${line.classList.contains('red') ? '切换为黑线' : '切换为红线'}
                    </button>
                </div>
                <div>
                    <button onclick="deleteLine(this.parentElement.parentElement)" style="width: 100%; padding: 4px; color: red;">
                        删除连线
                    </button>
                </div>
            `;
            
            // 添加到文档
            document.body.appendChild(settingsBox);
            
            // 阻止设置框内部事件冒泡
            settingsBox.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // 阻止连线事件冒泡，防止点击连线关闭设置框
            line.addEventListener('click', function(e) {
                e.stopPropagation();
            });
            
            // 点击外部关闭设置框
            function closeSettings(e) {
                if (!settingsBox.contains(e.target) && e.target !== line) {
                    try {
                        document.body.removeChild(settingsBox);
                    } catch (error) {
                        console.log('设置框已被移除:', error);
                    }
                    document.removeEventListener('click', closeSettings);
                }
            }
            
            // 延迟添加事件监听器，确保长按后的mouseup事件不会触发
            setTimeout(function() {
                document.addEventListener('click', closeSettings);
            }, 200);
            
            // 保存当前连线引用
            settingsBox.line = line;
        }
        
        // 切换连线颜色
        function toggleLineColor(settingsBox) {
            const line = settingsBox.line;
            line.classList.toggle('red');
            // 更新按钮文本
            const button = settingsBox.querySelector('button:first-child');
            button.textContent = line.classList.contains('red') ? '切换为黑线' : '切换为红线';
            
            // 更新连线对象的isRed属性
            const connection = connectionLines.find(conn => conn.line === line);
            if (connection) {
                connection.isRed = line.classList.contains('red');
            }
        }
        
        // 删除连线
        function deleteLine(settingsBox) {
            const line = settingsBox.line;
            // 从connectionLines中移除
            connectionLines = connectionLines.filter(connection => connection.line !== line);
            // 删除DOM元素
            line.remove();
            // 关闭设置框
            document.body.removeChild(settingsBox);
        }
        
        // 处理端口点击
        function handlePortClick(e) {
            e.stopPropagation();
            
            if (!firstPort) {
                // 第一次点击，保存端口
                firstPort = e.target;
                // 改变鼠标指针为十字
                canvas.style.cursor = 'crosshair';
            } else if (firstPort === e.target) {
                // 点击同一个端口，取消操作
                firstPort = null;
                canvas.style.cursor = 'grab';
            } else {
                // 第二次点击，检查是否是有效的连接
                const targetPort = e.target;
                const isOutputPort = firstPort.classList.contains('output-port');
                const isInputPort = targetPort.classList.contains('input-port');
                
                if (isOutputPort && isInputPort) {
                    // 创建连线
                    const startPos = getPortPosition(firstPort);
                    const endPos = getPortPosition(targetPort);
                    
                    const line = createConnectionLine(startPos.x, startPos.y, endPos.x, endPos.y);
                    canvasContent.appendChild(line);
                    
                    // 保存连线信息
                    connectionLines.push({
                        line: line,
                        startPort: firstPort,
                        endPort: targetPort,
                        isRed: line.classList.contains('red'),
                        data: null, // 传输的数据
                        transferred: false, // 数据是否已传输
                        startModuleId: firstPort.closest('.module').dataset.moduleId,
                        endModuleId: targetPort.closest('.module').dataset.moduleId,
                        startPortIndex: parseInt(firstPort.dataset.port.split('-')[1]),
                        endPortIndex: parseInt(targetPort.dataset.port.split('-')[1])
                    });
                }
                
                // 重置状态
                firstPort = null;
                canvas.style.cursor = 'grab';
            }
        }
        
        // 处理端口双击
        function handlePortDoubleClick(e) {
            e.stopPropagation();
            
            const port = e.target;
            
            // 检查端口是否已经有连线
            const connectedLines = connectionLines.filter(connection => {
                return connection.startPort === port || connection.endPort === port;
            });
            
            if (connectedLines.length > 0) {
                // 如果有连线，删除所有相关连线
                connectedLines.forEach(connection => {
                    connection.line.remove();
                });
                
                // 从连线数组中移除
                connectionLines = connectionLines.filter(connection => {
                    return !connectedLines.includes(connection);
                });
            } else {
                // 如果没有连线，创建一个新的临时连线
                // 这里可以实现更复杂的逻辑，比如连接到最近的端口
                console.log('双击端口创建新连线');
            }
        }
        
        // 刷新模块
        document.getElementById('refresh-modules-btn').addEventListener('click', async function() {
            try {
                const response = await fetch('/api/refresh_modules');
                const data = await response.json();
                modules = data;
                renderModules();
                alert('模块刷新成功');
            } catch (error) {
                console.error('刷新模块失败:', error);
                alert('刷新模块失败');
            }
        });
        
        // 发送消息
        document.getElementById('send-btn').addEventListener('click', function() {
            sendMessage();
        });
        
        document.getElementById('chat-input').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });
        
        // 存储用户输入
        let userInput = '';
        
        // 页面加载完成后初始化模块分类折叠功能
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOM内容已加载');
            initModuleCategoryCollapse();
            
            // 全局鼠标移动监听，统一更新lastMouseX/Y
            document.addEventListener('mousemove', function(e) {
                const rect = canvas.getBoundingClientRect();
                lastMouseX = e.clientX - rect.left;
                lastMouseY = e.clientY - rect.top;
            });
            
            // 延迟一点时间再初始化预览窗口，确保DOM完全加载
            setTimeout(function() {
                console.log('开始初始化预览窗口');
                initPreviewWindow(); // 初始化预览窗口
            }, 500);
        });
        
        // 页面关闭时自动保存缓存
        window.addEventListener('beforeunload', function(e) {
            saveCache();
        });
        
        // 解析画布的transform属性，获取视口信息
        function parseCanvasTransform() {
            return {
                offsetX: globalCanvasOffsetX,
                offsetY: globalCanvasOffsetY,
                scale: globalZoomScale,
                containerWidth: canvas.clientWidth,
                containerHeight: canvas.clientHeight
            };
        }
        
        // 设置画布的transform属性
        function setCanvasTransform(offsetX, offsetY, scale) {
            const canvasContent = document.getElementById('canvas-content');
            const zoomLevelDisplay = document.querySelector('.zoom-level');
            
            if (!canvasContent) {
                return;
            }
            
            const minZoom = 20;
            const maxZoom = 500;
            let zoomLevel = Math.round(scale * 100);
            zoomLevel = Math.max(minZoom, Math.min(maxZoom, zoomLevel));
            const newScale = zoomLevel / 100;
            
            globalCanvasOffsetX = offsetX;
            globalCanvasOffsetY = offsetY;
            globalZoomScale = newScale;
            
            canvasContent.style.transform = `translate(${globalCanvasOffsetX}px, ${globalCanvasOffsetY}px) scale(${newScale})`;
            
            if (zoomLevelDisplay) {
                zoomLevelDisplay.textContent = zoomLevel + '%';
            }
            
            currentZoomLevel = zoomLevel;
        }
        
        // 初始化预览窗口
        function initPreviewWindow() {
            console.log('initPreviewWindow函数被调用');
            
            // 获取预览窗口元素
            const previewWindow = document.querySelector('.preview-window');
            const previewToggle = document.querySelector('.preview-toggle');
            const previewCanvas = document.querySelector('.preview-canvas');
            const viewportBox = document.getElementById('viewport-box');
            const previewContent = document.querySelector('.preview-content');
            
            console.log('previewWindow:', previewWindow);
            console.log('previewToggle:', previewToggle);
            console.log('previewCanvas:', previewCanvas);
            console.log('viewportBox:', viewportBox);
            console.log('previewContent:', previewContent);
            
            if (!previewWindow || !previewToggle || !previewCanvas || !viewportBox || !previewContent) {
                console.log('找不到预览窗口元素，返回');
                return;
            }
            
            // 确保预览窗口显示
            previewWindow.style.display = 'block';
            
            // 设置画布尺寸
            const contentRect = previewContent.getBoundingClientRect();
            previewCanvas.width = Math.max(100, contentRect.width);
            previewCanvas.height = Math.max(80, contentRect.height);
            
            // 摄像机视角框拖动状态
            let isDraggingViewport = false;
            let viewportStartX = 0;
            let viewportStartY = 0;
            let dragStartViewport = null;
            let previewUpdateInterval = null;
            
            // 添加预览窗口显示/隐藏功能
            previewToggle.addEventListener('click', function() {
                previewWindow.style.display = previewWindow.style.display === 'none' ? 'block' : 'none';
            });
            
            // 摄像机视角框拖动功能
            viewportBox.addEventListener('mousedown', function(e) {
                e.preventDefault();
                e.stopPropagation();
                isDraggingViewport = true;
                isPreviewDragging = true;
                viewportStartX = e.clientX;
                viewportStartY = e.clientY;
                viewportBox.style.cursor = 'grabbing';
                dragStartViewport = parseCanvasTransform();
            });
            
            // 处理摄像机视角框拖动
            document.addEventListener('mousemove', function(e) {
                if (isDraggingViewport && dragStartViewport) {
                    const previewScale = Math.min(
                        (previewCanvas.width - 20) / canvasSize.width,
                        (previewCanvas.height - 20) / canvasSize.height
                    ) * 0.8;
                    
                    const deltaX = e.clientX - viewportStartX;
                    const deltaY = e.clientY - viewportStartY;
                    
                    const canvasDeltaX = -deltaX / previewScale;
                    const canvasDeltaY = -deltaY / previewScale;
                    
                    const newOffsetX = dragStartViewport.offsetX + canvasDeltaX;
                    const newOffsetY = dragStartViewport.offsetY + canvasDeltaY;
                    
                    setCanvasTransform(newOffsetX, newOffsetY, dragStartViewport.scale);
                }
            });
            
            // 结束摄像机视角框拖动
            document.addEventListener('mouseup', function() {
                if (isDraggingViewport) {
                    isDraggingViewport = false;
                    isPreviewDragging = false;
                    dragStartViewport = null;
                    viewportBox.style.cursor = 'move';
                    updatePreview();
                }
            });
            
            // 摄像机视角框上的滚轮缩放功能
            viewportBox.addEventListener('wheel', function(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const viewport = parseCanvasTransform();
                if (!viewport) return;
                
                let newScale = viewport.scale;
                
                if (e.deltaY < 0) {
                    // 放大
                    newScale = Math.min(viewport.scale * 1.1, 5);
                } else {
                    // 缩小
                    newScale = Math.max(viewport.scale / 1.1, 0.2);
                }
                
                setCanvasTransform(viewport.offsetX, viewport.offsetY, newScale);
            });
            
            console.log('预览窗口初始化完成');
            
            // 初始绘制预览图
            updatePreview();
            
            // 定时更新预览图
            setInterval(updatePreview, 100); // 每100ms更新一次，更流畅
        }
        
        // 全局变量：预览窗口拖动状态
        let isPreviewDragging = false;
        
        // 更新预览图
        function updatePreview() {
            const previewCanvas = document.querySelector('.preview-canvas');
            const viewportBox = document.getElementById('viewport-box');
            
            if (!previewCanvas || !viewportBox) {
                return;
            }
            
            const ctx = previewCanvas.getContext('2d');
            if (!ctx) {
                return;
            }
            
            // 清空画布
            ctx.fillStyle = '#fafafa';
            ctx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
            
            // 显示预览文字
            ctx.fillStyle = '#333333';
            ctx.font = '10px Arial';
            ctx.fillText('预览窗口', 5, 15);
            
            // 获取画布内容
            const canvasContent = document.getElementById('canvas-content');
            if (!canvasContent) {
                return;
            }
            
            // 计算预览图的缩放比例
            const previewScale = Math.min(
                (previewCanvas.width - 20) / canvasSize.width,
                (previewCanvas.height - 20) / canvasSize.height
            ) * 0.8;
            
            // 计算预览图的偏移量，使内容居中
            const previewOffsetX = (previewCanvas.width - canvasSize.width * previewScale) / 2;
            const previewOffsetY = (previewCanvas.height - canvasSize.height * previewScale) / 2;
            
            // 获取当前画布视口信息
            const viewport = parseCanvasTransform();
            
            // 更新摄像机视角框（仅在未拖动时）
            if (viewport && !isPreviewDragging) {
                const viewportLeft = (-viewport.offsetX) * previewScale + previewOffsetX;
                const viewportTop = (-viewport.offsetY) * previewScale + previewOffsetY;
                const viewportWidth = (viewport.containerWidth / viewport.scale) * previewScale;
                const viewportHeight = (viewport.containerHeight / viewport.scale) * previewScale;
                
                viewportBox.style.left = viewportLeft + 'px';
                viewportBox.style.top = viewportTop + 'px';
                viewportBox.style.width = viewportWidth + 'px';
                viewportBox.style.height = viewportHeight + 'px';
            }
            
            // 获取所有模块
            const moduleElements = document.querySelectorAll('.module');
            if (moduleElements.length === 0) {
                ctx.fillStyle = '#999999';
                ctx.fillText('暂无模块', 5, 30);
                return;
            }
            
            // 绘制模块
            moduleElements.forEach(module => {
                const moduleId = module.dataset.moduleId;
                const moduleState = moduleStates[moduleId];
                if (!moduleState) {
                    return;
                }
                
                // 获取模块位置和尺寸
                const left = parseFloat(module.style.left) || 0;
                const top = parseFloat(module.style.top) || 0;
                const width = module.offsetWidth;
                const height = module.offsetHeight;
                
                // 计算预览图中的位置和尺寸
                const previewLeft = left * previewScale + previewOffsetX;
                const previewTop = top * previewScale + previewOffsetY;
                const previewWidth = width * previewScale;
                const previewHeight = height * previewScale;
                
                // 绘制模块
                ctx.fillStyle = '#4CAF50';
                ctx.fillRect(previewLeft, previewTop, previewWidth, previewHeight);
                
                // 绘制模块边框
                ctx.strokeStyle = '#2e7d32';
                ctx.lineWidth = 1;
                ctx.strokeRect(previewLeft, previewTop, previewWidth, previewHeight);
            });
            
            // 绘制连线
            connectionLines.forEach(connection => {
                const startModuleId = connection.startModuleId;
                const endModuleId = connection.endModuleId;
                
                const startModule = document.querySelector(`.module[data-module-id="${startModuleId}"]`);
                const endModule = document.querySelector(`.module[data-module-id="${endModuleId}"]`);
                
                if (!startModule || !endModule) {
                    return;
                }
                
                // 获取起始模块和结束模块的位置
                const startLeft = parseFloat(startModule.style.left) || 0;
                const startTop = parseFloat(startModule.style.top) || 0;
                const endLeft = parseFloat(endModule.style.left) || 0;
                const endTop = parseFloat(endModule.style.top) || 0;
                
                // 获取模块尺寸
                const startWidth = startModule.offsetWidth;
                const startHeight = startModule.offsetHeight;
                const endWidth = endModule.offsetWidth;
                const endHeight = endModule.offsetHeight;
                
                // 计算连线的起始点和结束点（模块中心）
                const startX = (startLeft + startWidth / 2) * previewScale + previewOffsetX;
                const startY = (startTop + startHeight / 2) * previewScale + previewOffsetY;
                const endX = (endLeft + endWidth / 2) * previewScale + previewOffsetX;
                const endY = (endTop + endHeight / 2) * previewScale + previewOffsetY;
                
                // 绘制连线
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.strokeStyle = connection.isRed ? '#f44336' : '#666666';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }
        
        function sendMessage() {
            const input = document.getElementById('chat-input');
            const message = input.value.trim();
            if (message) {
                // 存储用户输入
                userInput = message;
                
                // 添加用户消息
                addMessage('user', message);
                input.value = '';
                
                // 设置运行触发方式为对话
                runTrigger = 'chat';
                console.log('通过对话激活流程，runTrigger:', runTrigger);
                
                // 用户输入触发执行
                console.log('用户输入触发执行');
                startAutoRun();
            }
        }
        
        // 获取用户输入
        function getUserInput() {
            return userInput;
        }
        
        // 输出消息到对话面板
        function outputToChatPanel(content) {
            if (content) {
                addMessage('ai', content);
            }
        }
        
        function addMessage(type, content) {
            const messagesContainer = document.getElementById('chat-messages');
            const messageElement = document.createElement('div');
            messageElement.className = `message ${type}`;
            messageElement.textContent = content;
            messagesContainer.appendChild(messageElement);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        // 画布事件监听
        canvas.addEventListener('dragover', handleCanvasDragOver);
        canvas.addEventListener('drop', handleCanvasDrop);
        
        // 初始化加载模块
        window.onload = function() {
            loadModules().then(() => {
                // 先尝试加载缓存
                fetch('/api/load_cache')
                    .then(response => response.json())
                    .then(result => {
                        if (result.success) {
                            console.log('缓存加载成功:', result.file_path);
                            processCacheData(result.cache_data);
                        } else {
                            console.log('没有找到缓存，创建默认user输入模块');
                            // 在(0,0)坐标处创建user输入模块
                            // 查找user输入模块的数据
                            let userInputModuleData = null;
                            for (const [name, params] of Object.entries(modules)) {
                                if (params.name === 'user输入') {
                                    userInputModuleData = {
                                        name: name,
                                        params: params
                                    };
                                    break;
                                }
                            }
                            
                            // 如果找到user输入模块，创建它
                            if (userInputModuleData) {
                                createModuleOnCanvas(userInputModuleData, 110, 40); // 调整坐标以确保模块完全可见
                            }
                        }
                    })
                    .catch(error => {
                        console.error('加载缓存失败，创建默认user输入模块:', error);
                        // 在(0,0)坐标处创建user输入模块
                        // 查找user输入模块的数据
                        let userInputModuleData = null;
                        for (const [name, params] of Object.entries(modules)) {
                            if (params.name === 'user输入') {
                                userInputModuleData = {
                                    name: name,
                                    params: params
                                };
                                break;
                            }
                        }
                        
                        // 如果找到user输入模块，创建它
                        if (userInputModuleData) {
                            createModuleOnCanvas(userInputModuleData, 110, 40); // 调整坐标以确保模块完全可见
                        }
                    });
            });
            initCollapseButtons();
            initZoomControls();
            initModuleDragDelete();
            initControlButtons();
        };
        
        // 保存界面缓存
        function saveCache() {
            try {
                // 收集所有模块的信息
                const modules = [];
                document.querySelectorAll('.module').forEach(module => {
                    const moduleId = module.dataset.moduleId;
                    const moduleState = moduleStates[moduleId];
                    if (moduleState) {
                        // 读取模块设置
                        const moduleKey = `module_settings_${moduleId}_${moduleState.moduleData.params.name || 'default'}`;
                        const savedSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
                        
                        // 获取输入值
                        let inputValue = '';
                        const inputElement = module.querySelector('.module-input');
                        if (inputElement) {
                            inputValue = inputElement.value;
                        } else {
                            const inputValueElement = module.querySelector('.input-value');
                            if (inputValueElement) {
                                inputValue = inputValueElement.textContent === '请输入固定值' ? '' : inputValueElement.textContent;
                            }
                        }
                        
                        modules.push({
                            id: moduleId,
                            name: moduleState.moduleData.params.name,
                            kind: moduleState.moduleData.params.kind,
                            left: module.style.left,
                            top: module.style.top,
                            moduleData: moduleState.moduleData, // 保存当前的moduleData（就是保存时刻的模块数据）
                            settings: savedSettings,
                            inputValue: inputValue
                        });
                    }
                });
                
                // 收集所有连接的信息
                const connections = connectionLines.map(conn => ({
                    startModuleId: conn.startModuleId,
                    startPortIndex: conn.startPortIndex,
                    endModuleId: conn.endModuleId,
                    endPortIndex: conn.endPortIndex,
                    isRed: conn.isRed || false
                }));
                
                // 构建缓存数据
                const cacheData = {
                    version: '1.0',
                    modules: modules,
                    connections: connections,
                    canvasSize: canvasSize,
                    timestamp: new Date().toISOString()
                };
                
                // 发送POST请求到服务器保存缓存
                fetch('/api/save_cache', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ cache_data: cacheData })
                })
                .then(response => response.json())
                .then(result => {
                    if (result.success) {
                        console.log('缓存保存成功:', result.file_path);
                    } else {
                        console.error('保存缓存失败:', result.error);
                    }
                })
                .catch(error => {
                    console.error('保存缓存失败:', error);
                });
            } catch (error) {
                console.error('保存缓存失败:', error);
            }
        }
        
        // 加载界面缓存
        function loadCache() {
            try {
                // 发送GET请求到服务器加载最新的缓存
                fetch('/api/load_cache')
                .then(response => response.json())
                .then(result => {
                    if (result.success) {
                        console.log('缓存加载成功:', result.file_path);
                        const cacheData = result.cache_data;
                        
                        // 处理缓存数据
                        processCacheData(cacheData);
                    } else {
                        console.log('没有找到缓存:', result.error);
                    }
                })
                .catch(error => {
                    console.error('加载缓存失败:', error);
                });
            } catch (error) {
                console.error('加载缓存失败:', error);
            }
        }
        
        // 处理缓存数据 - 直接套用导入项目的代码
        function processCacheData(cacheData) {
            try {
                // 版本兼容处理
                const processedProjectData = processProjectData(cacheData);
                
                // 清除当前画布上的所有模块和连接
                document.querySelectorAll('.module').forEach(module => module.remove());
                document.querySelectorAll('.connection-line').forEach(line => line.remove());
                connectionLines = [];
                
                // 恢复画布大小
                if (processedProjectData.canvasSize) {
                    canvasSize.width = processedProjectData.canvasSize.width;
                    canvasSize.height = processedProjectData.canvasSize.height;
                    canvasContent.style.width = `${canvasSize.width}px`;
                    canvasContent.style.height = `${canvasSize.height}px`;
                }
                
                // 重新创建模块
                const moduleIdMap = {}; // 用于映射旧ID到新ID
                let incompatibleModules = 0;
                processedProjectData.modules.forEach(moduleInfo => {
                    const moduleName = moduleInfo.moduleData.name;
                    
                    let actualModuleData = moduleInfo.moduleData;
                    let useCurrentModule = false;
                    
                    if (modules[moduleName]) {
                        actualModuleData = {
                            name: moduleName,
                            params: modules[moduleName]
                        };
                        useCurrentModule = true;
                        console.log(`使用当前模块库数据: ${moduleName}`);
                    }
                    
                    const isCompatible = isModuleCompatible(moduleInfo.moduleData);
                    
                    const module = document.createElement('div');
                    module.className = 'module';
                    module.style.left = moduleInfo.left;
                    module.style.top = moduleInfo.top;
                    module.style.width = '220px';
                    module.style.minWidth = '220px';
                    module.style.maxWidth = '220px';
                    module.style.boxSizing = 'border-box';
                    
                    if (!isCompatible) {
                        module.classList.add('error');
                        incompatibleModules++;
                        console.log(`标记模块为错误: ${moduleName}`);
                    }
                    
                    const newModuleId = generateModuleId();
                    module.dataset.moduleId = newModuleId;
                    moduleIdMap[moduleInfo.id] = newModuleId;
                    
                    const moduleContent = generateModuleContent(actualModuleData);
                    module.innerHTML = moduleContent;
                    
                    canvasContent.appendChild(module);
                    
                    addModuleEventListeners(module);
                    
                    const inputQuantity = actualModuleData.params.input_quantity || 0;
                    const outputQuantity = actualModuleData.params.output_quantity || 0;
                    
                    moduleStates[newModuleId] = {
                        moduleData: actualModuleData,
                        inputValues: new Array(inputQuantity).fill(null),
                        outputValues: new Array(outputQuantity).fill(null),
                        executed: false,
                        executing: false,
                        isCompatible: isCompatible
                    };
                    
                    // 恢复模块设置
                    if (moduleInfo.settings) {
                        const moduleKey = `module_settings_${newModuleId}_${moduleInfo.moduleData.params.name || 'default'}`;
                        sessionStorage.setItem(moduleKey, JSON.stringify(moduleInfo.settings));
                    }
                    
                    // 恢复输入值
                    if (moduleInfo.inputValue !== undefined) {
                        const inputElement = module.querySelector('.module-input');
                        if (inputElement) {
                            inputElement.value = moduleInfo.inputValue;
                        } else {
                            const inputValueElement = module.querySelector('.input-value');
                            if (inputValueElement) {
                                inputValueElement.textContent = moduleInfo.inputValue || '请输入固定值';
                            }
                        }
                    }
                });
                
                // 重新创建连接
                processedProjectData.connections.forEach(connInfo => {
                    const startModuleId = moduleIdMap[connInfo.startModuleId];
                    const endModuleId = moduleIdMap[connInfo.endModuleId];
                    
                    if (startModuleId && endModuleId) {
                        const startModule = document.querySelector(`.module[data-module-id="${startModuleId}"]`);
                        const endModule = document.querySelector(`.module[data-module-id="${endModuleId}"]`);
                        
                        if (startModule && endModule) {
                            const startPort = startModule.querySelectorAll('.output-port')[connInfo.startPortIndex];
                            const endPort = endModule.querySelectorAll('.input-port')[connInfo.endPortIndex];
                            
                            if (startPort && endPort) {
                                // 创建连接
                                createConnection(startPort, endPort, connInfo.isRed);
                            }
                        }
                    }
                });
                
                // 重新初始化画布，确保缩放和偏移量正确
                initZoomControls();
                
                console.log('项目加载成功:', processedProjectData);
                if (incompatibleModules > 0) {
                    showNotification(`项目加载成功！发现 ${incompatibleModules} 个不兼容的模块（已标记为红色）`);
                } else {
                    showNotification('项目加载成功！');
                }
            } catch (error) {
                console.error('加载zip文件失败:', error);
                alert('加载文件失败，请确保文件格式正确。');
            }
        }
        
        // 初始化控制按钮事件
        function initControlButtons() {
            // 运行按钮
            document.getElementById('run-btn').addEventListener('click', function() {
                // 设置运行触发方式为按钮
                runTrigger = 'button';
                console.log('通过运行按钮激活流程，runTrigger:', runTrigger);
                
                startAutoRun();
            });
            
            // 停止按钮
            document.getElementById('stop-btn').addEventListener('click', function() {
                stopExecution();
            });
            
            // 连续运行按钮
            document.getElementById('continuous-run-btn').addEventListener('click', function() {
                // 打开连续运行设置模态框
                document.getElementById('continuous-run-modal').style.display = 'flex';
            });
            
            // 生成代码按钮 - 打开文件转换界面
            document.getElementById('generate-code-btn').addEventListener('click', function() {
                // 创建文件转换界面模态框
                const modal = document.createElement('div');
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background-color: rgba(0, 0, 0, 0.5);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 10000;
                `;
                
                const modalContent = document.createElement('div');
                modalContent.style.cssText = `
                    background-color: white;
                    padding: 30px;
                    border-radius: 8px;
                    width: 80%;
                    max-width: 700px;
                    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
                `;
                
                const modalHeader = document.createElement('div');
                modalHeader.style.cssText = `
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 20px;
                    padding-bottom: 10px;
                    border-bottom: 1px solid #ddd;
                `;
                
                const modalTitle = document.createElement('h2');
                modalTitle.textContent = '工作流转 Python 代码';
                modalTitle.style.margin = '0';
                
                const closeBtn = document.createElement('button');
                closeBtn.textContent = '关闭';
                closeBtn.style.cssText = `
                    padding: 8px 16px;
                    background-color: #f44336;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                closeBtn.addEventListener('click', function() {
                    document.body.removeChild(modal);
                });
                
                modalHeader.appendChild(modalTitle);
                modalHeader.appendChild(closeBtn);
                
                const fileInputSection = document.createElement('div');
                fileInputSection.style.cssText = 'margin-bottom: 20px;';
                fileInputSection.innerHTML = `
                    <h3 style="margin-bottom: 10px;">1. 选择文件</h3>
                    <p style="color: #666; margin-bottom: 10px;">支持 .aiud 或 .json 格式的工作流文件</p>
                    <input type="file" id="workflow-file-input" accept=".aiud,.json" style="
                        width: 100%;
                        padding: 10px;
                        border: 2px dashed #ccc;
                        border-radius: 4px;
                        cursor: pointer;
                    ">
                `;
                
                const previewSection = document.createElement('div');
                previewSection.id = 'workflow-preview';
                previewSection.style.cssText = 'margin-bottom: 20px; display: none;';
                previewSection.innerHTML = `
                    <h3 style="margin-bottom: 10px;">2. 文件预览</h3>
                    <div id="workflow-info" style="
                        background-color: #f9f9f9;
                        padding: 15px;
                        border-radius: 4px;
                        font-size: 14px;
                    "></div>
                `;
                
                const codeSection = document.createElement('div');
                codeSection.id = 'code-section';
                codeSection.style.cssText = 'margin-bottom: 20px; display: none;';
                codeSection.innerHTML = `
                    <h3 style="margin-bottom: 10px;">3. 生成的 Python 代码</h3>
                    <div id="code-container" style="
                        background-color: #f5f5f5;
                        padding: 15px;
                        border-radius: 4px;
                        font-family: 'Courier New', monospace;
                        white-space: pre-wrap;
                        line-height: 1.4;
                        max-height: 400px;
                        overflow: auto;
                    "></div>
                `;
                
                const buttonContainer = document.createElement('div');
                buttonContainer.style.cssText = 'display: flex; gap: 10px; justify-content: flex-end;';
                
                const generateBtn = document.createElement('button');
                generateBtn.id = 'generate-from-file-btn';
                generateBtn.textContent = '生成代码';
                generateBtn.disabled = true;
                generateBtn.style.cssText = `
                    padding: 10px 20px;
                    background-color: #4CAF50;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                
                const copyBtn = document.createElement('button');
                copyBtn.id = 'copy-generated-code-btn';
                copyBtn.textContent = '复制代码';
                copyBtn.style.display = 'none';
                copyBtn.style.cssText = `
                    padding: 10px 20px;
                    background-color: #2196F3;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                
                const downloadBtn = document.createElement('button');
                downloadBtn.id = 'download-generated-code-btn';
                downloadBtn.textContent = '下载代码';
                downloadBtn.style.display = 'none';
                downloadBtn.style.cssText = `
                    padding: 10px 20px;
                    background-color: #FF9800;
                    color: white;
                    border: none;
                    border-radius: 4px;
                    cursor: pointer;
                `;
                
                buttonContainer.appendChild(generateBtn);
                buttonContainer.appendChild(copyBtn);
                buttonContainer.appendChild(downloadBtn);
                
                modalContent.appendChild(modalHeader);
                modalContent.appendChild(fileInputSection);
                modalContent.appendChild(previewSection);
                modalContent.appendChild(codeSection);
                modalContent.appendChild(buttonContainer);
                modal.appendChild(modalContent);
                
                document.body.appendChild(modal);
                
                // 存储当前文件数据
                let currentWorkflowData = null;
                let generatedCode = '';
                
                // 文件选择事件
                const fileInput = document.getElementById('workflow-file-input');
                fileInput.addEventListener('change', async function(e) {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    try {
                        let jsonData = null;
                        
                        // 检查是否为 .aiud 文件（ZIP 格式）
                        if (file.name.toLowerCase().endsWith('.aiud')) {
                            // 尝试用 JSZip 解压
                            try {
                                const zip = new JSZip();
                                const zipContent = await zip.loadAsync(file);
                                
                                // 检查是否包含 project.json
                                if (zipContent.file('project.json')) {
                                    const projectJsonContent = await zipContent.file('project.json').async('string');
                                    jsonData = JSON.parse(projectJsonContent);
                                } else {
                                    alert('aiud 文件中没有找到 project.json');
                                    return;
                                }
                            } catch (zipError) {
                                console.error('解压 aiud 文件失败:', zipError);
                                alert('解压 aiud 文件失败，请检查文件是否有效');
                                return;
                            }
                        } else {
                            // 否则作为纯 JSON 文件处理
                            const reader = new FileReader();
                            reader.onload = async function(event) {
                                try {
                                    jsonData = JSON.parse(event.target.result);
                                    processWorkflowData(jsonData, file.name);
                                } catch (parseError) {
                                    alert('文件解析失败，请确保是有效的 JSON 格式');
                                }
                            };
                            reader.readAsText(file);
                            return; // 对于非 aiud 文件，交给上面的 onload 处理
                        }
                        
                        // 如果是 aiud 文件，直接处理
                        if (jsonData) {
                            processWorkflowData(jsonData, file.name);
                        }
                    } catch (error) {
                        alert('文件读取失败: ' + error.message);
                    }
                    
                    // 处理工作流数据的函数
                    function processWorkflowData(data, fileName) {
                        currentWorkflowData = data;
                        
                        // 显示文件预览
                        const previewInfo = document.getElementById('workflow-info');
                        const modulesCount = currentWorkflowData.modules ? currentWorkflowData.modules.length : 0;
                        const connectionsCount = currentWorkflowData.connections ? currentWorkflowData.connections.length : 0;
                        
                        previewInfo.innerHTML = `
                            <div><strong>文件名:</strong> ${fileName}</div>
                            <div><strong>模块数量:</strong> ${modulesCount}</div>
                            <div><strong>连接数量:</strong> ${connectionsCount}</div>
                            ${currentWorkflowData.timestamp ? `<div><strong>创建时间:</strong> ${currentWorkflowData.timestamp}</div>` : ''}
                        `;
                        
                        document.getElementById('workflow-preview').style.display = 'block';
                        document.getElementById('generate-from-file-btn').disabled = false;
                    }
                });
                
                // 生成代码按钮事件
                generateBtn.addEventListener('click', async function() {
                    if (!currentWorkflowData) {
                        alert('请先选择一个工作流文件');
                        return;
                    }
                    
                    try {
                        generateBtn.disabled = true;
                        generateBtn.textContent = '正在生成...';
                        
                        // 调用后端 AST API 生成代码
                        const response = await fetch('/api/generate_code_ast', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                workflow: currentWorkflowData
                            })
                        });
                        
                        if (!response.ok) {
                            throw new Error(`API请求失败: ${response.status}`);
                        }
                        
                        const result = await response.json();
                        
                        if (!result.success) {
                            throw new Error(result.error || '生成代码失败');
                        }
                        
                        generatedCode = result.source_code;
                        
                        // 显示生成的代码
                        const codeContainer = document.getElementById('code-container');
                        codeContainer.textContent = generatedCode;
                        document.getElementById('code-section').style.display = 'block';
                        
                        // 显示复制和下载按钮
                        document.getElementById('copy-generated-code-btn').style.display = 'inline-block';
                        document.getElementById('download-generated-code-btn').style.display = 'inline-block';
                        
                        generateBtn.disabled = false;
                        generateBtn.textContent = '生成代码';
                    } catch (error) {
                        alert('生成代码失败: ' + error.message);
                        generateBtn.disabled = false;
                        generateBtn.textContent = '生成代码';
                    }
                });
                
                // 复制代码按钮事件
                copyBtn.addEventListener('click', function() {
                    if (generatedCode) {
                        navigator.clipboard.writeText(generatedCode).then(function() {
                            alert('代码已复制到剪贴板');
                        }).catch(function(err) {
                            console.error('复制失败:', err);
                        });
                    }
                });
                
                // 下载代码按钮事件
                downloadBtn.addEventListener('click', function() {
                    if (generatedCode) {
                        const blob = new Blob([generatedCode], { type: 'text/plain' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = 'workflow_to_code.py';
                        a.click();
                        URL.revokeObjectURL(url);
                    }
                });
            });
            

            
            // 从工作流数据生成Python代码的函数
            async function generateCodeFromWorkflow(workflowData) {
                // 第一步：收集模块信息
                const modules = workflowData.modules || [];
                const connections = workflowData.connections || [];
                
                const allModuleInfo = new Map();
                modules.forEach(module => {
                    allModuleInfo.set(module.id, {
                        id: module.id,
                        name: module.name,
                        kind: module.kind,
                        moduleData: module.moduleData,
                        settings: module.settings || {},
                        fileName: module.moduleData?.name || module.name
                    });
                });
                
                // 第二步：计算拓扑排序的执行顺序
                // 构建依赖图
                const dependencies = new Map();
                const dependents = new Map();
                
                // 初始化所有模块的依赖关系
                modules.forEach(module => {
                    dependencies.set(module.id, []);
                    dependents.set(module.id, []);
                });
                
                // 填充依赖关系
                connections.forEach(conn => {
                    const startModuleId = conn.startModuleId;
                    const endModuleId = conn.endModuleId;
                    
                    // endModule 依赖于 startModule
                    if (!dependencies.has(endModuleId)) {
                        dependencies.set(endModuleId, []);
                    }
                    if (!dependencies.get(endModuleId).includes(startModuleId)) {
                        dependencies.get(endModuleId).push(startModuleId);
                    }
                    
                    // startModule 被 endModule 依赖
                    if (!dependents.has(startModuleId)) {
                        dependents.set(startModuleId, []);
                    }
                    if (!dependents.get(startModuleId).includes(endModuleId)) {
                        dependents.get(startModuleId).push(endModuleId);
                    }
                });
                
                // Kahn算法进行拓扑排序
                const inDegree = new Map();
                const queue = [];
                const executionOrder = [];
                
                // 计算每个模块的入度
                modules.forEach(module => {
                    const deps = dependencies.get(module.id) || [];
                    inDegree.set(module.id, deps.length);
                    if (deps.length === 0) {
                        queue.push(module.id);
                    }
                });
                
                while (queue.length > 0) {
                    const moduleId = queue.shift();
                    executionOrder.push(moduleId);
                    
                    const moduleDependents = dependents.get(moduleId) || [];
                    for (const dependentId of moduleDependents) {
                        const currentDegree = inDegree.get(dependentId) - 1;
                        inDegree.set(dependentId, currentDegree);
                        if (currentDegree === 0) {
                            queue.push(dependentId);
                        }
                    }
                }
                
                // 第三步：收集这些模块的详细信息
                const modulesInOrder = executionOrder.map(moduleId => allModuleInfo.get(moduleId));
                
                // 第四步：获取所有需要的模块源代码
                const moduleSources = new Map();
                for (const moduleInfo of modulesInOrder) {
                    try {
                        const response = await fetch('/api/get_module_source', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ module_name: moduleInfo.fileName })
                        });
                        
                        if (response.ok) {
                            const data = await response.json();
                            moduleSources.set(moduleInfo.id, {
                                ...moduleInfo,
                                source_code: data.source_code,
                                module_params: data.module_params
                            });
                        }
                    } catch (error) {
                        console.error(`获取模块 ${moduleInfo.name} 源代码失败:`, error);
                    }
                }
                
                // 第五步：识别user输入模块和固定值输出模块
                const userInputModules = [];
                const fixedValueModules = [];
                modulesInOrder.forEach(moduleInfo => {
                    if (moduleInfo.name === 'user输入') {
                        userInputModules.push(moduleInfo);
                    } else if (moduleInfo.name === '固定值输出模块') {
                        fixedValueModules.push(moduleInfo);
                    }
                });
                
                // 第六步：构建函数参数
                const functionParams = [];
                userInputModules.forEach((m, i) => {
                    functionParams.push(`user_input_${i + 1}`);
                });
                fixedValueModules.forEach((m, i) => {
                    functionParams.push(`fixed_value_${i + 1}`);
                });
                
                // 模块ID到更友好的变量名映射
                const moduleIdToVarName = new Map();
                const settingNameMap = new Map();
                modulesInOrder.forEach((moduleInfo, idx) => {
                    const safeName = moduleInfo.name.replace(/[^a-zA-Z0-9_]/g, '_');
                    const varName = `${safeName}_${idx + 1}`;
                    moduleIdToVarName.set(moduleInfo.id, varName);
                    settingNameMap.set(moduleInfo.id, new Map());
                });
                
                // 第七步：开始生成代码
                let code = '#!/usr/bin/env python3\n';
                code += '# -*- coding: utf-8 -*-\n';
                code += '"""\n';
                code += '图形化编程生成的Python代码\n';
                code += '\n';
                code += '功能: 根据图形化编程工作流自动生成的代码\n';
                code += '"""\n';
                code += '\n';
                
                // 第八步：生成全局变量（设置值）
                code += '# ====================================\n';
                code += '# 全局变量设置（模块设置值）\n';
                code += '# ====================================\n';
                code += '\n';
                
                modulesInOrder.forEach(moduleInfo => {
                    const settings = moduleInfo.settings;
                    const moduleVarName = moduleIdToVarName.get(moduleInfo.id);
                    const moduleSettingMap = settingNameMap.get(moduleInfo.id);
                    
                    // 直接从 moduleInfo 的 moduleData 中获取参数（更可靠）
                    const moduleParams = moduleInfo.moduleData?.params || {};
                    const variablesName = moduleParams.variables_name || '';
                    const inputQuantity = moduleParams.input_quantity || 0;
                    const variableQuantity = moduleParams.variable_quantity || 0;
                    
                    // 从 variables_name 中获取设置变量名（跳过 input_quantity 个输入，只取后面的设置变量）
                    const settingVarNames = variablesName.split(',').map(v => v.trim()).filter(v => v);
                    const actualSettingNames = settingVarNames.slice(inputQuantity);
                    
                    if (Object.keys(settings).length > 0) {
                        code += `# 模块: ${moduleInfo.name}\n`;
                        
                        // 使用 actualSettingNames 作为正确的设置变量名
                        let settingIdx = 0;
                        const settingEntries = Object.entries(settings);
                        
                        for (let i = 0; i < actualSettingNames.length && settingIdx < settingEntries.length; i++) {
                            const paramName = actualSettingNames[i];
                            const [key, value] = settingEntries[settingIdx];
                            
                            if (!paramName) {
                                settingIdx++;
                                continue;
                            }
                            
                            const safeParamName = paramName.replace(/[^a-zA-Z0-9_]/g, '_');
                            const settingVarName = `SETTING_${moduleVarName}_${safeParamName}`;
                            
                            // 同时用两种方式映射：用 paramName 和 key 都映射
                            moduleSettingMap.set(paramName, settingVarName);
                            moduleSettingMap.set(key, settingVarName);
                            
                            // 处理值
                            let outputValue = value;
                            
                            // 修复布尔值问题
                            if (typeof value === 'string') {
                                if (value.toLowerCase() === 'true') {
                                    outputValue = 'True';
                                } else if (value.toLowerCase() === 'false') {
                                    outputValue = 'False';
                                } else {
                                    outputValue = JSON.stringify(value);
                                }
                            } else if (typeof value === 'boolean') {
                                outputValue = value ? 'True' : 'False';
                            }
                            
                            code += `${settingVarName} = ${outputValue}\n`;
                            
                            settingIdx++;
                        }
                        
                        // 如果还有剩余的设置没有匹配到 paramName，直接用 key
                        for (; settingIdx < settingEntries.length; settingIdx++) {
                            const [key, value] = settingEntries[settingIdx];
                            const safeKey = key.replace(/[^a-zA-Z0-9_]/g, '_');
                            const settingVarName = `SETTING_${moduleVarName}_${safeKey}`;
                            moduleSettingMap.set(key, settingVarName);
                            
                            let outputValue = value;
                            
                            if (typeof value === 'string') {
                                if (value.toLowerCase() === 'true') {
                                    outputValue = 'True';
                                } else if (value.toLowerCase() === 'false') {
                                    outputValue = 'False';
                                } else {
                                    outputValue = JSON.stringify(value);
                                }
                            } else if (typeof value === 'boolean') {
                                outputValue = value ? 'True' : 'False';
                            }
                            
                            code += `${settingVarName} = ${outputValue}\n`;
                        }
                        
                        code += '\n';
                    }
                });
                
                code += '\n';
                code += '# ====================================\n';
                code += '# 模块执行函数\n';
                code += '# ====================================\n';
                code += '\n';
                
                // 防止模块重复
                const addedModules = new Set();
                
                // 第九步：添加各个模块的execute函数
                for (const moduleInfo of modulesInOrder) {
                    const sourceData = moduleSources.get(moduleInfo.id);
                    if (!sourceData) continue;
                    
                    const fileName = moduleInfo.fileName;
                    if (addedModules.has(fileName)) {
                        continue; // 防止重复添加相同模块
                    }
                    addedModules.add(fileName);
                    
                    const sourceCode = sourceData.source_code;
                    
                    code += `# ------------------------------\n`;
                    code += `# 模块: ${moduleInfo.name}\n`;
                    code += `# ------------------------------\n`;
                    
                    // 提取模块代码并清理
                    const lines = sourceCode.split('\n');
                    let inExecute = false;
                    let executeFuncStart = -1;
                    let executeFuncEnd = -1;
                    let bracketCount = 0;
                    
                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i];
                        
                        if (!inExecute && line.trim().startsWith('def execute(')) {
                            inExecute = true;
                            executeFuncStart = i;
                            bracketCount = 0;
                        }
                        
                        if (inExecute) {
                            // 计算括号数量来确定函数结束位置
                            for (const char of line) {
                                if (char === '{') bracketCount++;
                                if (char === '}') bracketCount--;
                            }
                            
                            // Python 用缩进来确定，所以简单处理：遇到下一个 def 或非缩进代码停止
                            if (i > executeFuncStart && !line.startsWith('    ') && !line.startsWith('\t') && line.trim() && !line.trim().startsWith('#')) {
                                if (executeFuncEnd === -1) {
                                    executeFuncEnd = i;
                                }
                            }
                        }
                    }
                    
                    // 如果找不到结束，就用直到文件结束
                    if (executeFuncEnd === -1) {
                        executeFuncEnd = lines.length;
                    }
                    
                    // 提取 execute 函数
                    let processedCode = '';
                    if (executeFuncStart !== -1) {
                        // 提取 execute 函数
                        let executeLines = lines.slice(executeFuncStart, executeFuncEnd);
                        
                        // 移除开头的注释参数（直到第一个非注释）
                        let startIdx = 0;
                        while (startIdx < executeLines.length && executeLines[startIdx].trim().startsWith('#')) {
                            startIdx++;
                        }
                        
                        executeLines = executeLines.slice(startIdx);
                        
                        // 重命名 execute 函数
                        const moduleVarName = moduleIdToVarName.get(moduleInfo.id);
                        const funcName = `execute_${moduleVarName}`;
                        processedCode = executeLines.join('\n').replace(/def execute\(/g, `def ${funcName}(`);
                        
                        // 清理多余的空行
                        processedCode = processedCode.replace(/\n{3,}/g, '\n\n');
                    }
                    
                    // 如果提取失败，用简单处理
                    if (!processedCode) {
                        processedCode = sourceCode;
                        // 跳过开头的注释参数
                        const linesSimple = sourceCode.split('\n');
                        let skipComments = true;
                        let codeLinesSimple = [];
                        
                        for (const line of linesSimple) {
                            if (skipComments && line.trim().startsWith('#')) {
                                continue;
                            }
                            skipComments = false;
                            codeLinesSimple.push(line);
                        }
                        
                        processedCode = codeLinesSimple.join('\n');
                        
                        // 重命名execute函数
                        const moduleVarName = moduleIdToVarName.get(moduleInfo.id);
                        const funcName = `execute_${moduleVarName}`;
                        processedCode = processedCode.replace(/def execute\(/g, `def ${funcName}(`);
                        
                        // 移除测试代码（if __name__ == "__main__": 后面的部分）
                        const testCodeIdx = processedCode.indexOf('if __name__ == "__main__":');
                        if (testCodeIdx !== -1) {
                            processedCode = processedCode.substring(0, testCodeIdx);
                        }
                    }
                    
                    code += processedCode;
                    code += '\n\n';
                }
                
                code += '\n';
                code += '# ====================================\n';
                code += '# 主执行函数\n';
                code += '# ====================================\n';
                code += '\n';
                
                // 第十步：生成主函数
                const paramStr = functionParams.length > 0 ? functionParams.join(', ') : '';
                code += `def main(${paramStr}):\n`;
                code += '    """\n';
                code += '    主执行函数\n';
                code += '    \n';
                code += '    参数:\n';
                userInputModules.forEach((m, i) => {
                    code += `    - user_input_${i + 1}: 用户输入 ${i + 1}\n`;
                });
                fixedValueModules.forEach((m, i) => {
                    code += `    - fixed_value_${i + 1}: 固定值 ${i + 1}\n`;
                });
                code += '    \n';
                code += '    返回:\n';
                code += '    - 执行结果\n';
                code += '    """\n';
                code += '    \n';
                code += '    # 初始化变量存储\n';
                code += '    module_outputs = {}\n';
                code += '    \n';
                
                // 第十一步：设置user输入和固定值输出
                userInputModules.forEach((m, i) => {
                    code += `    # 用户输入模块 ${m.name}\n`;
                    code += `    module_outputs['${m.id}'] = [user_input_${i + 1}]\n`;
                    code += '    \n';
                });
                
                fixedValueModules.forEach((m, i) => {
                    code += `    # 固定值输出模块 ${m.name}\n`;
                    code += `    module_outputs['${m.id}'] = [fixed_value_${i + 1}]\n`;
                    code += '    \n';
                });
                
                // 第十二步：按执行顺序调用各个模块
                modulesInOrder.forEach(moduleInfo => {
                    if (moduleInfo.name === 'user输入' || moduleInfo.name === '固定值输出模块') {
                        return; // 已经处理过了
                    }
                    
                    const moduleVarName = moduleIdToVarName.get(moduleInfo.id);
                    const funcName = `execute_${moduleVarName}`;
                    const moduleSettingMap = settingNameMap.get(moduleInfo.id);
                    
                    code += `    # 执行模块: ${moduleInfo.name}\n`;
                    
                    // 收集输入参数
                    const inputConnections = connections.filter(conn => conn.endModuleId === moduleInfo.id);
                    
                    const sourceData = moduleSources.get(moduleInfo.id);
                    const moduleParams = sourceData?.module_params || {};
                    const inputQuantity = moduleParams.input_quantity || 0;
                    const variableQuantity = moduleParams.variable_quantity || 0;
                    const variablesName = moduleParams.variables_name || '';
                    const varNames = variablesName.split(',').map(v => v.trim()).filter(v => v);
                    
                    // 按端口索引排序
                    const sortedConnections = [...inputConnections].sort((a, b) => a.endPortIndex - b.endPortIndex);
                    
                    const inputs = [];
                    
                    for (let i = 0; i < inputQuantity; i++) {
                        const conn = sortedConnections.find(c => c.endPortIndex === i);
                        if (conn) {
                            const startModuleId = conn.startModuleId;
                            const startPortIndex = conn.startPortIndex;
                            inputs.push(`module_outputs['${startModuleId}'][${startPortIndex}]`);
                        } else {
                            inputs.push('None');
                        }
                    }
                    
                    // 添加设置参数
                    for (let i = inputQuantity; i < variableQuantity; i++) {
                        if (i < varNames.length) {
                            const key = varNames[i];
                            const settingVarName = moduleSettingMap.get(key);
                            if (settingVarName) {
                                inputs.push(settingVarName);
                            } else {
                                inputs.push('None');
                            }
                        } else {
                            inputs.push('None');
                        }
                    }
                    
                    const inputStr = inputs.join(', ');
                    
                    code += `    result_${moduleVarName} = ${funcName}(${inputStr})\n`;
                    
                    // 处理返回值
                    code += `    if not isinstance(result_${moduleVarName}, (list, tuple)):\n`;
                    code += `        result_${moduleVarName} = [result_${moduleVarName}]\n`;
                    code += `    module_outputs['${moduleInfo.id}'] = result_${moduleVarName}\n`;
                    code += '    \n';
                });
                
                code += '    # 返回最后一个模块的输出\n';
                if (modulesInOrder.length > 0) {
                    const lastModuleId = modulesInOrder[modulesInOrder.length - 1].id;
                    code += `    return module_outputs['${lastModuleId}']\n`;
                } else {
                    code += '    return None\n';
                }
                
                code += '\n';
                code += '\n';
                
                // 第十三步：添加示例调用
                code += '# ====================================\n';
                code += '# 示例用法\n';
                code += '# ====================================\n';
                code += '\n';
                
                code += 'if __name__ == "__main__":\n';
                code += '    # 示例1: 直接调用\n';
                
                if (functionParams.length > 0) {
                    code += '    # 传入参数调用:\n';
                    const exampleParams = functionParams.map((p, i) => {
                        if (p.startsWith('user_input')) return `"用户输入${i + 1}"`;
                        return `"固定值${i + 1}"`;
                    }).join(', ');
                    code += `    result = main(${exampleParams})\n`;
                } else {
                    code += '    result = main()\n';
                }
                
                code += '    print("执行结果:", result)\n';
                code += '\n';
                
                return code;
            }
            
            // 新建项目按钮

                
                // 生成Python代码
                let code = `#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
图形化编程生成的Python代码

功能: 根据图形化编程逻辑自动生成的代码
"""

import time
import requests
import json


def main(user_input=None):
    """主执行函数
    
    参数:
    - user_input: 用户输入内容，等效于浏览器中的用户输入
    
    返回:
    - AI的回复内容
    """
    # 获取用户输入
    if user_input is None:
        user_input = input("请输入内容: ")
    
    # 初始化变量
    context = ""
    dialogue = user_input
    
`;
                
                // 添加调用模块逻辑
                if (hasCallModule) {
                    code += '    # 调用AI模型\n';
                    code += '    def call_ai_model(dialogue, context=""):\n';
                    code += '        """调用AI模型获取回复"""\n';
                    code += '        # 模型设置\n';
                    code += '        model_source = "' + modelSource + '"\n';
                    code += '        api_key = "' + apiKey + '"\n';
                    code += '        model = "' + model + '"\n';
                    code += '        temperature = ' + temperature + '\n';
                    code += '        max_tokens = ' + maxTokens + '\n';
                    code += '        timeout = ' + timeout + '\n';
                    code += '        delay = ' + delay + '\n';
                    code += '        lmstudio_host = "' + lmstudioHost + '"\n';
                    code += '        lmstudio_model = "' + lmstudioModel + '"\n';
                    code += '        prompt = "' + prompt + '"\n';
                    code += '        \n';
                    code += '        # 处理延迟\n';
                    code += '        if delay > 0:\n';
                    code += '            time.sleep(delay)\n';
                    code += '        \n';
                    code += '        # 实际模型调用\n';
                    code += '        try:\n';
                    code += '            if model_source == "lmstudio":\n';
                    code += '                # 调用LM Studio API\n';
                    code += '                messages = [\n';
                    code += '                    {"role": "system", "content": "You are a helpful assistant."}\n';
                    code += '                ]\n';
                    code += '                \n';
                    code += '                # 添加上下文\n';
                    code += '                if context:\n';
                    code += '                    messages.append({"role": "system", "content": f"上下文信息: {context}"})\n';
                    code += '                \n';
                    code += '                # 添加用户对话\n';
                    code += '                if dialogue:\n';
                    code += '                    messages.append({"role": "user", "content": dialogue})\n';
                    code += '                \n';
                    code += '                # 构建请求数据\n';
                    code += '                payload = {\n';
                    code += '                    "model": lmstudio_model,\n';
                    code += '                    "messages": messages,\n';
                    code += '                    "temperature": temperature,\n';
                    code += '                    "max_tokens": max_tokens\n';
                    code += '                }\n';
                    code += '                \n';
                    code += '                # 发送请求\n';
                    code += '                response = requests.post(\n';
                    code += '                    f"{lmstudio_host}/v1/chat/completions",\n';
                    code += '                    headers={"Content-Type": "application/json"},\n';
                    code += '                    data=json.dumps(payload),\n';
                    code += '                    timeout=timeout\n';
                    code += '                )\n';
                    code += '                \n';
                    code += '                # 处理响应\n';
                    code += '                if response.status_code == 200:\n';
                    code += '                    response_data = response.json()\n';
                    code += '                    result = response_data["choices"][0]["message"]["content"]\n';
                    code += '                else:\n';
                    code += '                    result = f"调用LM Studio失败: {response.status_code} - {response.text}"\n';
                    code += '            else:\n';
                    code += '                # 其他模型来源的实现可以在这里添加\n';
                    code += '                result = "无法调用"\n';
                    code += '        except Exception as e:\n';
                    code += '            # 错误处理\n';
                    code += '            result = f"调用模型失败: {str(e)}"\n';
                    code += '        \n';
                    code += '        # 更新上下文\n';
                    code += '        if dialogue:\n';
                    code += '            updated_context = "用户: " + str(dialogue) + " AI: " + str(result)\n';
                    code += '        else:\n';
                    code += '            updated_context = result\n';
                    code += '        \n';
                    code += '        return result, updated_context\n';
                    code += '    \n';
                }
                
                // 添加缓存模块逻辑
                if (hasCacheModule) {
                    code += '    # 缓存处理\n';
                    code += '    def save_to_cache(data):\n';
                    code += '        """保存数据到缓存"""\n';
                    code += '        # 缓存设置\n';
                    code += '        cache_file = "' + cacheFile + '"\n';
                    code += '        cache_size = ' + cacheSize + '\n';
                    code += '        \n';
                    code += '        print(f"缓存内容: {data}")\n';
                    code += '        # 实际实现中可以添加文件写入或数据库操作\n';
                    code += '    \n';
                }
                
                // 添加比大小模块逻辑
                if (hasCompareModule) {
                    code += '    # 比大小逻辑\n';
                    code += '    def compare_values(a, b, operator="' + compareOperator + '"):\n';
                    code += '        """比较两个值的大小"""\n';
                    code += '        try:\n';
                    code += '            a = float(a)\n';
                    code += '            b = float(b)\n';
                    code += '            if operator == ">":\n';
                    code += '                return a > b\n';
                    code += '            elif operator == "<":\n';
                    code += '                return a < b\n';
                    code += '            elif operator == "==":\n';
                    code += '                return a == b\n';
                    code += '            elif operator == ">=":\n';
                    code += '                return a >= b\n';
                    code += '            elif operator == "<=":\n';
                    code += '                return a <= b\n';
                    code += '            else:\n';
                    code += '                return False\n';
                    code += '        except ValueError:\n';
                    code += '            return False\n';
                    code += '    \n';
                }
                
                // 添加主逻辑执行
                code += `    # 主逻辑执行
    print("开始处理...")
    
`;
                
                // 处理调用模块
                if (hasCallModule) {
                    code += `    # 执行AI模型调用
    ai_response, context = call_ai_model(dialogue, context)
    print(f"AI回复: {ai_response}")
    
`;
                }
                
                // 处理缓存模块
                if (hasCacheModule && hasCallModule) {
                    code += `    # 保存到缓存
    save_to_cache(ai_response)
    
`;
                }
                
                // 处理比大小模块
                if (hasCompareModule) {
                    code += '    # 执行比大小操作\n';
                    code += '    try:\n';
                    code += '        input_value = float(user_input)\n';
                    code += '        comparison_result = compare_values(input_value, 10)\n';
                    code += '        print("比较结果: " + str(input_value) + " ' + compareOperator + ' 10 = " + str(comparison_result))\n';
                    code += '    except ValueError:\n';
                    code += '        print("输入不是有效的数字，无法进行比较")\n';
                    code += '    \n';
                }
                
                // 添加返回语句
                code += `    # 返回结果
    print("处理完成")
`;
                
                if (hasCallModule) {
                    code += `    return ai_response
`;
                } else {
                    code += `    return user_input
`;
                }
                
                // 添加主函数调用
                code += `

if __name__ == "__main__":
    # 示例用法
    # 1. 传入参数调用
    # result = main("你的输入内容")
    
    # 2. 交互式调用
    user_input = input("请输入内容: ")
    result = main(user_input)
    print("\\n最终结果: " + str(result))
    print("\\n可以通过以下方式集成到其他代码中:")
    print("from generated_code import main")
    print("result = main('你的输入内容')")
`;
                
                return code;
            }
            
            // 新建项目按钮
            document.getElementById('new-project-btn').addEventListener('click', function() {
                // 弹出确认清空的弹窗
                if (confirm('确定要清空画布，创建新项目吗？')) {
                    // 清空中央画布
                    // 删除所有模块
                    document.querySelectorAll('.module').forEach(module => module.remove());
                    // 删除所有连接
                    document.querySelectorAll('.connection-line').forEach(line => line.remove());
                    // 清空连接数组
                    connectionLines = [];
                    // 清空模块状态
                    moduleStates = {};
                    // 重置模块计数器
                    moduleCounter = 0;
                    // 重置项目名
                    document.getElementById('project-name').textContent = '未命名项目';
                    // 重新创建user输入模块
                    loadFreshModules().then(() => {
                        let userInputModuleData = null;
                        for (const [name, params] of Object.entries(modules)) {
                            if (params.name === 'user输入') {
                                userInputModuleData = {
                                    name: name,
                                    params: params
                                };
                                break;
                            }
                        }
                        
                        // 如果找到user输入模块，创建它
                        if (userInputModuleData) {
                            createModuleOnCanvas(userInputModuleData, 110, 40); // 调整坐标以确保模块完全可见
                        }
                    });
                    console.log('新建项目成功，画布已清空');
                }
            });
            
            // 保存项目按钮
            document.getElementById('save-project-btn').addEventListener('click', async function() {
                try {
                    // 收集所有模块的信息
                    const modules = [];
                    const usedCustomModules = new Set();
                    document.querySelectorAll('.module').forEach(module => {
                        const moduleId = module.dataset.moduleId;
                        const moduleState = moduleStates[moduleId];
                        if (moduleState) {
                            // 读取模块设置
                            const moduleKey = `module_settings_${moduleId}_${moduleState.moduleData.params.name || 'default'}`;
                            const savedSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
                            
                            // 获取输入值
                            let inputValue = '';
                            const inputElement = module.querySelector('.module-input');
                            if (inputElement) {
                                inputValue = inputElement.value;
                            } else {
                                const inputValueElement = module.querySelector('.input-value');
                                if (inputValueElement) {
                                    inputValue = inputValueElement.textContent === '请输入固定值' ? '' : inputValueElement.textContent;
                                }
                            }
                            
                            modules.push({
                                id: moduleId,
                                name: moduleState.moduleData.params.name,
                                kind: moduleState.moduleData.params.kind,
                                left: module.style.left,
                                top: module.style.top,
                                moduleData: moduleState.moduleData,
                                settings: savedSettings,
                                inputValue: inputValue
                            });
                            
                            // 检查是否为自定义模块
                            if (moduleState.moduleData.params.source === 'custom') {
                                usedCustomModules.add(moduleState.moduleData.name);
                            }
                        }
                    });
                    
                    // 收集所有连接的信息
                    const connections = connectionLines.map(conn => ({
                        startModuleId: conn.startModuleId,
                        startPortIndex: conn.startPortIndex,
                        endModuleId: conn.endModuleId,
                        endPortIndex: conn.endPortIndex,
                        isRed: conn.isRed || false
                    }));
                    
                    // 构建项目数据
                    const projectData = {
                        version: '1.0', // 添加版本号，用于版本兼容
                        modules: modules,
                        connections: connections,
                        canvasSize: canvasSize,
                        timestamp: new Date().toISOString(),
                        usedCustomModules: Array.from(usedCustomModules)
                    };
                    
                    // 发送POST请求到服务器保存项目
                    const response = await fetch('/api/save_project', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ project_data: projectData })
                    });
                    
                    const result = await response.json();
                    if (result.success) {
                        console.log('项目保存成功:', result.file_path);
                        alert('项目保存成功！');
                    } else {
                        console.error('保存项目失败:', result.error);
                        alert('保存项目失败: ' + result.error);
                    }
                } catch (error) {
                    console.error('保存项目失败:', error);
                    alert('保存项目失败，请检查控制台错误信息。');
                }
            });
            
            // 另存为项目按钮
            document.getElementById('save-as-project-btn').addEventListener('click', async function() {
                try {
                    // 收集所有模块的信息
                    const modules = [];
                    const usedCustomModules = new Set();
                    document.querySelectorAll('.module').forEach(module => {
                        const moduleId = module.dataset.moduleId;
                        const moduleState = moduleStates[moduleId];
                        if (moduleState) {
                            // 读取模块设置
                            const moduleKey = `module_settings_${moduleId}_${moduleState.moduleData.params.name || 'default'}`;
                            const savedSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
                            
                            // 获取输入值
                            let inputValue = '';
                            const inputElement = module.querySelector('.module-input');
                            if (inputElement) {
                                inputValue = inputElement.value;
                            } else {
                                const inputValueElement = module.querySelector('.input-value');
                                if (inputValueElement) {
                                    inputValue = inputValueElement.textContent === '请输入固定值' ? '' : inputValueElement.textContent;
                                }
                            }
                            
                            modules.push({
                                id: moduleId,
                                name: moduleState.moduleData.params.name,
                                kind: moduleState.moduleData.params.kind,
                                left: module.style.left,
                                top: module.style.top,
                                moduleData: moduleState.moduleData,
                                settings: savedSettings,
                                inputValue: inputValue
                            });
                            
                            // 检查是否为自定义模块
                            if (moduleState.moduleData.params.source === 'custom') {
                                usedCustomModules.add(moduleState.moduleData.name);
                            }
                        }
                    });
                    
                    // 收集所有连接的信息
                    const connections = connectionLines.map(conn => ({
                        startModuleId: conn.startModuleId,
                        startPortIndex: conn.startPortIndex,
                        endModuleId: conn.endModuleId,
                        endPortIndex: conn.endPortIndex,
                        isRed: conn.isRed || false
                    }));
                    
                    // 构建项目数据
                    const projectData = {
                        version: '1.0', // 添加版本号，用于版本兼容
                        modules: modules,
                        connections: connections,
                        canvasSize: canvasSize,
                        timestamp: new Date().toISOString(),
                        usedCustomModules: Array.from(usedCustomModules)
                    };
                    
                    // 创建zip文件
                    const zip = new JSZip();
                    
                    // 添加项目文件
                    zip.file('project.json', JSON.stringify(projectData, null, 2));
                    
                    // 添加自定义模块文件夹
                    const customModulesFolder = zip.folder('custom_modules');
                    
                    // 这里需要从服务器获取自定义模块的内容
                    // 由于浏览器环境限制，我们无法直接访问本地文件系统
                    // 所以这里只创建文件夹结构，实际的模块文件需要由服务器处理
                    
                    // 生成zip文件
                    const zipContent = await zip.generateAsync({ type: 'blob' });
                    
                    // 生成文件名
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:T]/g, '-');
                    const defaultFileName = `ai_tool_project_${timestamp}.aiud`;
                    
                    // 尝试使用File System Access API
                    if (window.showSaveFilePicker) {
                        // 使用现代浏览器的File System Access API
                        const options = {
                            suggestedName: defaultFileName,
                            types: [
                                { accept: { 'application/zip': ['.aiud'] } }
                            ]
                        };
                        
                        try {
                            const handle = await window.showSaveFilePicker(options);
                            const writableStream = await handle.createWritable();
                            await writableStream.write(zipContent);
                            await writableStream.close();
                            
                            console.log('项目另存为成功:', projectData);
                            alert('项目另存为成功！');
                        } catch (error) {
                            // 用户取消了保存操作
                            console.log('用户取消了保存操作:', error);
                        }
                    } else {
                        // 浏览器不支持File System Access API，使用传统的下载方法
                        const url = URL.createObjectURL(zipContent);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = defaultFileName;
                        
                        // 触发下载
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        
                        // 释放URL对象
                        URL.revokeObjectURL(url);
                        
                        console.log('项目另存为成功:', projectData);
                        alert('项目另存为成功！');
                    }
                } catch (error) {
                    console.error('另存为项目失败:', error);
                    alert('另存为项目失败，请检查控制台错误信息。');
                }
            });
            
            // 检查模块是否匹配当前代码（严格检查：任何不同都算不兼容）
            function isModuleCompatible(savedModuleData) {
                const moduleName = savedModuleData.name;
                const currentModule = modules[moduleName];
                
                if (!currentModule) {
                    console.log(`模块不兼容: ${moduleName} 不存在`);
                    return false;
                }
                
                const savedParams = savedModuleData.params || {};
                const currentParams = currentModule;
                
                const allKeys = [
                    'input_quantity',
                    'output_quantity',
                    'variable_quantity',
                    'userinput',
                    'setting',
                    'time_late',
                    'name',
                    'excitedbydata',
                    'kind'
                ];
                
                for (const key of allKeys) {
                    const saved = savedParams[key];
                    const current = currentParams[key];
                    if (saved !== undefined && current !== undefined) {
                        if (saved !== current) {
                            console.log(`模块不兼容: ${moduleName} 的${key}不匹配 (保存=${saved}, 当前=${current})`);
                            return false;
                        }
                    }
                }
                
                const savedVariablesName = savedParams.variables_name || '';
                const currentVariablesName = currentParams.variables_name || '';
                if (savedVariablesName !== currentVariablesName) {
                    console.log(`模块不兼容: ${moduleName} 的variables_name不匹配 (保存="${savedVariablesName}", 当前="${currentVariablesName}")`);
                    return false;
                }
                
                const savedOutputName = savedParams.output_name || '';
                const currentOutputName = currentParams.output_name || '';
                if (savedOutputName !== currentOutputName) {
                    console.log(`模块不兼容: ${moduleName} 的output_name不匹配 (保存="${savedOutputName}", 当前="${currentOutputName}")`);
                    return false;
                }
                
                return true;
            }
        
        // 生成模块内容
        function generateModuleContent(moduleData) {
            // 创建输入端口
            let inputPortsHtml = '';
            const inputNames = moduleData.params.variables_name ? moduleData.params.variables_name.split(',') : [];
            for (let i = 0; i < (moduleData.params.input_quantity || 0); i++) {
                const portName = inputNames[i] || `IN_${(i+1).toString().padStart(3, '0')}`;
                inputPortsHtml += `<div style="display: flex; align-items: center; margin: 2px 0; white-space: nowrap;">
                    <div class="port input-port" data-port="input-${i}" style="margin-right: 8px;"></div>
                    <span style="font-size: 10px; flex: 1; overflow: hidden; text-overflow: ellipsis;">${portName}</span>
                </div>`;
            }
            
            // 创建输出端口
            let outputPortsHtml = '';
            const outputNames = moduleData.params.output_name ? moduleData.params.output_name.split(',') : [];
            for (let i = 0; i < (moduleData.params.output_quantity || 0); i++) {
                const portName = outputNames[i] || `OUT_${(i+1).toString().padStart(3, '0')}`;
                outputPortsHtml += `<div style="display: flex; align-items: center; margin: 2px 0; white-space: nowrap;">
                    <span style="font-size: 10px; flex: 1; text-align: right; margin-right: 8px; overflow: hidden; text-overflow: ellipsis;">${portName}</span>
                    <div class="port output-port" data-port="output-${i}"></div>
                </div>`;
            }
            
            // 添加设置按钮
            let settingBtnHtml = '';
            if (moduleData.params.setting === true || moduleData.params.setting === 'T' || moduleData.params.setting === 'true') {
                // 转义JSON字符串中的双引号，确保在HTML属性中正确显示
                const escapedModuleData = JSON.stringify(moduleData).replace(/"/g, '&quot;');
                settingBtnHtml = `<div class="setting-btn" data-module="${escapedModuleData}">Set</div>`;
            }
            
            // 创建显示框
            let showingWindowHtml = '';
            if (moduleData.params.showingwindow_quantity > 0) {
                showingWindowHtml = `<div class="showing-window" style="margin-top: 10px; padding: 0; background-color: #f5f5f5; border: 1px solid #ddd; border-radius: 4px; font-size: 10px; width: 100%; max-width: 100%; box-sizing: border-box; overflow: hidden; position: relative;">
                    <span class="window-content" style="cursor: help; display: block; padding: 5px;">${moduleData.params.name === '缓存模块' ? '缓存内容...' : '显示内容'}</span>
                </div>`;
            }
            
            // 创建输入窗口
            let inputtingWindowHtml = '';
            if (moduleData.params.inputtingwindow_quantity > 0) {
                // 转义moduleData.name中的单引号，确保在HTML属性中正确显示
                const escapedModuleName = moduleData.name.replace(/'/g, "\\'");
                inputtingWindowHtml = `<div class="inputting-window" style="margin-top: 10px; padding: 5px; background-color: #f0f8ff; border: 1px solid #add8e6; border-radius: 4px; font-size: 10px; width: 100%; max-width: 100%; box-sizing: border-box; cursor: pointer;" onclick="openInputSettingModal('${escapedModuleName}', this.closest('.module').dataset.moduleId)">
                    <span style="display: block; margin-bottom: 3px;">输入值:</span>
                    <div style="width: 100%; max-width: 100%; box-sizing: border-box; padding: 3px; border: 1px solid #ddd; border-radius: 2px; font-size: 10px; background-color: white; max-height: 120px; overflow-y: auto; word-wrap: break-word; white-space: pre-wrap;">
                        <span class="input-value">请输入固定值</span>
                    </div>
                </div>`;
            }
            
            return `
                ${settingBtnHtml}
                <div class="module-header">${moduleData.params.name || moduleData.name}</div>
                <div class="module-kind">${moduleData.params.kind || '未知'}</div>
                <div class="ports" style="display: flex; justify-content: space-between; align-items: flex-start;">
                    <div class="input-ports" style="flex: 1; margin-right: 10px;">${inputPortsHtml}</div>
                    <div style="width: 1px; background-color: #ddd; height: 100%; margin: 0 10px;"></div>
                    <div class="output-ports" style="flex: 1; margin-left: 10px;">${outputPortsHtml}</div>
                </div>
                ${showingWindowHtml}
                ${inputtingWindowHtml}
            `;
        }
        
        // 添加模块事件监听器
        function addModuleEventListeners(module) {
            // 添加拖拽功能
            makeDraggable(module);
            
            // 添加端口事件
            module.querySelectorAll('.port').forEach(port => {
                port.addEventListener('mousedown', handlePortMouseDown);
                port.addEventListener('click', handlePortClick);
                port.addEventListener('dblclick', handlePortDoubleClick);
            });
            
            // 添加设置按钮点击事件
            const settingBtn = module.querySelector('.setting-btn');
            if (settingBtn) {
                settingBtn.addEventListener('click', function(e) {
                    e.stopPropagation();
                    const moduleData = JSON.parse(settingBtn.dataset.module);
                    const moduleId = module.dataset.moduleId;
                    openSettingModal(moduleData, moduleId);
                });
            }
            
            // 添加显示框悬停事件
            const showingWindow = module.querySelector('.showing-window');
            if (showingWindow) {
                const contentSpan = showingWindow.querySelector('.window-content');
                const tooltip = showingWindow.querySelector('.tooltip');
                
                // 鼠标进入时显示完整内容
                contentSpan.addEventListener('mouseenter', function(e) {
                    // 根据模块类型获取实际内容
                    const currentModule = this.closest('.module');
                    const moduleId = parseInt(currentModule.dataset.moduleId);
                    const moduleState = moduleStates[moduleId];
                    
                    let fullContent = '';
                    if (moduleState) {
                        if (moduleState.moduleData.params.name === '缓存模块' || moduleState.moduleData.params.name === '显示模块') {
                                const displayContent = moduleState.displayContent !== undefined && moduleState.displayContent !== null ? moduleState.displayContent : '';
                                const prefix = moduleState.moduleData.params.name === '缓存模块' ? '缓存内容: ' : '显示内容: ';
                                fullContent = `${prefix}${displayContent}`;
                            } else {
                            // 对于其他模块，显示完整的默认内容
                            fullContent = contentSpan.textContent;
                        }
                    } else {
                        fullContent = contentSpan.textContent;
                    }
                    
                    // 创建一个新的tooltip元素，确保它能够正确显示
                    let tooltipElement = document.getElementById('custom-tooltip');
                    if (!tooltipElement) {
                        tooltipElement = document.createElement('div');
                        tooltipElement.id = 'custom-tooltip';
                        tooltipElement.style.cssText = `
                            display: none;
                            position: fixed;
                            background-color: #333;
                            color: white;
                            padding: 10px;
                            border-radius: 4px;
                            font-size: 12px;
                            z-index: 9999;
                            max-width: 800px;
                            max-height: 500px;
                            overflow: auto;
                            word-wrap: break-word;
                            pointer-events: none;
                            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
                        `;
                        document.body.appendChild(tooltipElement);
                    }
                    
                    tooltipElement.textContent = fullContent;
                    tooltipElement.style.display = 'block';
                    
                    // 定位tooltip到鼠标位置附近
                    tooltipElement.style.left = `${e.pageX + 10}px`;
                    tooltipElement.style.top = `${e.pageY + 10}px`;
                });
                
                // 鼠标移动时更新tooltip位置
                contentSpan.addEventListener('mousemove', function(e) {
                    const tooltipElement = document.getElementById('custom-tooltip');
                    if (tooltipElement && tooltipElement.style.display === 'block') {
                        tooltipElement.style.left = `${e.pageX + 10}px`;
                        tooltipElement.style.top = `${e.pageY + 10}px`;
                    }
                });
                
                // 鼠标离开时隐藏tooltip
                contentSpan.addEventListener('mouseleave', function() {
                    const tooltipElement = document.getElementById('custom-tooltip');
                    if (tooltipElement) {
                        tooltipElement.style.display = 'none';
                    }
                });
            }
        }
        
        // 创建连接
        function createConnection(startPort, endPort, isRed = false) {
            // 确保是从输出端口到输入端口的连接
            const isOutputPort = startPort.classList.contains('output-port');
            const isInputPort = endPort.classList.contains('input-port');
            
            if (isOutputPort && isInputPort) {
                // 计算端口位置
                const startPos = getPortPosition(startPort);
                const endPos = getPortPosition(endPort);
                
                // 创建连线元素
                const line = createConnectionLine(startPos.x, startPos.y, endPos.x, endPos.y, isRed);
                canvasContent.appendChild(line);
                
                // 保存连线信息
                connectionLines.push({
                    line: line,
                    startPort: startPort,
                    endPort: endPort,
                    isRed: isRed,
                    data: null, // 传输的数据
                    transferred: false, // 数据是否已传输
                    startModuleId: startPort.closest('.module').dataset.moduleId,
                    endModuleId: endPort.closest('.module').dataset.moduleId,
                    startPortIndex: parseInt(startPort.dataset.port.split('-')[1]),
                    endPortIndex: parseInt(endPort.dataset.port.split('-')[1])
                });
            }
        }
        
        // 加载项目按钮
        document.getElementById('load-project-btn').addEventListener('click', function() {
            // 创建文件选择输入
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.aiud,.txt';
            
            // 监听文件选择事件
            input.addEventListener('change', function(e) {
                try {
                    const file = e.target.files[0];
                    if (!file) {
                        return;
                    }
                    
                    // 从文件名中提取项目名
                    const fileName = file.name;
                    const projectName = fileName.split('.').slice(0, -1).join('.');
                    document.getElementById('project-name').textContent = projectName;
                    
                    // 检查文件类型
                    if (file.name.endsWith('.aiud')) {
                        // 处理zip格式的.aiud文件
                        const zip = new JSZip();
                        zip.loadAsync(file).then(function(zip) {
                            // 读取project.json文件
                            return Promise.all([
                                zip.file('project.json').async('string'),
                                // 读取custom_modules文件夹中的文件
                                Promise.resolve(zip.folder('custom_modules'))
                            ]);
                        }).then(function([projectJson, customModulesFolder]) {
                            try {
                                const projectData = JSON.parse(projectJson);
                                
                                // 版本兼容处理
                                const processedProjectData = processProjectData(projectData);
                                
                                // 处理自定义模块
                                if (customModulesFolder) {
                                    // 收集自定义模块文件
                                    const promises = [];
                                    
                        customModulesFolder.forEach(function(relativePath, file) {
                            if (!file.dir) {
                                // 读取模块文件内容
                                const promise = file.async('string').then(function(content) {
                                    try {
                                        // 解析模块参数
                                        const params = parseModuleParamsFromContent(content);
                                        params.source = 'custom';
                                        
                                        // 从文件名中提取模块名
                                        const moduleName = relativePath.split('/').pop().split('.').slice(0, -1).join('.');
                                        
                                        // 添加到模块库
                                        modules[moduleName] = params;
                                        console.log('添加自定义模块:', moduleName, params);
                                    } catch (error) {
                                        console.error('解析自定义模块失败:', relativePath, error);
                                        showNotification(`解析自定义模块失败: ${relativePath}`);
                                    }
                                }).catch(function(error) {
                                    console.error('读取自定义模块失败:', relativePath, error);
                                    showNotification(`读取自定义模块失败: ${relativePath}`);
                                });
                                promises.push(promise);
                            }
                        });
                        
                        // 等待所有模块加载完成后重新渲染模块库
                        return Promise.all(promises).then(function() {
                            console.log('所有自定义模块加载完成，重新渲染模块库');
                            renderModules();
                            return processedProjectData;
                        });
                    } else {
                        return processedProjectData;
                    }
                } catch (error) {
                    console.error('解析项目文件失败:', error);
                    showNotification(`解析项目文件失败: ${error.message}`);
                    throw error;
                }
            }).then(function(projectData) {
                // 清除当前画布上的所有模块和连接
                document.querySelectorAll('.module').forEach(module => module.remove());
                document.querySelectorAll('.connection-line').forEach(line => line.remove());
                connectionLines = [];
                
                // 恢复画布大小
                if (projectData.canvasSize) {
                    canvasSize.width = projectData.canvasSize.width;
                    canvasSize.height = projectData.canvasSize.height;
                    canvasContent.style.width = `${canvasSize.width}px`;
                    canvasContent.style.height = `${canvasSize.height}px`;
                }
                
                // 重新创建模块
                const moduleIdMap = {}; // 用于映射旧ID到新ID
                let incompatibleModules = 0;
                projectData.modules.forEach(moduleInfo => {
                    const moduleName = moduleInfo.moduleData.name;
                    
                    let actualModuleData = moduleInfo.moduleData;
                    let useCurrentModule = false;
                    
                    if (modules[moduleName]) {
                        actualModuleData = {
                            name: moduleName,
                            params: modules[moduleName]
                        };
                        useCurrentModule = true;
                        console.log(`使用当前模块库数据: ${moduleName}`);
                    }
                    
                    const isCompatible = isModuleCompatible(moduleInfo.moduleData);
                    
                    const module = document.createElement('div');
                    module.className = 'module';
                    module.style.left = moduleInfo.left;
                    module.style.top = moduleInfo.top;
                    
                    if (!isCompatible) {
                        module.classList.add('error');
                        incompatibleModules++;
                        console.log(`标记模块为错误: ${moduleName}`);
                    }
                    
                    const newModuleId = generateModuleId();
                    module.dataset.moduleId = newModuleId;
                    moduleIdMap[moduleInfo.id] = newModuleId;
                    
                    const moduleContent = generateModuleContent(actualModuleData);
                    module.innerHTML = moduleContent;
                    
                    canvasContent.appendChild(module);
                    
                    addModuleEventListeners(module);
                    
                    const inputQuantity = actualModuleData.params.input_quantity || 0;
                    const outputQuantity = actualModuleData.params.output_quantity || 0;
                    
                    moduleStates[newModuleId] = {
                        moduleData: actualModuleData,
                        inputValues: new Array(inputQuantity).fill(null),
                        outputValues: new Array(outputQuantity).fill(null),
                        executed: false,
                        executing: false,
                        isCompatible: isCompatible
                    };
                    
                    // 恢复模块设置
                    if (moduleInfo.settings) {
                        const moduleKey = `module_settings_${newModuleId}_${moduleInfo.moduleData.params.name || 'default'}`;
                        sessionStorage.setItem(moduleKey, JSON.stringify(moduleInfo.settings));
                    }
                    
                    // 恢复输入值
                    if (moduleInfo.inputValue !== undefined) {
                        const inputElement = module.querySelector('.module-input');
                        if (inputElement) {
                            inputElement.value = moduleInfo.inputValue;
                        } else {
                            const inputValueElement = module.querySelector('.input-value');
                            if (inputValueElement) {
                                inputValueElement.textContent = moduleInfo.inputValue || '请输入固定值';
                            }
                        }
                    }
                });
                
                // 重新创建连接
                projectData.connections.forEach(connInfo => {
                    const startModuleId = moduleIdMap[connInfo.startModuleId];
                    const endModuleId = moduleIdMap[connInfo.endModuleId];
                    
                    if (startModuleId && endModuleId) {
                        const startModule = document.querySelector(`.module[data-module-id="${startModuleId}"]`);
                        const endModule = document.querySelector(`.module[data-module-id="${endModuleId}"]`);
                        
                        if (startModule && endModule) {
                            const startPort = startModule.querySelectorAll('.output-port')[connInfo.startPortIndex];
                            const endPort = endModule.querySelectorAll('.input-port')[connInfo.endPortIndex];
                            
                            if (startPort && endPort) {
                                // 创建连接
                                createConnection(startPort, endPort, connInfo.isRed);
                            }
                        }
                    }
                });
                
                // 重新初始化画布，确保缩放和偏移量正确
                initZoomControls();
                
                console.log('项目加载成功:', projectData);
                if (incompatibleModules > 0) {
                    showNotification(`项目加载成功！发现 ${incompatibleModules} 个不兼容的模块（已标记为红色）`);
                } else {
                    showNotification('项目加载成功！');
                }
            }).catch(function(error) {
                console.error('加载zip文件失败:', error);
                alert('加载文件失败，请确保文件格式正确。');
            });
        } else {
            // 处理.txt格式的文件
            const reader = new FileReader();
            
            // 监听读取完成事件
            reader.addEventListener('load', function(e) {
                try {
                    const text = e.target.result;
                    const projectData = JSON.parse(text);
                    
                    // 版本兼容处理
                    const processedProjectData = processProjectData(projectData);
                    
                    // 清除当前画布上的所有模块和连接
                    document.querySelectorAll('.module').forEach(module => module.remove());
                    document.querySelectorAll('.connection-line').forEach(line => line.remove());
                    connectionLines = [];
                    
                    // 恢复画布大小
                    if (processedProjectData.canvasSize) {
                        canvasSize.width = processedProjectData.canvasSize.width;
                        canvasSize.height = processedProjectData.canvasSize.height;
                        canvasContent.style.width = `${canvasSize.width}px`;
                        canvasContent.style.height = `${canvasSize.height}px`;
                    }
                    
                    // 重新创建模块
                    const moduleIdMap = {}; // 用于映射旧ID到新ID
                    let incompatibleModules = 0;
                    processedProjectData.modules.forEach(moduleInfo => {
                        try {
                            const moduleName = moduleInfo.moduleData.name;
                            
                            let actualModuleData = moduleInfo.moduleData;
                            let useCurrentModule = false;
                            
                            if (modules[moduleName]) {
                                actualModuleData = {
                                    name: moduleName,
                                    params: modules[moduleName]
                                };
                                useCurrentModule = true;
                                console.log(`使用当前模块库数据: ${moduleName}`);
                            }
                            
                            const isCompatible = isModuleCompatible(moduleInfo.moduleData);
                            
                            const module = document.createElement('div');
                            module.className = 'module';
                            module.style.left = moduleInfo.left || '0px';
                            module.style.top = moduleInfo.top || '0px';
                            
                            if (!isCompatible) {
                                module.classList.add('error');
                                incompatibleModules++;
                                console.log(`标记模块为错误: ${moduleName}`);
                            }
                            
                            const newModuleId = generateModuleId();
                            module.dataset.moduleId = newModuleId;
                            moduleIdMap[moduleInfo.id] = newModuleId;
                            
                            const moduleContent = generateModuleContent(actualModuleData);
                            module.innerHTML = moduleContent;
                            
                            canvasContent.appendChild(module);
                            
                            addModuleEventListeners(module);
                            
                            const inputQuantity = actualModuleData.params.input_quantity || 0;
                            const outputQuantity = actualModuleData.params.output_quantity || 0;
                            
                            moduleStates[newModuleId] = {
                                moduleData: actualModuleData,
                                inputValues: new Array(inputQuantity).fill(null),
                                outputValues: new Array(outputQuantity).fill(null),
                                displayContent: '',
                                executed: false,
                                executing: false,
                                isCompatible: isCompatible
                            };
                            
                            // 恢复模块设置
                            if (moduleInfo.settings) {
                                const moduleKey = `module_settings_${newModuleId}_${moduleInfo.moduleData.params.name || 'default'}`;
                                sessionStorage.setItem(moduleKey, JSON.stringify(moduleInfo.settings));
                            }
                            
                            // 恢复输入值
                            if (moduleInfo.inputValue !== undefined) {
                                const inputElement = module.querySelector('.module-input');
                                if (inputElement) {
                                    inputElement.value = moduleInfo.inputValue;
                                } else {
                                    const inputValueElement = module.querySelector('.input-value');
                                    if (inputValueElement) {
                                        inputValueElement.textContent = moduleInfo.inputValue || '请输入固定值';
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('创建模块失败:', moduleInfo, error);
                            showNotification(`创建模块失败: ${moduleInfo.name || '未知模块'}`);
                        }
                    });
                    
                    // 重新创建连接
                    processedProjectData.connections.forEach(connInfo => {
                        try {
                            const startModuleId = moduleIdMap[connInfo.startModuleId];
                            const endModuleId = moduleIdMap[connInfo.endModuleId];
                            
                            if (startModuleId && endModuleId) {
                                const startModule = document.querySelector(`.module[data-module-id="${startModuleId}"]`);
                                const endModule = document.querySelector(`.module[data-module-id="${endModuleId}"]`);
                                
                                if (startModule && endModule) {
                                    const startPort = startModule.querySelectorAll('.output-port')[connInfo.startPortIndex];
                                    const endPort = endModule.querySelectorAll('.input-port')[connInfo.endPortIndex];
                                    
                                    if (startPort && endPort) {
                                        // 创建连接
                                        createConnection(startPort, endPort, connInfo.isRed);
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('创建连接失败:', connInfo, error);
                        }
                    });
                    
                    // 重新初始化画布，确保缩放和偏移量正确
                    initZoomControls();
                    
                    console.log('项目加载成功:', processedProjectData);
                    if (incompatibleModules > 0) {
                        showNotification(`项目加载成功！发现 ${incompatibleModules} 个不兼容的模块（已标记为红色）`);
                    } else {
                        showNotification('项目加载成功！');
                    }
                } catch (error) {
                    console.error('解析文件失败:', error);
                    showNotification(`解析文件失败: ${error.message}`);
                }
            });
            
            // 监听读取错误事件
            reader.addEventListener('error', function() {
                console.error('读取文件失败');
                alert('读取文件失败，请重试。');
            });
            
            // 开始读取文件
            reader.readAsText(file);
        }
    } catch (error) {
        console.error('加载项目失败:', error);
        alert('加载项目失败，请检查控制台错误信息。');
    }
});

// 触发文件选择对话框
input.click();
});
        
        // 初始化折叠按钮
        function initCollapseButtons() {
            // 左侧模块库折叠按钮
            const moduleLibraryCollapse = document.getElementById('module-library-collapse');
            const moduleLibrary = document.querySelector('.module-library');
            
            moduleLibraryCollapse.addEventListener('click', function() {
                moduleLibrary.classList.toggle('collapsed');
                if (moduleLibrary.classList.contains('collapsed')) {
                    moduleLibraryCollapse.textContent = '→';
                } else {
                    moduleLibraryCollapse.textContent = '←';
                }
            });
            
            // 右侧对话面板折叠按钮
            const chatPanelCollapse = document.getElementById('chat-panel-collapse');
            const chatPanel = document.querySelector('.chat-panel');
            
            chatPanelCollapse.addEventListener('click', function() {
                chatPanel.classList.toggle('collapsed');
                if (chatPanel.classList.contains('collapsed')) {
                    chatPanelCollapse.textContent = '←';
                } else {
                    chatPanelCollapse.textContent = '→';
                }
            });
        }
        
        // 调整画布大小
        function resizeCanvas() {
            // 获取当前画布大小
            const currentWidth = canvasSize.width;
            const currentHeight = canvasSize.height;
            
            // 创建一个HTML弹窗来同时设置高度和宽度
            const modal = document.createElement('div');
            modal.className = 'setting-modal';
            modal.innerHTML = `
                <div class="setting-modal-content">
                    <h3>调整画布大小</h3>
                    <form class="setting-form">
                        <div class="setting-form-group">
                            <label for="canvas-width">画布宽度</label>
                            <input type="number" id="canvas-width" name="canvas-width" value="${currentWidth}" min="100" step="100">
                        </div>
                        <div class="setting-form-group">
                            <label for="canvas-height">画布高度</label>
                            <input type="number" id="canvas-height" name="canvas-height" value="${currentHeight}" min="100" step="100">
                        </div>
                    </form>
                    <div class="setting-modal-buttons">
                        <button class="cancel-btn">取消</button>
                        <button class="save-btn">保存</button>
                    </div>
                </div>
            `;
            
            // 添加到文档
            document.body.appendChild(modal);
            
            // 取消按钮事件
            modal.querySelector('.cancel-btn').addEventListener('click', function() {
                document.body.removeChild(modal);
            });
            
            // 保存按钮事件
            modal.querySelector('.save-btn').addEventListener('click', function() {
                const widthInput = modal.querySelector('#canvas-width').value;
                const heightInput = modal.querySelector('#canvas-height').value;
                
                // 验证输入
                const newWidth = parseInt(widthInput);
                const newHeight = parseInt(heightInput);
                
                if (!isNaN(newWidth) && !isNaN(newHeight) && newWidth > 0 && newHeight > 0) {
                    // 更新画布大小
                    canvasSize.width = newWidth;
                    canvasSize.height = newHeight;
                    
                    // 更新画布内容的大小
                    canvasContent.style.width = `${newWidth}px`;
                    canvasContent.style.height = `${newHeight}px`;
                    
                    // 重新初始化画布，确保缩放和偏移量正确
                    initZoomControls();
                    
                    console.log(`画布大小已调整为: ${newWidth}px × ${newHeight}px`);
                    document.body.removeChild(modal);
                } else {
                    alert('请输入有效的画布大小！');
                }
            });
            
            // 点击模态框背景关闭
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }
        
        // 初始化缩放控制和画布拖动
        function initZoomControls() {
            // 计算最小缩放倍率，使画布高度正好充满浏览器高度
            const calculateMinZoom = () => {
                const canvasHeight = canvasSize.height;
                const containerHeight = window.innerHeight - 60;
                const minZoom = Math.max(15, Math.round((containerHeight / canvasHeight) * 100));
                return minZoom;
            };
            
            const minZoom = Math.max(20, calculateMinZoom());
            const maxZoom = 500;
            const zoomLevelDisplay = document.querySelector('.zoom-level');
            
            // 更新背景网格大小
            const updateGridSize = (scale) => {
                const smallGridSize = 20 * scale;
                const largeGridSize = 60 * scale;
                canvasContent.style.backgroundSize = `${smallGridSize}px ${smallGridSize}px, ${smallGridSize}px ${smallGridSize}px, ${largeGridSize}px ${largeGridSize}px, ${largeGridSize}px ${largeGridSize}px`;
            };
            
            // 初始化画布位置和缩放倍率
            const initializeCanvas = () => {
                zoomLevel = minZoom;
                currentZoomLevel = zoomLevel;
                globalZoomScale = zoomLevel / 100;
                const scale = zoomLevel / 100;
                
                const canvasWidth = canvasSize.width;
                const canvasHeight = canvasSize.height;
                const containerWidth = canvas.clientWidth;
                const containerHeight = canvas.clientHeight;
                
                globalCanvasOffsetX = (containerWidth / 2 / scale) - (canvasWidth / 2);
                globalCanvasOffsetY = (containerHeight / 2 / scale) - (canvasHeight / 2);
                
                canvasContent.style.transform = `translate(${globalCanvasOffsetX}px, ${globalCanvasOffsetY}px) scale(${scale})`;
                zoomLevelDisplay.textContent = zoomLevel + '%';
                updateGridSize(scale);
            };
            
            // 画布拖动功能
            canvas.addEventListener('mousedown', function(e) {
                if (e.target === canvas || e.target === canvasContent) {
                    isDraggingCanvas = true;
                    const rect = canvas.getBoundingClientRect();
                    canvasStartX = e.clientX - rect.left;
                    canvasStartY = e.clientY - rect.top;
                    canvasStartOffsetX = globalCanvasOffsetX;
                    canvasStartOffsetY = globalCanvasOffsetY;
                    canvas.style.cursor = 'grabbing';
                }
            });
            
            // 处理画布拖动
            document.addEventListener('mousemove', function(e) {
                if (isDraggingCanvas) {
                    const scale = zoomLevel / 100;
                    const rect = canvas.getBoundingClientRect();
                    const currentMouseX = e.clientX - rect.left;
                    const currentMouseY = e.clientY - rect.top;
                    const deltaX = currentMouseX - canvasStartX;
                    const deltaY = currentMouseY - canvasStartY;
                    
                    const newOffsetX = canvasStartOffsetX + deltaX / scale;
                    const newOffsetY = canvasStartOffsetY + deltaY / scale;
                    
                    globalCanvasOffsetX = newOffsetX;
                    globalCanvasOffsetY = newOffsetY;
                    
                    canvasContent.style.transform = `translate(${globalCanvasOffsetX}px, ${globalCanvasOffsetY}px) scale(${scale})`;
                    
                    updateGridSize(scale);
                    
                    if (typeof syncAllRunStatusMarkers === 'function') {
                        syncAllRunStatusMarkers();
                    }
                }
            });
            
            // 结束画布拖动
            document.addEventListener('mouseup', function() {
                if (isDraggingCanvas) {
                    isDraggingCanvas = false;
                    canvas.style.cursor = 'grab';
                }
            });
            
            document.addEventListener('mouseleave', function() {
                if (isDraggingCanvas) {
                    isDraggingCanvas = false;
                    canvas.style.cursor = 'grab';
                }
            });
            
            window.addEventListener('resize', function() {
                // 窗口大小变化时，保持当前画布位置不变
            });
            
            document.getElementById('zoom-in').addEventListener('click', function() {
                const oldScale = zoomLevel / 100;
                let newZoomLevel;
                
                if (zoomLevel % 10 !== 0) {
                    newZoomLevel = Math.ceil(zoomLevel / 10) * 10;
                } else {
                    newZoomLevel = zoomLevel + 10;
                }
                
                newZoomLevel = Math.min(newZoomLevel, maxZoom);
                
                if (newZoomLevel > zoomLevel) {
                    zoomLevel = newZoomLevel;
                    const newScale = zoomLevel / 100;
                    updateZoom(lastMouseX, lastMouseY, oldScale, newScale);
                }
            });
            
            document.getElementById('zoom-out').addEventListener('click', function() {
                const oldScale = zoomLevel / 100;
                let newZoomLevel = zoomLevel - 10;
                
                if (newZoomLevel > minZoom && newZoomLevel - minZoom < 10) {
                    newZoomLevel = minZoom;
                } else {
                    newZoomLevel = Math.max(newZoomLevel, minZoom);
                }
                
                if (newZoomLevel < zoomLevel) {
                    zoomLevel = newZoomLevel;
                    const newScale = zoomLevel / 100;
                    updateZoom(lastMouseX, lastMouseY, oldScale, newScale);
                }
            });
            
            const resizeCanvasBtn = document.getElementById('resize-canvas-btn');
            const newResizeCanvasBtn = resizeCanvasBtn.cloneNode(true);
            resizeCanvasBtn.parentNode.replaceChild(newResizeCanvasBtn, resizeCanvasBtn);
            newResizeCanvasBtn.addEventListener('click', function() {
                resizeCanvas();
            });
            
            canvas.addEventListener('wheel', function(e) {
                e.preventDefault();
                
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                
                let newZoomLevel;
                
                if (e.deltaY < 0) {
                    if (zoomLevel % 10 !== 0) {
                        newZoomLevel = Math.ceil(zoomLevel / 10) * 10;
                    } else {
                        newZoomLevel = zoomLevel + 10;
                    }
                    newZoomLevel = Math.min(newZoomLevel, maxZoom);
                } else {
                    if (zoomLevel % 10 !== 0) {
                        newZoomLevel = Math.floor(zoomLevel / 10) * 10;
                    } else {
                        newZoomLevel = zoomLevel - 10;
                    }
                    
                    if (newZoomLevel > minZoom && newZoomLevel - minZoom < 10) {
                        newZoomLevel = minZoom;
                    } else {
                        newZoomLevel = Math.max(newZoomLevel, minZoom);
                    }
                }
                
                if (newZoomLevel !== zoomLevel) {
                    const oldScale = zoomLevel / 100;
                    zoomLevel = newZoomLevel;
                    const newScale = zoomLevel / 100;
                    updateZoom(mouseX, mouseY, oldScale, newScale);
                }
            });
            
            function updateZoom(mouseX, mouseY, oldScale, newScale) {
                zoomLevelDisplay.textContent = zoomLevel + '%';
                currentZoomLevel = zoomLevel;
                globalZoomScale = newScale;
                
                const contentX = (mouseX - globalCanvasOffsetX) / oldScale;
                const contentY = (mouseY - globalCanvasOffsetY) / oldScale;
                
                const newOffsetX = mouseX - contentX * newScale;
                const newOffsetY = mouseY - contentY * newScale;
                
                globalCanvasOffsetX = newOffsetX;
                globalCanvasOffsetY = newOffsetY;
                
                canvasContent.style.transform = `translate(${globalCanvasOffsetX}px, ${globalCanvasOffsetY}px) scale(${newScale})`;
                canvasContent.style.minWidth = '1px';
                canvasContent.style.minHeight = '1px';
                updateGridSize(newScale);
            }
            
            window.getCurrentZoomLevel = function() {
                return currentZoomLevel;
            };
            
            initializeCanvas();
        }
        
        // 初始化模块拖拽删除功能
        function initModuleDragDelete() {
            const moduleLibrary = document.querySelector('.module-library');
            
            // 为模块库添加拖放事件
            moduleLibrary.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.stopPropagation();
                moduleLibrary.style.backgroundColor = '#e3f2fd';
            }, true);
            
            moduleLibrary.addEventListener('dragleave', function(e) {
                e.preventDefault();
                e.stopPropagation();
                moduleLibrary.style.backgroundColor = '#f5f5f5';
            }, true);
            
            moduleLibrary.addEventListener('drop', function(e) {
                e.preventDefault();
                e.stopPropagation();
                moduleLibrary.style.backgroundColor = '#f5f5f5';
                
                console.log('模块库drop事件触发');
                
                // 获取被拖拽的模块
                const draggedModuleElement = document.querySelector('.module.dragging');
                console.log('找到被拖拽的模块:', draggedModuleElement);
                
                if (draggedModuleElement) {
                    console.log('准备删除模块:', draggedModuleElement);
                    // 删除与该模块相关的所有连线
                    connectionLines = connectionLines.filter(connection => {
                        const isRelated = connection.startPort.closest('.module') === draggedModuleElement || 
                                        connection.endPort.closest('.module') === draggedModuleElement;
                        if (isRelated) {
                            connection.line.remove();
                        }
                        return !isRelated;
                    });
                    
                    // 删除模块
                    draggedModuleElement.remove();
                    console.log('模块删除成功');
                }
            }, true);
            
            // 为所有模块库子元素添加阻止默认行为的监听器
            const moduleLibraryChildren = moduleLibrary.querySelectorAll('*');
            moduleLibraryChildren.forEach(child => {
                child.addEventListener('dragover', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                }, true);
                child.addEventListener('drop', function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                }, true);
            });
        }
        
        // 打开设置窗口
        function openInputSettingModal(moduleName, moduleId) {
            // 创建设置窗口
            const modal = document.createElement('div');
            modal.className = 'setting-modal';
            
            // 获取当前输入值
            const moduleElement = document.querySelector(`.module[data-module-id="${moduleId}"]`);
            const inputValueElement = moduleElement ? moduleElement.querySelector('.input-value') : null;
            let currentValue = inputValueElement ? inputValueElement.textContent : '请输入固定值';
            if (currentValue === '请输入固定值') {
                currentValue = '';
            }
            
            // 生成设置表单
            const formHtml = `
                <div class="setting-form-group">
                    <label for="input-value">输入值</label>
                    <textarea id="input-value" name="input-value" placeholder="请输入固定值" style="width: 100%; height: 200px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; resize: none; overflow: auto;">${currentValue}</textarea>
                </div>
            `;
            
            // 设置窗口内容
            modal.innerHTML = `
                <div class="setting-modal-content" style="width: 600px; max-width: 80%;">
                    <h3>输入值设置</h3>
                    <form class="setting-form">
                        ${formHtml}
                    </form>
                    <div class="setting-modal-buttons">
                        <button class="cancel-btn">取消</button>
                        <button class="save-btn">保存</button>
                    </div>
                </div>
            `;
            
            // 添加到文档
            document.body.appendChild(modal);
            
            // 保存按钮点击事件
            const saveBtn = modal.querySelector('.save-btn');
            saveBtn.addEventListener('click', function(e) {
                e.preventDefault();
                
                // 获取输入值
                const inputValue = modal.querySelector('#input-value').value;
                
                // 更新模块显示
                if (inputValueElement) {
                    inputValueElement.textContent = inputValue || '请输入固定值';
                }
                
                // 保存到模块状态
                const moduleState = moduleStates[moduleId];
                if (moduleState) {
                    // 这里可以根据需要保存输入值到模块状态
                }
                
                // 关闭窗口
                modal.remove();
            });
            
            // 取消按钮点击事件
            const cancelBtn = modal.querySelector('.cancel-btn');
            cancelBtn.addEventListener('click', function(e) {
                e.preventDefault();
                modal.remove();
            });
        }
        
        function openSettingModal(moduleData, moduleId) {
            // 创建设置窗口
            const modal = document.createElement('div');
            modal.className = 'setting-modal';
            
            // 获取变量名
            const variableNames = moduleData.params.variables_name ? moduleData.params.variables_name.split(',') : [];
            const variableQuantity = moduleData.params.variable_quantity || 0;
            
            // 生成设置表单
            let formHtml = '';
            
            // 检查是否为加载图像模块
            if (moduleData.params.name === '加载图像模块') {
                // 加载图像模块特殊设置
                formHtml += `
                    <div class="setting-form-group">
                        <label>加载图像</label>
                        <input type="file" id="image-input" accept="image/*" style="width: 100%; padding: 8px;">
                    </div>
                    <div class="setting-form-group">
                        <label>图像预览（点击图像可绘制遮罩）</label>
                        <div id="image-preview-container" style="width: 100%; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; cursor: pointer; min-height: 200px; display: flex; align-items: center; justify-content: center; background-color: #fafafa;">
                            <span style="color: #999;">请先加载图像</span>
                            <img id="image-preview" style="max-width: 100%; max-height: 400px; display: none;">
                        </div>
                    </div>
                    <div class="setting-form-group">
                        <label>遮罩预览</label>
                        <div id="mask-preview-container" style="width: 100%; border: 1px solid #ddd; border-radius: 4px; overflow: hidden; min-height: 200px; display: flex; align-items: center; justify-content: center; background-color: #fafafa;">
                            <span style="color: #999;">暂无遮罩</span>
                            <canvas id="mask-preview" style="max-width: 100%; max-height: 400px; display: none;"></canvas>
                        </div>
                    </div>
                `;
            }
            
            // 检查是否为调用模块
            if (moduleData.params.kind === '调用模块') {
                // 调用模块特殊设置
                formHtml += `
                    <h4>模型选择</h4>
                    <div class="setting-form-group">
                        <label for="model_source">模型调用方式</label>
                        <select id="model_source" name="model_source" onchange="toggleModelSettings(this.value)">
                            <option value="api">API</option>
                            <option value="lmstudio" selected>本地 LM Studio</option>
                        </select>
                    </div>
                    
                    <!-- API设置 -->
                    <div id="api_settings" class="model-settings" style="display: none;">
                        <div class="setting-form-group">
                            <label for="service_provider">服务商</label>
                            <select id="service_provider" name="service_provider">
                                <option value="火山引擎">火山引擎</option>
                                <option value="阿里云">阿里云</option>
                                <option value="腾讯云">腾讯云</option>
                                <option value="DeepSeek">DeepSeek</option>
                                <option value="OpenAI">OpenAI</option>
                            </select>
                        </div>
                        <div class="setting-form-group">
                            <label for="model">模型ID</label>
                            <input type="text" id="model" name="model" placeholder="请输入模型ID">
                        </div>
                        <div class="setting-form-group">
                            <label for="api_key">API密钥</label>
                            <input type="password" id="api_key" name="api_key" placeholder="请输入API密钥">
                        </div>
                    </div>
                    
                    <!-- LM Studio设置 -->
                    <div id="lmstudio_settings" class="model-settings">
                        <div class="setting-form-group">
                            <label for="lmstudio_host">主机地址</label>
                            <input type="text" id="lmstudio_host" name="lmstudio_host" value="http://localhost:1234" placeholder="请输入主机地址">
                        </div>
                        <div class="setting-form-group">
                            <label for="lmstudio_model">模型选择</label>
                            <select id="lmstudio_model" name="lmstudio_model">
                                <option value="">加载中...</option>
                            </select>
                            <button type="button" id="refresh_models" onclick="refreshLMStudioModels()">刷新模型列表</button>
                            <div id="model_status" style="font-size: 12px; color: gray; margin-top: 5px;">状态: 就绪</div>
                        </div>
                        
                        <!-- 生成参数设置 -->
                        <h4>生成参数设置</h4>
                        <div class="setting-form-group">
                            <label for="temperature">温度 (temperature)</label>
                            <input type="number" id="temperature" name="temperature" value="0.7" min="0" max="2" step="0.1" placeholder="0.7">
                        </div>
                        <div class="setting-form-group">
                            <label for="top_p">核采样 (top_p)</label>
                            <input type="number" id="top_p" name="top_p" value="0.9" min="0" max="1" step="0.05" placeholder="0.9">
                        </div>
                        <div class="setting-form-group">
                            <label for="top_k">Top-K</label>
                            <input type="number" id="top_k" name="top_k" value="40" min="0" step="1" placeholder="40">
                        </div>
                        <div class="setting-form-group">
                            <label for="repetition_penalty">重复惩罚 (repetition_penalty)</label>
                            <input type="number" id="repetition_penalty" name="repetition_penalty" value="1.0" min="0.5" max="2" step="0.1" placeholder="1.0">
                        </div>
                        <div class="setting-form-group">
                            <label for="presence_penalty">存在惩罚 (presence_penalty)</label>
                            <input type="number" id="presence_penalty" name="presence_penalty" value="0.0" min="-2" max="2" step="0.1" placeholder="0.0">
                        </div>
                        <div class="setting-form-group">
                            <label for="frequency_penalty">频率惩罚 (frequency_penalty)</label>
                            <input type="number" id="frequency_penalty" name="frequency_penalty" value="0.0" min="-2" max="2" step="0.1" placeholder="0.0">
                        </div>
                        <div class="setting-form-group">
                            <label for="max_tokens">最大生成长度 (max_tokens)</label>
                            <input type="number" id="max_tokens" name="max_tokens" value="1000" min="1" step="100" placeholder="1000">
                        </div>
                        <div class="setting-form-group">
                            <label for="stop_words">停止词 (stop_words)</label>
                            <input type="text" id="stop_words" name="stop_words" placeholder="用逗号分隔，如: 你好,再见">
                        </div>
                        <div class="setting-form-group">
                            <label for="seed">随机种子 (seed)</label>
                            <input type="number" id="seed" name="seed" value="0" min="0" step="1" placeholder="0 (随机)">
                        </div>
                    </div>
                    
                    <h4>默认值设置</h4>
                `;
            }
            
            // 生成通用变量设置
                for (let i = 0; i < variableQuantity; i++) {
                    const variableName = variableNames[i] || `变量${i+1}`;
                    // 在LM Studio模式下，隐藏下方的"模型选择"输入框
                    const isModelSelection = variableName === '模型选择';
                    const hiddenClass = isModelSelection ? ' lmstudio-hidden' : '';
                    
                    // 为"是否保存"添加开关控件
                    if (moduleData.params.name === '图片保存/显示模块' && variableName === '是否保存') {
                        formHtml += `
                        <div class="setting-form-group${hiddenClass}">
                            <label for="var-${i}">${variableName}</label>
                            <div style="display: flex; align-items: center; gap: 10px; margin-top: 5px;">
                                <input type="checkbox" id="var-${i}" name="${variableName}" checked style="width: 20px; height: 20px; cursor: pointer;">
                                <span style="font-size: 14px;">是（保存图片）</span>
                            </div>
                        </div>
                    `;
                    }
                    // 为Checkpoint加载器、VAE解码器加载模块、CLIP文本编码器加载模块添加特殊处理
                    else if (moduleData.params.name === 'Checkpoint加载器' || 
                        moduleData.params.name === 'VAE解码器加载模块' || 
                        moduleData.params.name === 'CLIP文本编码器加载模块') {
                        if (variableName === '模型文件夹路径') {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <input type="text" id="var-${i}" name="${variableName}" placeholder="请输入模型文件夹路径">
                            </div>
                        `;
                        } else if (variableName === '模型文件选择') {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <select id="var-${i}" name="${variableName}" style="width: 100%; padding: 8px;">
                                    <option value="">请选择模型</option>
                                </select>
                                <button type="button" onclick="refreshModelList('var-${i}', 'var-0')" style="margin-top: 5px; padding: 5px 10px; cursor: pointer;">刷新</button>
                            </div>
                        `;
                        } else {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <input type="text" id="var-${i}" name="${variableName}" placeholder="请输入默认值">
                            </div>
                        `;
                        }
                    } else if (moduleData.params.name === '空Latent张量生成模块') {
                        if (variableName === '种子') {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <input type="number" id="var-${i}" name="${variableName}" placeholder="请输入种子值(-1表示随机)" value="-1">
                            </div>
                        `;
                        } else {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <input type="number" id="var-${i}" name="${variableName}" placeholder="请输入默认值" value="${variableName === '宽度' ? '512' : variableName === '高度' ? '512' : variableName === '批量大小' ? '1' : ''}">
                            </div>
                        `;
                        }
                    } else if (moduleData.params.name === 'K采样器模块') {
                        // 为K采样器模块添加特殊处理
                        if (variableName === '生成后控制') {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <select id="var-${i}" name="${variableName}" style="width: 100%; padding: 8px;">
                                    <option value="fixed">fixed（固定）</option>
                                    <option value="increment">increment（递增）</option>
                                    <option value="decrement">decrement（递减）</option>
                                    <option value="randomize" selected>randomize（随机）</option>
                                </select>
                            </div>
                        `;
                        } else if (variableName === '采样器名称') {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <select id="var-${i}" name="${variableName}" style="width: 100%; padding: 8px;">
                                    <option value="dpmpp_2m">dpmpp_2m</option>
                                    <option value="dpmpp_2m_sde">dpmpp_2m_sde</option>
                                    <option value="euler" selected>euler</option>
                                    <option value="euler_ancestral">euler_ancestral</option>
                                </select>
                            </div>
                        `;
                        } else if (variableName === '调度器') {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <select id="var-${i}" name="${variableName}" style="width: 100%; padding: 8px;">
                                    <option value="karras">karras</option>
                                    <option value="simple">simple</option>
                                </select>
                            </div>
                        `;
                        } else if (variableName === '种子') {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <input type="number" id="var-${i}" name="${variableName}" placeholder="请输入种子值" value="0">
                            </div>
                        `;
                        } else if (variableName === '步数') {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <input type="number" id="var-${i}" name="${variableName}" placeholder="请输入步数" value="20" min="1" max="100">
                            </div>
                        `;
                        } else if (variableName === 'cfg') {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <input type="number" id="var-${i}" name="${variableName}" placeholder="请输入CFG值" value="8.0" min="0" max="20" step="0.5">
                            </div>
                        `;
                        } else if (variableName === '降噪') {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <input type="number" id="var-${i}" name="${variableName}" placeholder="请输入降噪值" value="1.0" min="0" max="1" step="0.05">
                            </div>
                        `;
                        } else if (variableName === '模型' || variableName === '正面条件' || variableName === '负面条件' || variableName === 'Latent图像') {
                            // 这些是输入端口的变量，不显示在设置界面
                        } else {
                            formHtml += `
                            <div class="setting-form-group${hiddenClass}">
                                <label for="var-${i}">${variableName}</label>
                                <input type="text" id="var-${i}" name="${variableName}" placeholder="请输入默认值">
                            </div>
                        `;
                        }
                    } else {
                        formHtml += `
                        <div class="setting-form-group${hiddenClass}">
                            <label for="var-${i}">${variableName}</label>
                            <input type="text" id="var-${i}" name="${variableName}" placeholder="请输入默认值">
                        </div>
                    `;
                    }
                }
            
            // 设置窗口内容
            modal.innerHTML = `
                <div class="setting-modal-content">
                    <h3>${moduleData.params.name || '模块'} 设置</h3>
                    <form class="setting-form">
                        ${formHtml}
                    </form>
                    <div class="setting-modal-buttons">
                        <button class="cancel-btn">取消</button>
                        <button class="save-btn">保存</button>
                    </div>
                </div>
            `;
            
            // 从会话存储中读取之前保存的设置
            const moduleKey = `module_settings_${moduleId}_${moduleData.params.name || 'default'}`;
            const savedSettings = JSON.parse(sessionStorage.getItem(moduleKey) || '{}');
            
            // 加载图像模块的变量，放在外层作用域，让保存按钮事件可以访问
            let imageData = null;
            let maskData = null;
            
            // 添加到文档
            document.body.appendChild(modal);
            
            // 处理加载图像模块
            if (moduleData.params.name === '加载图像模块') {
                // 从 moduleState 中加载之前保存的图像和遮罩
                if (moduleId) {
                    const moduleState = moduleStates[moduleId];
                    if (moduleState) {
                        imageData = moduleState.imageData || null;
                        maskData = moduleState.maskData || null;
                        console.log('从 moduleState 加载加载图像模块数据:', { hasImage: !!imageData, hasMask: !!maskData });
                    }
                }
                let maskCanvas = null;
                let maskCtx = null;
                let isDrawing = false;
                let lastX = 0;
                let lastY = 0;
                let brushSize = 20;
                
                const imageInput = modal.querySelector('#image-input');
                const imagePreview = modal.querySelector('#image-preview');
                const imagePreviewContainer = modal.querySelector('#image-preview-container');
                const maskPreview = modal.querySelector('#mask-preview');
                const maskPreviewContainer = modal.querySelector('#mask-preview-container');
                
                // 加载之前保存的图像
                if (imageData) {
                    imagePreview.src = imageData;
                    imagePreview.style.display = 'block';
                    imagePreviewContainer.querySelector('span').style.display = 'none';
                    
                    if (maskData) {
                        const img = new Image();
                        img.onload = function() {
                            maskPreview.width = img.width;
                            maskPreview.height = img.height;
                            maskCtx = maskPreview.getContext('2d');
                            maskCtx.drawImage(img, 0, 0);
                            maskPreview.style.display = 'block';
                            maskPreviewContainer.querySelector('span').style.display = 'none';
                        };
                        img.src = maskData;
                    }
                }
                
                // 图像加载事件
                imageInput.addEventListener('change', function(e) {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = function(event) {
                            imageData = event.target.result;
                            imagePreview.src = imageData;
                            imagePreview.style.display = 'block';
                            imagePreviewContainer.querySelector('span').style.display = 'none';
                            
                            // 初始化遮罩画布
                            const img = new Image();
                            img.onload = function() {
                                maskPreview.width = img.width;
                                maskPreview.height = img.height;
                                maskCtx = maskPreview.getContext('2d');
                                maskCtx.fillStyle = '#ffffff';
                                maskCtx.fillRect(0, 0, maskPreview.width, maskPreview.height);
                                maskPreview.style.display = 'block';
                                maskPreviewContainer.querySelector('span').style.display = 'none';
                                maskData = maskPreview.toDataURL();
                            };
                            img.src = imageData;
                        };
                        reader.readAsDataURL(file);
                    }
                });
                
                // 点击图像打开遮罩绘制窗口
                imagePreviewContainer.addEventListener('click', function() {
                    if (!imageData) return;
                    
                    // 创建遮罩绘制窗口
                    const maskModal = document.createElement('div');
                    maskModal.className = 'setting-modal';
                    maskModal.innerHTML = `
                        <div class="setting-modal-content" style="width: 90%; max-width: 1200px; max-height: 90vh; overflow: auto;">
                            <h3>遮罩绘制（黑色=重绘，白色=保留）</h3>
                            <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                                <label>画笔大小: <input type="range" id="brush-size" min="1" max="100" value="${brushSize}"> <span id="brush-size-value">${brushSize}</span></label>
                                <button id="clear-mask" style="padding: 5px 15px;">清除遮罩</button>
                                <button id="fill-mask" style="padding: 5px 15px;">全部重绘</button>
                            </div>
                            <div style="position: relative; display: inline-block; border: 1px solid #ddd;">
                                <canvas id="drawing-canvas" style="cursor: crosshair;"></canvas>
                                <img id="drawing-image" src="${imageData}" style="position: absolute; top: 0; left: 0; pointer-events: none; opacity: 0.5;">
                            </div>
                            <div class="setting-modal-buttons">
                                <button class="cancel-btn" id="mask-cancel">取消</button>
                                <button class="save-btn" id="mask-save">保存遮罩</button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(maskModal);
                    
                    const drawingCanvas = maskModal.querySelector('#drawing-canvas');
                    const drawingImage = maskModal.querySelector('#drawing-image');
                    const drawingCtx = drawingCanvas.getContext('2d');
                    const brushSizeInput = maskModal.querySelector('#brush-size');
                    const brushSizeValue = maskModal.querySelector('#brush-size-value');
                    const clearMaskBtn = maskModal.querySelector('#clear-mask');
                    const fillMaskBtn = maskModal.querySelector('#fill-mask');
                    const maskCancelBtn = maskModal.querySelector('#mask-cancel');
                    const maskSaveBtn = maskModal.querySelector('#mask-save');
                    
                    // 初始化画布
                    const img = new Image();
                    img.onload = function() {
                        drawingCanvas.width = img.width;
                        drawingCanvas.height = img.height;
                        drawingImage.width = img.width;
                        drawingImage.height = img.height;
                        
                        // 如果有已保存的遮罩，加载它
                        if (maskData) {
                            const maskImg = new Image();
                            maskImg.onload = function() {
                                drawingCtx.drawImage(maskImg, 0, 0);
                            };
                            maskImg.src = maskData;
                        } else {
                            drawingCtx.fillStyle = '#ffffff';
                            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                        }
                    };
                    img.src = imageData;
                    
                    // 画笔大小调整
                    brushSizeInput.addEventListener('input', function() {
                        brushSize = parseInt(this.value);
                        brushSizeValue.textContent = brushSize;
                    });
                    
                    // 清除遮罩
                    clearMaskBtn.addEventListener('click', function() {
                        drawingCtx.fillStyle = '#ffffff';
                        drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    });
                    
                    // 全部重绘
                    fillMaskBtn.addEventListener('click', function() {
                        drawingCtx.fillStyle = '#000000';
                        drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
                    });
                    
                    // 绘制逻辑
                    let isDrawingMask = false;
                    let lastDrawX = 0;
                    let lastDrawY = 0;
                    
                    function getMousePos(canvas, evt) {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        return {
                            x: (evt.clientX - rect.left) * scaleX,
                            y: (evt.clientY - rect.top) * scaleY
                        };
                    }
                    
                    drawingCanvas.addEventListener('mousedown', function(e) {
                            isDrawingMask = true;
                            const pos = getMousePos(drawingCanvas, e);
                            lastDrawX = pos.x;
                            lastDrawY = pos.y;
                            
                            drawingCtx.beginPath();
                            drawingCtx.arc(pos.x, pos.y, brushSize / 2, 0, Math.PI * 2);
                            drawingCtx.fillStyle = '#000000';
                            drawingCtx.fill();
                    });
                    
                    drawingCanvas.addEventListener('mousemove', function(e) {
                        if (!isDrawingMask) return;
                        
                        const pos = getMousePos(drawingCanvas, e);
                        
                        drawingCtx.beginPath();
                        drawingCtx.moveTo(lastDrawX, lastDrawY);
                        drawingCtx.lineTo(pos.x, pos.y);
                        drawingCtx.strokeStyle = '#000000';
                        drawingCtx.lineWidth = brushSize;
                        drawingCtx.lineCap = 'round';
                        drawingCtx.lineJoin = 'round';
                        drawingCtx.stroke();
                        
                        lastDrawX = pos.x;
                        lastDrawY = pos.y;
                    });
                    
                    drawingCanvas.addEventListener('mouseup', function() {
                        isDrawingMask = false;
                    });
                    
                    drawingCanvas.addEventListener('mouseleave', function() {
                        isDrawingMask = false;
                    });
                    
                    // 取消按钮
                    maskCancelBtn.addEventListener('click', function() {
                        document.body.removeChild(maskModal);
                    });
                    
                    // 保存按钮
                    maskSaveBtn.addEventListener('click', function() {
                        maskData = drawingCanvas.toDataURL();
                        
                        // 更新预览
                        const previewImg = new Image();
                        previewImg.onload = function() {
                            maskPreview.width = previewImg.width;
                            maskPreview.height = previewImg.height;
                            maskCtx = maskPreview.getContext('2d');
                            maskCtx.drawImage(previewImg, 0, 0);
                            maskPreview.style.display = 'block';
                            maskPreviewContainer.querySelector('span').style.display = 'none';
                        };
                        previewImg.src = maskData;
                        
                        document.body.removeChild(maskModal);
                    });
                });
            }
            
            // 获取默认路径
            if (moduleData.params.name === 'Checkpoint加载器' || 
                moduleData.params.name === 'VAE解码器加载模块' || 
                moduleData.params.name === 'CLIP文本编码器加载模块' || 
                moduleData.params.name === '图片保存/显示模块') {
                // 从后端获取默认路径
                fetch('/api/get_default_paths')
                    .then(response => response.json())
                    .then(data => {
                        if (data.success) {
                            if (moduleData.params.name === 'Checkpoint加载器' || 
                                moduleData.params.name === 'VAE解码器加载模块' || 
                                moduleData.params.name === 'CLIP文本编码器加载模块') {
                                // 这些模块使用默认模型路径
                                const folderInput = modal.querySelector('#var-0');
                                if (folderInput && !folderInput.value && data.default_model_path) {
                                    folderInput.placeholder = data.default_model_path;
                                }
                            } else if (moduleData.params.name === '图片保存/显示模块') {
                                // 图片保存/显示模块使用默认图片保存路径
                                // 找到所有输入框，第二个输入框是保存路径（索引1）
                                const inputs = modal.querySelectorAll('input[type="text"]');
                                if (inputs.length >= 2) {
                                    const savePathInput = inputs[1];
                                    if (savePathInput && !savePathInput.value && data.default_image_path) {
                                        savePathInput.placeholder = data.default_image_path;
                                    }
                                }
                            }
                        }
                    })
                    .catch(error => {
                        console.error('获取默认路径失败:', error);
                    });
            }
            
            // 填充之前保存的设置
            if (Object.keys(savedSettings).length > 0) {
                console.log('加载之前保存的设置:', savedSettings);
                
                // 填充模型调用方式
                const modelSourceSelect = modal.querySelector('#model_source');
                if (modelSourceSelect && savedSettings.model_source) {
                    modelSourceSelect.value = savedSettings.model_source;
                }
                
                // 填充API设置
                const serviceProviderSelect = modal.querySelector('#service_provider');
                if (serviceProviderSelect && savedSettings.service_provider) {
                    serviceProviderSelect.value = savedSettings.service_provider;
                }
                
                const modelInput = modal.querySelector('#model');
                if (modelInput && savedSettings.model) {
                    modelInput.value = savedSettings.model;
                }
                
                const apiKeyInput = modal.querySelector('#api_key');
                if (apiKeyInput && savedSettings.api_key) {
                    apiKeyInput.value = savedSettings.api_key;
                }
                
                // 填充LM Studio设置
                const lmstudioHostInput = modal.querySelector('#lmstudio_host');
                if (lmstudioHostInput && savedSettings.lmstudio_host) {
                    lmstudioHostInput.value = savedSettings.lmstudio_host;
                }
                
                const lmstudioModelSelect = modal.querySelector('#lmstudio_model');
                if (lmstudioModelSelect && savedSettings.lmstudio_model) {
                    // 确保模型列表已加载，然后设置选中值
                    setTimeout(() => {
                        const option = Array.from(lmstudioModelSelect.options).find(opt => opt.value === savedSettings.lmstudio_model);
                        if (option) {
                            option.selected = true;
                        }
                    }, 100);
                }
                
                // 填充生成参数设置
                const temperatureInput = modal.querySelector('#temperature');
                if (temperatureInput && savedSettings.temperature !== undefined) {
                    temperatureInput.value = savedSettings.temperature;
                }
                
                const topPInput = modal.querySelector('#top_p');
                if (topPInput && savedSettings.top_p !== undefined) {
                    topPInput.value = savedSettings.top_p;
                }
                
                const topKInput = modal.querySelector('#top_k');
                if (topKInput && savedSettings.top_k !== undefined) {
                    topKInput.value = savedSettings.top_k;
                }
                
                const repetitionPenaltyInput = modal.querySelector('#repetition_penalty');
                if (repetitionPenaltyInput && savedSettings.repetition_penalty !== undefined) {
                    repetitionPenaltyInput.value = savedSettings.repetition_penalty;
                }
                
                const presencePenaltyInput = modal.querySelector('#presence_penalty');
                if (presencePenaltyInput && savedSettings.presence_penalty !== undefined) {
                    presencePenaltyInput.value = savedSettings.presence_penalty;
                }
                
                const frequencyPenaltyInput = modal.querySelector('#frequency_penalty');
                if (frequencyPenaltyInput && savedSettings.frequency_penalty !== undefined) {
                    frequencyPenaltyInput.value = savedSettings.frequency_penalty;
                }
                
                const maxTokensInput = modal.querySelector('#max_tokens');
                if (maxTokensInput && savedSettings.max_tokens !== undefined) {
                    maxTokensInput.value = savedSettings.max_tokens;
                }
                
                const stopWordsInput = modal.querySelector('#stop_words');
                if (stopWordsInput && savedSettings.stop_words !== undefined) {
                    stopWordsInput.value = savedSettings.stop_words;
                }
                
                const seedInput = modal.querySelector('#seed');
                if (seedInput && savedSettings.seed !== undefined) {
                    seedInput.value = savedSettings.seed;
                }
                
                // 填充加载图像模块设置
                if (moduleData.params.name === '加载图像模块') {
                    // 从 moduleState 中恢复之前保存的 imageData 和 maskData
                    if (moduleId) {
                        const moduleState = moduleStates[moduleId];
                        if (moduleState) {
                            imageData = moduleState.imageData || null;
                            maskData = moduleState.maskData || null;
                            console.log('从 moduleState 恢复加载图像模块数据:', { hasImage: !!imageData, hasMask: !!maskData });
                        }
                    }
                }
                
                // 填充是否保存复选框
                if (moduleData.params.name === '图片保存/显示模块' && savedSettings['是否保存'] !== undefined) {
                    const checkbox = modal.querySelector('input[name="是否保存"]');
                    if (checkbox) {
                        checkbox.checked = savedSettings['是否保存'] === true || savedSettings['是否保存'] === 'true';
                    }
                }
                
                // 填充通用变量设置
                const variableNames = moduleData.params.variables_name ? moduleData.params.variables_name.split(',') : [];
                for (let i = 0; i < variableNames.length; i++) {
                    const variableName = variableNames[i];
                    if (savedSettings[variableName] !== undefined && savedSettings[variableName] !== null) {
                        // 先尝试查找input元素
                        const input = modal.querySelector(`input[name="${variableName}"]`);
                        if (input) {
                            input.value = savedSettings[variableName];
                        } else {
                            // 如果没找到input，尝试查找select元素
                            const select = modal.querySelector(`select[name="${variableName}"]`);
                            if (select) {
                                // 如果是Checkpoint加载器、VAE解码器加载模块或CLIP文本编码器加载模块的模型文件选择，需要先刷新模型列表
                            if ((moduleData.params.name === 'Checkpoint加载器' || 
                                 moduleData.params.name === 'VAE解码器加载模块' || 
                                 moduleData.params.name === 'CLIP文本编码器加载模块') && 
                                variableName === '模型文件选择') {
                                    // 查找模型文件夹路径输入框
                                    const folderInputId = 'var-0';
                                    const folderInput = modal.querySelector(`#${folderInputId}`);
                                    if (folderInput && folderInput.value) {
                                        // 先刷新模型列表，然后通过回调设置选中值
                                        refreshModelList(`var-${i}`, folderInputId, function(success) {
                                            if (success) {
                                                // 模型列表刷新完成，设置选中值
                                                for (let j = 0; j < select.options.length; j++) {
                                                    if (select.options[j].value === savedSettings[variableName]) {
                                                        select.options[j].selected = true;
                                                        break;
                                                    }
                                                }
                                            }
                                        });
                                    } else {
                                        // 如果没有文件夹路径，直接设置选中值
                                        for (let j = 0; j < select.options.length; j++) {
                                            if (select.options[j].value === savedSettings[variableName]) {
                                                select.options[j].selected = true;
                                                break;
                                            }
                                        }
                                    }
                                } else {
                                    // 普通选择框，直接设置选中值
                                    for (let j = 0; j < select.options.length; j++) {
                                        if (select.options[j].value === savedSettings[variableName]) {
                                            select.options[j].selected = true;
                                            break;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // 添加切换模型设置的函数
            window.toggleModelSettings = function(value) {
                const apiSettings = modal.querySelector('#api_settings');
                const lmstudioSettings = modal.querySelector('#lmstudio_settings');
                const modelSelectionInputs = modal.querySelectorAll('.lmstudio-hidden');
                
                if (value === 'lmstudio') {
                    apiSettings.style.display = 'none';
                    lmstudioSettings.style.display = 'block';
                    // 隐藏默认值设置中的模型选择输入框
                    modelSelectionInputs.forEach(input => {
                        input.style.display = 'none';
                    });
                    // 加载LM Studio模型列表
                    refreshLMStudioModels();
                } else if (value === 'api') {
                    apiSettings.style.display = 'block';
                    lmstudioSettings.style.display = 'none';
                    // 隐藏默认值设置中的模型选择输入框
                    modelSelectionInputs.forEach(input => {
                        input.style.display = 'none';
                    });
                }
            };
            
            // 从LM Studio获取模型列表
            window.refreshLMStudioModels = async function() {
                const hostInput = modal.querySelector('#lmstudio_host');
                const modelSelect = modal.querySelector('#lmstudio_model');
                const refreshBtn = modal.querySelector('#refresh_models');
                const statusDiv = modal.querySelector('#model_status');
                
                if (!hostInput || !modelSelect || !refreshBtn || !statusDiv) return;
                
                const host = hostInput.value || 'http://localhost:1234';
                
                try {
                    refreshBtn.textContent = '加载中...';
                    modelSelect.innerHTML = '<option value="">加载中...</option>';
                    statusDiv.textContent = '状态: 正在获取模型列表...';
                    statusDiv.style.color = 'blue';
                    
                    // 通过后端API获取LM Studio模型列表，避免CORS错误
                    statusDiv.textContent = '状态: 通过后端API获取模型列表...';
                    
                    // 调用后端API
                    const response = await fetch(`/api/get_lmstudio_models?host=${encodeURIComponent(host)}`);
                    
                    if (!response.ok) {
                        throw new Error(`后端API错误! 状态: ${response.status}`);
                    }
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error);
                    }
                    
                    const models = data.models || [];
                    
                    statusDiv.textContent = '状态: 解析响应...';
                    
                    // 填充模型列表
                    let optionsHtml = '';
                    models.forEach(modelId => {
                        optionsHtml += `<option value="${modelId}">${modelId}</option>`;
                    });
                    
                    // 如果没有获取到模型，使用通用的模型名称作为备份
                    if (!optionsHtml) {
                        const backupModels = [
                            "abliterated",
                            "text-embedding-nomic-embed-text-v1.5"
                        ];
                        
                        backupModels.forEach(modelId => {
                            optionsHtml += `<option value="${modelId}">${modelId}</option>`;
                        });
                    }
                    
                    modelSelect.innerHTML = optionsHtml || '<option value="">未找到有效模型</option>';
                    statusDiv.textContent = `状态: 成功获取 ${models.length || 2} 个模型`;
                    statusDiv.style.color = 'green';
                    
                    console.log('通过后端API获取的LM Studio模型列表:', models.length > 0 ? models : '使用通用备份模型列表');
                    
                } catch (error) {
                    console.error('获取模型列表失败:', error);
                    
                    // 出错时使用通用的模型名称作为备份
                    const backupModels = [
                        "abliterated",
                        "text-embedding-nomic-embed-text-v1.5"
                    ];
                    
                    let optionsHtml = '';
                    backupModels.forEach(modelId => {
                        optionsHtml += `<option value="${modelId}">${modelId}</option>`;
                    });
                    
                    modelSelect.innerHTML = optionsHtml || '<option value="">未找到有效模型</option>';
                    statusDiv.textContent = `状态: 获取失败，使用通用备份模型列表 - ${error.message}`;
                    statusDiv.style.color = 'orange';
                } finally {
                    refreshBtn.textContent = '刷新模型列表';
                }
            };
            
            // 初始化模型设置显示
            const modelSourceSelect = modal.querySelector('#model_source');
            if (modelSourceSelect) {
                window.toggleModelSettings(modelSourceSelect.value);
            }
            
            // 取消按钮事件
            modal.querySelector('.cancel-btn').addEventListener('click', function() {
                document.body.removeChild(modal);
            });
            
            // 保存按钮事件
            modal.querySelector('.save-btn').addEventListener('click', async function() {
                const form = modal.querySelector('.setting-form');
                const formData = new FormData(form);
                const settings = {};
                
                // 获取默认路径
                let defaultModelPath = '';
                let defaultImagePath = '';
                if (moduleData.params.name === 'Checkpoint加载器' || 
                    moduleData.params.name === 'VAE解码器加载模块' || 
                    moduleData.params.name === 'CLIP文本编码器加载模块' || 
                    moduleData.params.name === '图片保存/显示模块') {
                    try {
                        const response = await fetch('/api/get_default_paths');
                        const data = await response.json();
                        if (data.success) {
                            defaultModelPath = data.default_model_path || '';
                            defaultImagePath = data.default_image_path || '';
                        }
                    } catch (error) {
                        console.error('获取默认路径失败:', error);
                    }
                }
                
                // 收集通用变量设置
                for (let i = 0; i < variableQuantity; i++) {
                    const variableName = variableNames[i] || `变量${i+1}`;
                    let value;
                    
                    // 特殊处理"是否保存"复选框
                    if (moduleData.params.name === '图片保存/显示模块' && variableName === '是否保存') {
                        const checkbox = modal.querySelector(`input[name="${variableName}"]`);
                        value = checkbox ? checkbox.checked : true;
                    } else {
                        value = formData.get(variableName) || '';
                    }
                    
                    // 如果是Checkpoint加载器、VAE解码器加载模块或CLIP文本编码器加载模块的模型文件夹路径且为空，使用默认路径
                    if ((moduleData.params.name === 'Checkpoint加载器' || 
                         moduleData.params.name === 'VAE解码器加载模块' || 
                         moduleData.params.name === 'CLIP文本编码器加载模块') && 
                        variableName === '模型文件夹路径' && 
                        !value && 
                        defaultModelPath) {
                        value = defaultModelPath;
                    }
                    
                    // 如果是图片保存/显示模块的保存路径且为空，使用默认路径
                    if (moduleData.params.name === '图片保存/显示模块' && 
                        variableName === '保存路径' && 
                        !value && 
                        defaultImagePath) {
                        value = defaultImagePath;
                    }
                    
                    settings[variableName] = value;
                }
                
                // 收集调用模块特殊设置
                if (moduleData.params.kind === '调用模块') {
                    settings.model_source = formData.get('model_source') || 'lmstudio';
                    settings.service_provider = formData.get('service_provider') || 'OpenAI';
                    settings.model = formData.get('model') || '';
                    settings.api_key = formData.get('api_key') || '';
                    settings.lmstudio_host = formData.get('lmstudio_host') || 'http://localhost:1234';
                    settings.lmstudio_model = formData.get('lmstudio_model') || '';
                    
                    // 收集生成参数设置
                    settings.temperature = parseFloat(formData.get('temperature') || '0.7');
                    settings.top_p = parseFloat(formData.get('top_p') || '0.9');
                    settings.top_k = parseInt(formData.get('top_k') || '40');
                    settings.repetition_penalty = parseFloat(formData.get('repetition_penalty') || '1.0');
                    settings.presence_penalty = parseFloat(formData.get('presence_penalty') || '0.0');
                    settings.frequency_penalty = parseFloat(formData.get('frequency_penalty') || '0.0');
                    settings.max_tokens = parseInt(formData.get('max_tokens') || '1000');
                    settings.stop_words = formData.get('stop_words') || '';
                    settings.seed = parseInt(formData.get('seed') || '0');
                }
                
                // 收集加载图像模块特殊设置 - 不存到sessionStorage，但临时存到settings里用于执行
                if (moduleData.params.name === '加载图像模块') {
                    if (typeof imageData !== 'undefined') {
                        settings.imageData = imageData;
                    }
                    if (typeof maskData !== 'undefined') {
                        settings.maskData = maskData;
                    }
                }
                
                // 保存设置到会话存储 - 注意：不存imageData和maskData
                const moduleKey = `module_settings_${moduleId}_${moduleData.params.name || 'default'}`;
                // 不存imageData和maskData到sessionStorage
                if (moduleData.params.name === '加载图像模块') {
                    const cleanSettings = {...settings};
                    delete cleanSettings.imageData;
                    delete cleanSettings.maskData;
                    sessionStorage.setItem(moduleKey, JSON.stringify(cleanSettings));
                } else {
                    sessionStorage.setItem(moduleKey, JSON.stringify(settings));
                }
                
                // 这里可以添加保存默认值的逻辑
                console.log('保存设置:', settings);
                console.log('设置已保存到会话存储，键名:', moduleKey);
                console.log('设置将在当前会话中保持，关闭浏览器后会被清除');
                
                // 关闭窗口
                document.body.removeChild(modal);
                
                // 如果是加载图像模块，保存完整设置到moduleState并更新显示
                if (moduleData.params.name === '加载图像模块' && moduleId) {
                    const moduleState = moduleStates[moduleId];
                    if (moduleState) {
                        moduleState.imageData = settings.imageData;
                        moduleState.maskData = settings.maskData;
                        if (settings.imageData) {
                            moduleState.imageBase64 = settings.imageData;
                            updateModuleDisplay(moduleId);
                        }
                    }
                }
                // 刷新当前模块的设置（如果需要）
                console.log('设置保存完成，可以在模块执行时使用这些设置');
            });
            
            // 点击模态框背景关闭
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    document.body.removeChild(modal);
                }
            });
        }
        
        // 刷新模型列表功能
        window.refreshModelList = async function(selectId, folderInputId, callback) {
            const select = document.getElementById(selectId);
            const folderInput = document.getElementById(folderInputId);
            if (!select || !folderInput) {
                if (callback) callback(false);
                return;
            }
            
            let folderPath = folderInput.value;
            
            // 如果文件夹路径为空，从后端获取默认路径
            if (!folderPath) {
                try {
                    const response = await fetch('/api/get_default_model_path');
                    const data = await response.json();
                    if (data.success && data.default_path) {
                        folderPath = data.default_path;
                    } else {
                        alert('请先选择模型文件夹');
                        if (callback) callback(false);
                        return;
                    }
                } catch (error) {
                    console.error('获取默认路径失败:', error);
                    alert('请先选择模型文件夹');
                    if (callback) callback(false);
                    return;
                }
            }
            
            console.log('刷新模型列表，文件夹:', folderPath);
            
            // 清空选择框
            select.innerHTML = '<option value="">正在加载...</option>';
            
            // 调用后端API扫描模型文件
            fetch('/api/scan_models', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    folder_path: folderPath
                })
            })
            .then(response => response.json())
            .then(data => {
                console.log('获取到的模型文件:', data);
                
                // 清空选择框
                select.innerHTML = '<option value="">请选择模型</option>';
                
                // 添加模型文件选项
                if (data.model_files && data.model_files.length > 0) {
                    data.model_files.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file.split(/[\\/]/).pop(); // 只显示文件名
                        select.appendChild(option);
                    });
                } else {
                    const option = document.createElement('option');
                    option.value = '';
                    option.textContent = '未找到模型文件';
                    select.appendChild(option);
                }
                
                // 调用回调函数，表示刷新完成
                if (callback) callback(true);
            })
            .catch(error => {
                console.error('刷新模型列表失败:', error);
                select.innerHTML = '<option value="">加载失败</option>';
                if (callback) callback(false);
            });
        };
    </script>
</body>
</html>